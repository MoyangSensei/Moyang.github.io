<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Fy J"><meta name="renderer" content="webkit"><meta name="copyright" content="Fy J"><meta name="keywords" content="MoyangSensei"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>操作系统四：页面置换算法 · MoYang</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="MoyangSensei" type="application/atom+xml">
</head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Fy J</div><div class="profile-signature">CS专业扫雷学深造学者互联网冲浪一级选手</div><div class="friends"><div>FRIENDS</div><span><a href="//hnjia00.github.io" target="_black">jhn</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">MoYang's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">操作系统四：页面置换算法</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>05-17-2019 15:22:51</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="操作系统"> 操作系统</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">8.5k</span> | Reading time: <span class="post-count">34</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><blockquote>
<p>原创文章，转载、引用请注明出处！<br>代码、文章及图片挂载地址：<a target="_blank" rel="noopener" href="https://github.com/MoyangSensei/OS">https://github.com/MoyangSensei/OS</a></p>
</blockquote>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>最佳置换算法、先进先出置换算法、最近最久未使用置换算法、改进型CLOCK置换算法、页面缓冲置换算法</p>
<h2 id="符合局部访问特性的随机生成算法"><a href="#符合局部访问特性的随机生成算法" class="headerlink" title="符合局部访问特性的随机生成算法"></a>符合局部访问特性的随机生成算法</h2><p>（1）确定虚拟内存的尺寸N，工作集的起始位置p，工作集中包含的页数e，工作集移动率m（每处理m个页面访问则将起始位置p +1），以及一个范围在0和1之间的值t；</p>
<p>（2）生成m个取值范围在p和p + e间的随机数，并记录到页面访问序列串中；</p>
<p>（3）生成一个随机数r，0 ≤ r ≤ 1；</p>
<p>（4）如果r &lt; t，则为p生成一个新值，否则p = (p + 1) mod N；</p>
<p>（5）如果想继续加大页面访问序列串的长度，请返回第2步，否则结束。</p>
<h2 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h2><p>（1）测试不同的页面访问序列及不同的虚拟内存尺寸，并从缺页率、算法开销等方面对各个算法进行比较。</p>
<p>（2）给出在给定页面访问序列的情况下，发生页面置换次数的平均值</p>
<hr>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="页面置换算法-1"><a href="#页面置换算法-1" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h2 id="前提及定义"><a href="#前提及定义" class="headerlink" title="前提及定义"></a>前提及定义</h2><p>由于在不同的操作系统和不同的情况下，页面置换算法的实现方式和效率是有一定出入的，因此先要对该过程的前提做规定和解释，以及对一些特定的变量作出说明。</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li><p>对于给定的页面序列，程序或功能将严格按照这个顺序进行访问，不会出现提前访问、越界访问情况；</p>
</li>
<li><p>对于给定的页面序列，每个页面的大小一定不会超过虚拟内存的大小；</p>
</li>
<li><p>对于PBA算法，需要另外给定空闲物理块数量，该数量不可超过工作物理块数量；</p>
</li>
<li><p>对于所有算法的页面填充过程，将新到来的页面填充到空白的工作物理块中，同样算作缺页。</p>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>对于各算法都通用的变量，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024</span></span><br><span class="line"><span class="comment">//页面序列总长度、工作集的起始位置p、物理块个数</span></span><br><span class="line"><span class="keyword">int</span> pageNum=<span class="number">0</span>,pageStart=<span class="number">0</span>,blockNum=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//物理块状态数组</span></span><br><span class="line"><span class="keyword">int</span> **blockSta;</span><br><span class="line"><span class="comment">//页面序列数组</span></span><br><span class="line"><span class="keyword">int</span> *page;</span><br><span class="line"><span class="comment">//页面序列指针</span></span><br><span class="line"><span class="keyword">int</span> pPage;</span><br><span class="line"><span class="comment">//缺页中断数组</span></span><br><span class="line"><span class="keyword">char</span> *interrupt;</span><br><span class="line"><span class="comment">//缺页数量</span></span><br><span class="line"><span class="keyword">int</span> lakePage;</span><br><span class="line"><span class="comment">//虚拟内存N</span></span><br><span class="line"><span class="keyword">int</span> memory;</span><br><span class="line"><span class="comment">//工作集中包含的页数e</span></span><br><span class="line"><span class="keyword">int</span> everyWorkSet;</span><br><span class="line"><span class="comment">//工作集移动率m</span></span><br><span class="line"><span class="keyword">int</span> moveRate;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于最近最久未使用置换算法（LRU）来说，需要维护一个特定的栈，该栈的功能是：当前栈顶的页面就是最长时间没有被调用过的页面。<br>该模拟栈以数组实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自写栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAX];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈的功能以函数形式定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数组中是否已有x，若有返回其下标值，没有则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(x==a[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈法插入(第一个元素出，后面元素前移，新元素从尾部入)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> m=a[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">        a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于改进型CLOCK算法来说，需要维护使用位、修改位以及生成随机的修改序列。<br>使用位、修改位定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用位</span></span><br><span class="line"><span class="keyword">bool</span> *useBit;</span><br><span class="line"><span class="comment">//修改位</span></span><br><span class="line"><span class="keyword">bool</span> *modifiedBit;</span><br><span class="line"><span class="comment">//修改页面序列</span></span><br><span class="line"><span class="keyword">bool</span> *modifiedPage;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数getRandomModifiedPage用来生成随机的修改页面序列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRandomModifiedPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//设置修改页面数量占页面总数量的比重</span></span><br><span class="line">    <span class="comment">//此处默认为0.3</span></span><br><span class="line">    <span class="keyword">double</span> modifiedRate=<span class="number">0.3</span>;</span><br><span class="line">    <span class="keyword">int</span> modifiedPageNum=<span class="built_in">ceil</span>(pageNum*modifiedRate);</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    a=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*modifiedPageNum);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//随机编号为0到pageNum-1的页面序列编号中生成modifiedPageNum个修改页面</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t==modifiedPageNum)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> RandNum = (rand()%(pageNum<span class="number">-0</span>))+<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == RandNum)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;</span><br><span class="line">            a[t] = RandNum;</span><br><span class="line">            modifiedPage[a[t]]=<span class="literal">true</span>;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于页面缓冲置换算法（LRU）来说，需要维护空闲物理块。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空闲物理块数量</span></span><br><span class="line"><span class="keyword">int</span> freeBlock;</span><br><span class="line"><span class="comment">//空闲物理块状态数组</span></span><br><span class="line"><span class="keyword">int</span> **freeBlockSta;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>最佳置换算法（OPT）是一种<em>理想情况</em>下的页面置换算法，但实际上是<strong>不可能实现</strong>的。</p>
<p>该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到10、100或者1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数进行标记。</p>
<p>最佳页面置换算法只是简单地规定：标记最大的页应该被置换。这个算法唯一的一个问题就是它无法实现。当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。对于我们的实验而言，由于我们给定了将要访问的页面的顺序序列，就相当于正确“预言”了接下来将要访问的页面，才能将这个算法实现出来。</p>
<p>虽然这个算法在实际情况不可能实现，但是<strong>最佳页面置换算法可以用于对可实现算法的性能进行衡量比较</strong>。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/1.png" alt="最佳页面置换算法流程" title="Optional title"></p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void OPT()**用来实现最佳置换算法的流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的缺页补全，替换块指针不动（填充完后又回到第一个位置）</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            <span class="comment">//nearPage：记录最近要被调用的位置</span></span><br><span class="line">            <span class="keyword">int</span> *nearPage;</span><br><span class="line">            <span class="comment">//ifFindNearPage：记录从该页面的下一个页面起到序列结束，是否有当前页面的调用</span></span><br><span class="line">            <span class="keyword">bool</span> *ifFindNearPage;</span><br><span class="line">            nearPage=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(blockNum*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            ifFindNearPage=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(blockNum*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">            <span class="comment">//向着页面序列结束的方向寻找当前物理块每一个内容最近要被调用的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                nearPage[j]=<span class="number">-1</span>;</span><br><span class="line">                ifFindNearPage[j]=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;pageNum;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(blockSta[j][i]==page[k])&#123;</span><br><span class="line">                        nearPage[j]=k;</span><br><span class="line">                        <span class="comment">//找到调用：记录调用位置</span></span><br><span class="line">                        ifFindNearPage[j]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//直到序列结束都未找到调用：调用位置设为序列长度+1</span></span><br><span class="line">                <span class="keyword">if</span>(!ifFindNearPage[j])&#123;</span><br><span class="line">                    nearPage[j]=pageNum+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最远调用的物理块</span></span><br><span class="line">            <span class="keyword">int</span> farPageNum=<span class="number">0</span>,farPage=nearPage[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(farPage&lt;nearPage[j])&#123;</span><br><span class="line">                    farPage=nearPage[j];</span><br><span class="line">                    farPageNum=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换最远调用物理块中的内容为当前页面</span></span><br><span class="line">            blockSta[farPageNum][i]=page[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物理块的填充"><a href="#物理块的填充" class="headerlink" title="物理块的填充"></a>物理块的填充</h2><p>对于上述算法来说，在第8行调用了一个名为fillFront()的函数，该函数的功能是将物理块从<strong>全部空白填充至刚好所有物理块中都有不一样的内容</strong>。</p>
<p>实际上，这个过程是非常容易想到的，即一旦遇到新的页面后，将它填充到空白物理块中即可。但是这里需要注意的是：<strong>对于一个拥有n个模拟物理块的页面置换流程来说，如果前n个页面都是两两不相同的页面，那么该过程刚好可以把这n个不相同的页面全部填充进去，从第n+1个页面开始进行淘汰和替换动作</strong>。</p>
<p>但由于我们模拟的页面序列是有局部性的，即如果不指定工作集中包含的页数e远大于工作集移动率m，这种情况几乎是很少发生的。有可能出现这样的状况：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">过程</th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">页面序列</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">物理块[1]</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">物理块[2]</td>
<td align="center">-</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">物理块[3]</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">3</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>上面的例子告诉我们，如果前n个页面中出现了重复，那么将这n个模拟物理块从全部空白填充至全部非空白所需要的“步数”就不是n了。且<strong>不论是什么样的页面置换算法，只有在将空白物理块全部利用之后才会去考虑淘汰和替换的问题</strong>。因此，按照这个思路考虑，我们的所有页面置换算法分为两个步骤进行：</p>
<p>（1）先使用一个函数来帮我们将物理块从全部空白填充至刚好所有物理块中都有不一样的内容；</p>
<p>（2）只对剩余的页面序列考虑淘汰和替换问题。</p>
<p>函数**void fillFront()**用来实现物理块填充的流程。简言之，该函数的作用是避免在此过程中的重复元素多占用物理块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b[blockNum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a&lt;blockNum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            blockSta[<span class="number">0</span>][<span class="number">0</span>]=page[pPage];</span><br><span class="line">            b[a]=page[pPage];</span><br><span class="line">            a+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                blockSta[j][pPage]=blockSta[j][pPage<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> ifFindCommon=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(page[pPage]==b[j])&#123;</span><br><span class="line">                    ifFindCommon=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!ifFindCommon)&#123;</span><br><span class="line">                blockSta[a][pPage]=page[pPage];</span><br><span class="line">                b[a]=page[pPage];</span><br><span class="line">                a+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pPage+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该函数适用于FIFO、OPT、改进型CLOCK以及PBA</strong>，之后不再赘述。</p>
<p><strong>该函数不适用于LRU</strong>：虽然是同样的填充方法，但是LRU要从头开始维护一个特殊的栈，代表物理块中的页面是否在最近被调用过。重复页面会使得该页面在特殊的栈的“位置”变得“靠前”，而其他算法并不考虑已检索的重复页面对于整个算法流程的影响（OPT考虑的是未检索过的重复页面）。</p>
<p>此函数仅仅是为了方便代码的编写以及理解整个流程，模拟算法可用之。在实际情况下一定是在分配的物理块区域内按照顺序进行检索的。</p>
<h2 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>先进先出置换算法是实现最为简单的置换算法，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。</p>
<p>其基本思想是：优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。</p>
<p>但FIFO算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。且FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由Belady于1969年发现，故称为Belady异常。</p>
<p><strong>只有FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。</strong></p>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/2.png" alt="先进先出置换算法流程" title="Optional title"></p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void FIFO()**用来实现最佳置换算法的流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的缺页补全</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置替换块指针</span></span><br><span class="line">    <span class="keyword">int</span> pReplaceBlock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            <span class="comment">//将替换指针所指向的物理块进行替换</span></span><br><span class="line">            blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">            <span class="comment">//将替换指针后移</span></span><br><span class="line">            pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>在之前的FIFO算法中，依据的是各个页面调入内存的时间，这并不能反映页面的真实使用情况。</p>
<p>而最近最久未使用置换算法（Latest Recently Used）是根据页面调入内存之后的使用情况。由于无法预测页面未来的情况，所以只能利用“最近的过去”来作为预测未来的方法，LRU选择的是最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面从上次被访问以来所经历的时间t，当需要淘汰一个页面的时候，选择现有页面中t的值最大的页面进行淘汰。</p>
<p>LRU是一种优秀的页面置换算法，但是需要硬件的支持，为了了解一个进程在内存中各个页面各有多少时间未被进程访问，以及如何快速地知道哪一个页面是最近最久未使用的页面，需要寄存器或栈来支持。</p>
<p>（1）寄存器：为了记录某进程在内存中各页的使用情况，需要为每个在内存中的页面设置一个移位寄存器，可表示为：R=R(n-1)R(n-2)…R2R1R0,当进程访问某物理块时，要将相应寄存器的R(n-1)位置成1。此时，定时信号将每隔一定时间（例如100ms）将寄存器右移一位。如果我们把n位寄存器的数看做是一个整数，那么具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。当发生缺页时，首先将它置换出去。</p>
<p>（2）栈：可以利用一种特殊的栈来保存当前使用的各个页面的页面号，每当进程访问某页面的时候，便将该页面的页面号从栈中移除，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，栈底则是最近最久未访问页面的页面号，当需要置换页面的时候，将栈底对应的页面置换出来。</p>
<h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/3.png" alt="最近最久未使用置换算法流程" title="Optional title"></p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void LRU()**用来实现最佳置换算法的流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自写栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAX];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化自写栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        <span class="built_in">stack</span>[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从页面序列的第一个开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//读数后top自动+1</span></span><br><span class="line">        top++;</span><br><span class="line">        <span class="comment">//栈中无元素：直接插入元素</span></span><br><span class="line">        <span class="keyword">if</span>(top==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top]=page[i];</span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中元素个数小于物理块个数：不重复则直接插入、重复则更新元素在栈中位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(top&lt;blockNum)&#123;</span><br><span class="line">            <span class="comment">//栈中不存在待插入元素：新元素从尾部插入</span></span><br><span class="line">            <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,blockNum,page[i])==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>[top]=page[i];</span><br><span class="line">                lakePage+=<span class="number">1</span>;</span><br><span class="line">                interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈中存在待插入元素：重复元素的位置置后，表示最近使用过</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                move(<span class="built_in">stack</span>,top,judge(<span class="built_in">stack</span>,blockNum,page[i]));</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中元素个数大于物理块个数：重复则更新元素在栈中位置、不重复就淘汰并替换元素</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//栈中不存在待插入元素：新元素栈法插入（淘汰替换旧元素）</span></span><br><span class="line">            <span class="comment">//栈法插入：第一个元素出，后面元素前移，新元素从尾部入</span></span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,blockNum,page[i])==<span class="number">-1</span>)&#123;</span><br><span class="line">                insert(<span class="built_in">stack</span>,blockNum,page[i]);</span><br><span class="line">                lakePage+=<span class="number">1</span>;</span><br><span class="line">                interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈中存在待插入元素：重复元素的位置置后，表示最近使用过</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                move(<span class="built_in">stack</span>,blockNum,judge(<span class="built_in">stack</span>,blockNum,page[i]));</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新物理块的变化情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>[j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                blockSta[j][i]=<span class="built_in">stack</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进型Clock置换算法"><a href="#改进型Clock置换算法" class="headerlink" title="改进型Clock置换算法"></a>改进型Clock置换算法</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p>
<p>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p>
<ul>
<li><p>最近未被访问，也未被修改(u=0, m=0)。</p>
</li>
<li><p>最近被访问，但未被修改(u=1, m=0)。</p>
</li>
<li><p>最近未被访问，但被修改(u=0, m=1)。</p>
</li>
<li><p>最近被访问，被修改(u=1, m=1)。</p>
</li>
</ul>
<p>在改进型CLOCK算法中，<strong>系统总是倾向于替换最近未被访问且未被修改的页面</strong>，倘若不存在这样的页面，那么系统就回去寻找最近被访问但为不修改的页面。倘若无法在为修改页面中找到符合上述两条条件的页面，那么系统就会将所有物理块均视作未访问，再去进行上述查询过程。<strong>如此这般，一定可以找到一个符合条件的页面，来进行当前页面的淘汰和替换。</strong></p>
<h3 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/4.png" alt="改进型CLOCK置换算法流程" title="Optional title"></p>
<h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void CLOCK_better()**用来实现最佳置换算法的流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLOCK_better</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机生成修改页序列</span></span><br><span class="line">    getRandomModifiedPage();</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//设置替换块指针</span></span><br><span class="line">    <span class="keyword">int</span> pReplaceBlock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的使用位和修改位、缺页补全，替换块指针不动（填充完后又回到第一个位置）</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="comment">//所有的useBit全部为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            <span class="keyword">bool</span> ifFindReplaceBlock=<span class="literal">false</span>;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第一次寻找：find(0,0)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;!modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第二次寻找：find(0,1)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//将集合中所有页面的使用位设置成0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                useBit[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第三次寻找（使用位已修改）：find(0,0)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;!modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                useBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第四次寻找（使用位已修改）：find(0,1)</span></span><br><span class="line">            <span class="comment">//如果进行到此处，一定可以找到结果，否则证明代码逻辑出现错误</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                useBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="页面缓冲算法（PBA）"><a href="#页面缓冲算法（PBA）" class="headerlink" title="页面缓冲算法（PBA）"></a>页面缓冲算法（PBA）</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>页面缓冲算法是目前Linux系统较为常见的一种页面置换算法。</p>
<p>当需要置换页面时，采用FIFO从所有以分配页面中选择最先进入的页面淘汰。该算法规定将一个被淘汰的页放入两个链表中的一个，即如果页面未被修改，就将它直接放入空闲链表中；否则，便放入已经修改页面的链表中的一个。须注意的是，这时页面在内存中并不做物理上的移动，而只是将页表中的表项移到上述两个链表之一中。</p>
<h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/5.png" alt="页面缓冲算法流程" title="Optional title"></p>
<h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void PBA()**用来实现最佳置换算法的流程。</p>
<p>该函数实现的PBA算法不是标准概念的实现，区别在于没有模拟修改页面物理块和对空闲物理块的数量进行动态分配，只是模拟了固定数量的空闲物理块的情况。</p>
<p>按照这样的思想去实现，可以推测，这样进行的流程结果，与FIFO是完全一致的（工作物理块的变化情况）。<strong>如果在把空闲物理块调用至工作物理块的步骤也算作缺页的前提下（这一点非常重要）</strong>，连缺页率的计算结果也会和同情况下的FIFO一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PBA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//设置替换块指针：此处的更替指针的原理与FIFO是相同的</span></span><br><span class="line">    <span class="keyword">int</span> pReplaceBlock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的缺页补全，替换块指针不动（填充完后又回到第一个位置）</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock;j++)&#123;</span><br><span class="line">            freeBlockSta[j][i]=freeBlockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//是否在缓冲物理块内</span></span><br><span class="line">            <span class="keyword">int</span> inFreeBLockLocation=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(page[i]==freeBlockSta[j][i])&#123;</span><br><span class="line">                    inFreeBLockLocation=j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在缓冲物理块内</span></span><br><span class="line">            <span class="keyword">if</span>(inFreeBLockLocation!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//产生缺页</span></span><br><span class="line">                lakePage+=<span class="number">1</span>;</span><br><span class="line">                interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                <span class="comment">//将两块的内容交换</span></span><br><span class="line">                <span class="keyword">int</span> temp=blockSta[pReplaceBlock][i];</span><br><span class="line">                blockSta[pReplaceBlock][i]=freeBlockSta[inFreeBLockLocation][i];</span><br><span class="line">                freeBlockSta[inFreeBLockLocation][i]=temp;</span><br><span class="line">                <span class="comment">//将替换指针后移</span></span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="comment">//将这一块的内容放到最后</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=inFreeBLockLocation;j&lt;freeBlock<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    freeBlockSta[j][i]=freeBlockSta[j+<span class="number">1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">                freeBlockSta[freeBlock<span class="number">-1</span>][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> spaceFreeBlock=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(freeBlockSta[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">                        spaceFreeBlock=j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//有空白的缓冲物理块：</span></span><br><span class="line">                <span class="comment">//当前物理块填入空白物理块</span></span><br><span class="line">                <span class="comment">//当前页面填入当前物理块</span></span><br><span class="line">                <span class="keyword">if</span>(spaceFreeBlock!=<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//产生缺页</span></span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    <span class="comment">//将替换指针所指向的物理块进行替换</span></span><br><span class="line">                    freeBlockSta[spaceFreeBlock][i]=blockSta[pReplaceBlock][i];</span><br><span class="line">                    blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                    <span class="comment">//将替换指针后移</span></span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不存在空白的缓冲物理块</span></span><br><span class="line">                <span class="comment">//将空闲物理块的最后一个位置的内容替换成当前的页面，缺页操作同上</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//产生缺页</span></span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    <span class="comment">//temp保留当前物理块内容</span></span><br><span class="line">                    <span class="comment">//当前工作物理块填入当前页面作为新内容</span></span><br><span class="line">                    <span class="keyword">int</span> temp=blockSta[pReplaceBlock][i];</span><br><span class="line">                    blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                    <span class="comment">//抛弃空闲物理块第一块的内容，temp放入最后一块的内容</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                        freeBlockSta[j][i]=freeBlockSta[j+<span class="number">1</span>][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    freeBlockSta[freeBlock<span class="number">-1</span>][i]=temp;</span><br><span class="line">                    <span class="comment">//将替换指针后移</span></span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="页面序列随机算法"><a href="#页面序列随机算法" class="headerlink" title="页面序列随机算法"></a>页面序列随机算法</h2><p>显而易见的是，<strong>用来测试上述页面置换算法的页面序列不可以用全随机的方式生成。不加限制的随机序列必然不符合局部性原理</strong>。如果页面序列不符合局部性，势必会使得缺页率大大增加。</p>
<p>实现题目中所给的页面序列随机算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符合局部访问特性的随机生成算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRandomPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">double</span> t=rand()%<span class="number">10</span>/<span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)(pageNum/moveRate);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i*moveRate;j&lt;(i+<span class="number">1</span>)*moveRate;j++)&#123;</span><br><span class="line">            page[j]=(pageStart+rand()%everyWorkSet)%memory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> r=rand()%<span class="number">10</span>/<span class="number">10.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;t)&#123;</span><br><span class="line">            pageStart=rand()%memory;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pageStart=(pageStart+<span class="number">1</span>)%memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列的最后几个内容的长度不足以构成工作集移动的一步，单另填充，规则不变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)(pageNum/moveRate)*moveRate;i&lt;pageNum;i++)&#123;</span><br><span class="line">        page[i]=(pageStart+rand()%everyWorkSet)%memory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;生成的随机序列为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;page[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行结果及对比分析"><a href="#运行结果及对比分析" class="headerlink" title="运行结果及对比分析"></a>运行结果及对比分析</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入内容分为两部分，第一部分要输入页面序列长度、页面起始位置、物理块数、每个工作集包含的页面数、工作集移动率，共五个参数；第二部分针对PBA算法输入缓冲物理块数量，限制是该数量需要小于工作物理块数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键入信息</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入页面序列长度、页面起始位置、物理块数、每个工作集包含的页面数、工作集移动率:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;pageNum&gt;&gt;pageStart&gt;&gt;blockNum&gt;&gt;everyWorkSet&gt;&gt;moveRate;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;PBA算法中的缓冲物理块数量(需小于工作物理块数):&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;freeBlock;</span><br><span class="line">        <span class="keyword">if</span>(freeBlock&lt;blockNum)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;缓冲物理块数量有误，请重新输入:&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在接下来的测试中，输入固定如下：</p>
<pre><code>输入页面序列长度、页面起始位置、物理块数、每个工作集包含的页面数、工作集移动率:32 1 3 5 10
PBA算法中的缓冲物理块数量(需小于工作物理块数):2</code></pre>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>使用上面的输入，对于不同的随机序列，运行结果如下：</p>
<ul>
<li><p>第一次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/6.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/7.png" title="Optional title"></p>
</li>
<li><p>第二次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/8.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/9.png" title="Optional title"></p>
</li>
<li><p>第三次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/10.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/11.png" title="Optional title"></p>
</li>
<li><p>第四次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/12.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/13.png" title="Optional title"></p>
</li>
<li><p>第五次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/14.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/15.png" title="Optional title"></p>
</li>
</ul>
<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><ul>
<li>统计上述测试的缺页率：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">第一次运行</th>
<th align="center">第二次运行</th>
<th align="center">第三次运行</th>
<th align="center">第四次运行</th>
<th align="center">第五次运行</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OPT</td>
<td align="center">0.40625</td>
<td align="center">0.40625</td>
<td align="center">0.4375</td>
<td align="center">0.375</td>
<td align="center">0.40625</td>
</tr>
<tr>
<td align="center">FIFO</td>
<td align="center">0.4375</td>
<td align="center">0.5625</td>
<td align="center">0.59375</td>
<td align="center">0.5</td>
<td align="center">0.625</td>
</tr>
<tr>
<td align="center">LRU</td>
<td align="center">0.59375</td>
<td align="center">0.5</td>
<td align="center">0.5625</td>
<td align="center">0.4375</td>
<td align="center">0.59375</td>
</tr>
<tr>
<td align="center">改进型CLOCK算法</td>
<td align="center">0.71875</td>
<td align="center">0.78125</td>
<td align="center">0.71875</td>
<td align="center">0.6875</td>
<td align="center">0.65625</td>
</tr>
<tr>
<td align="center">PBA</td>
<td align="center">0.4375</td>
<td align="center">0.5625</td>
<td align="center">0.59375</td>
<td align="center">0.5</td>
<td align="center">0.625</td>
</tr>
</tbody></table>
<ul>
<li>针对不同的算法，5次运行的缺页率均值如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">OPT</th>
<th align="center">FIFO</th>
<th align="center">LRU</th>
<th align="center">改进型CLOCK算法</th>
<th align="center">PBA</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0.40625</td>
<td align="center">0.54375</td>
<td align="center">0.5375</td>
<td align="center">0.712</td>
<td align="center">0.54375</td>
</tr>
</tbody></table>
<p>首先，<strong>OPT的缺页率是所有算法中最低的</strong>，这同样符合该算法的定义和其命名“最佳”。</p>
<p><strong>LRU算法的性能接近于OPT</strong>。但是从实现角度来说，其实现比较困难，且开销大：需要额外维护物理块中页面的调用顺序。</p>
<p>FIFO算法实现简单，<strong>但其机制决定了它的实际性能应该是最差的</strong>。PBA算法的缺页率和FIFO相同，这是由于模拟度不够且做了一些假设前提而导致的。<strong>它们的区别并不体现在缺页率上</strong>。</p>
<p><strong>那么PBA和FIFO的区别何在？在于PBA将缺页内容放在缓冲块（空闲物理块）里，而不存入内存里，不需要去内存调用对应的块，从系统资源的角度来说，节省了系统开销。这一点在我们的模拟中是无法体现的。</strong></p>
<p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<strong>但在上述测试中，改进型CLOCK算法的性能是最差的。</strong>由于该算法引入了修改页序列，所以导致了这一情况。<strong>可以推测，如果页面序列里没有修改页，即这些算法的流程是完全一致的，那么改进型CLOCK算法的性能会接近LRU，而FIFO的性能会变成最差。</strong></p>
<hr>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091?fr=aladdin">百度百科-页面置换算法：https://baike.baidu.com/item/页面置换算法/7626091?fr=aladdin</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626051?fr=aladdin">百度百科-最佳页面置换算法：https://baike.baidu.com/item/最佳页面置换算法/7626051?fr=aladdin</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/3286551">百度百科-先进先出页面置换算法：https://baike.baidu.com/item/先进先出页面置换算法/3286551</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/3334556?fr=aladdin">百度百科-局部性原理：https://baike.baidu.com/item/局部性原理/3334556?fr=aladdin</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://hjzgg.github.io/resume/">操作系统页面置换算法(opt,lru,fifo,clock)实现：https://hjzgg.github.io/resume/</a></p>
</blockquote>
</article><!-- lincense--><div class="post-paginator"><a class="prevSlogan" href="/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9ALL(1)%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" title="编译原理：LL(1)语法分析"><span>< PreviousPost</span><br><span class="prevTitle">编译原理：LL(1)语法分析</span></a><a class="nextSlogan" href="/2019/04/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90/" title="编译原理：递归下降分析"><span>NextPost ></span><br><span class="nextTitle">编译原理：递归下降分析</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%90%88%E5%B1%80%E9%83%A8%E8%AE%BF%E9%97%AE%E7%89%B9%E6%80%A7%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">符合局部访问特性的随机生成算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E6%B5%8B"><span class="toc-number">1.3.</span> <span class="toc-text">性能评测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94"><span class="toc-number">2.</span> <span class="toc-text">解答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-1"><span class="toc-number">2.1.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E5%8F%8A%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">前提及定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%8F%90"><span class="toc-number">2.2.1.</span> <span class="toc-text">前提</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">最佳置换算法（OPT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A"><span class="toc-number">2.3.3.</span> <span class="toc-text">代码及注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9D%97%E7%9A%84%E5%A1%AB%E5%85%85"><span class="toc-number">2.4.</span> <span class="toc-text">物理块的填充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">先进先出置换算法（FIFO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">代码及注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">最近最久未使用置换算法（LRU）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">2.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-2"><span class="toc-number">2.6.2.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-2"><span class="toc-number">2.6.3.</span> <span class="toc-text">代码及注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8BClock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">改进型Clock置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">2.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-3"><span class="toc-number">2.7.2.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-3"><span class="toc-number">2.7.3.</span> <span class="toc-text">代码及注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95%EF%BC%88PBA%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">页面缓冲算法（PBA）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">2.8.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-4"><span class="toc-number">2.8.2.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-4"><span class="toc-number">2.8.3.</span> <span class="toc-text">代码及注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%BA%8F%E5%88%97%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">页面序列随机算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">2.10.</span> <span class="toc-text">运行结果及对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">2.10.1.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">2.10.2.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">2.10.3.</span> <span class="toc-text">对比分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">参考链接</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>