<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MoyangSensei</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-09T11:55:58.472Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Fy J</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础：视频摘要</title>
    <link href="http://example.com/2020/09/03/%E5%9F%BA%E7%A1%80%EF%BC%9A%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/"/>
    <id>http://example.com/2020/09/03/%E5%9F%BA%E7%A1%80%EF%BC%9A%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/</id>
    <published>2020-09-03T10:53:58.000Z</published>
    <updated>2020-09-09T11:55:58.472Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="视频摘要概念简介"><a href="#视频摘要概念简介" class="headerlink" title="视频摘要概念简介"></a>视频摘要概念简介</h2><blockquote><p>什么是视频摘要？为什么要研究这项技术？</p></blockquote><p>近年来，随着人们对社会公共安全的需求不断增长，各大公共场所都安装了大量的监控摄像头，用于提高安防系统的侦查和报警水平。大量的监控摄像头实时录制了海量的视频数据，<strong>但这些视频数据的利用率极低</strong>。因为监控探头在每一天的24小时不间断记录，而往往人们所需要的信息只是很短的一部分，通常都是在成百上千个小时的监控视频中寻找个位数分钟的有价值部分。所以，如何在海量的数字视频中准确地找到感兴趣的视频片段已成为行业的迫切需求与巨大挑战。</p><p><strong>视频摘要是通过分析视频的结构与内容，从原视频中提取出有意义的信息，并重新组合有意义信息，浓缩成可以充分表现视频语义内容的概要。</strong></p><p>视频摘要是用一段静态图像或动态视频序列的长视频内容的缩略总结，供用户进行浏览和分析。视频摘要技术可以按照用户需求，将几十小时视频浓缩为十几分钟甚至更少，大幅度缩短视频观看浏览的时间，再利用视频目标特征检索技术，对视频底层特征进行语义分析，辅助用户迅速定位感兴趣目标。视频摘要与检索技术可以辅助用户充分挖掘海量视频监控录像中的有意义信息，提高海量监控视频录像分析与响应效率。</p><h2 id="视频摘要技术分类"><a href="#视频摘要技术分类" class="headerlink" title="视频摘要技术分类"></a>视频摘要技术分类</h2><p>视频摘要技术在近20年内已被国内外的学者广泛关注，并取得了一定的研究成果。</p><p>按照摘要结果表现形式的不同，视频摘要可分为静态视频摘要与动态视频摘要。</p><p><strong>目前，监控领域的视频摘要技术主要有两种形式：静态视频摘要中的基于关键帧的摘要和动态视频摘要中的基于对象的视频摘要。二者都可以大大缩短视频长度，方便对视频的观看、分析和检索。</strong></p><blockquote><p>基于关键帧的视频摘要的最小单位是“帧”，存储空间较小且方便传输，但不能完整表示每个目标的运动轨迹，不利于视频目标检索。基于对象的视频摘要的最小单位是“对象”，可以最大限度的减少时间冗余信息与空间冗余信息，且为视频检索等上层开发提供对象结构，能在监控安防中快速响应紧急事件，定位到事件相关“对象”，但存在处理复杂，摘要生成困难的问题。</p></blockquote><h3 id="静态视频摘要"><a href="#静态视频摘要" class="headerlink" title="静态视频摘要"></a>静态视频摘要</h3><p>静态的视频摘要是以一系列从原始视频流中抽取出的<strong>静态语义单元</strong>来表现视频的内容。静态语义单元是如关键帧、标题、 幻灯片等可以概括表示视频镜头内容的静态特征信息。</p><blockquote><p>目前静态视频摘要研究主要是基于关键帧选取方法开展的，关键帧又称故事板，是从原始视频中提取的反映镜头中主要信息内容的一帧或多帧图像。通过多个关键帧组合成视频摘要，允许用户通过少量的关键帧快速浏览原始视频的内容，并提供快速检索。经典的关键帧选取的算法主要利用颜色、运动矢量等视觉特征去区分帧间的差异性。但差异性的区分计算依赖阈值的选择，选择过程计算量较大，实时性困难。</p></blockquote><p>基于关键帧的视频摘要具有结果简单，观看方便的优点。但由于其以静态图像为结果的表达形式，很难准确地表达视频的内在语义，且对“对象”动态特性的描述不全面，所以仅仅适用于视频的精彩瞬间生成，无法适应需要进行“对象”特性分析的场合。</p><h3 id="动态视频摘要"><a href="#动态视频摘要" class="headerlink" title="动态视频摘要"></a>动态视频摘要</h3><p>基于对象的视频摘要，是一种近些年来提出的主要用于监控视频领域的动态视频摘要技术，通过提取用户感兴趣对象，然后重组感兴趣对象得到视频摘要。</p><blockquote><p>对象的提取主要使用背景建模技术、运动目标检测与跟踪技术及视觉分析技术，对象的重组主要考虑用户关注度、压缩比、多视频融合等因素。</p></blockquote><p>这种方法能有效地保持视频内容随时间动态变化的特征，同时最大限度地减少时间-空间冗余，但存在对象提取困难及很难解决复杂场景下的视频摘要生成的问题。</p><p>实际上，可将静态视频技术中的提取关键帧的技术融入到动态视频摘要中：即直接提取视频中的关键帧合成新的视频。此类方法虽然也可以缩短视频的时长，但是合成后视频给人一种快进看电影的感觉，而且实际使用较少。</p><h2 id="视频摘要技术评估方法"><a href="#视频摘要技术评估方法" class="headerlink" title="视频摘要技术评估方法"></a>视频摘要技术评估方法</h2><p>视频摘要技术中最常用的评估方法是基于用户对视频内容的主观理解，让多个观众对视频中重要内容进行标注打分，综合所有人员的标注结果作为参考标准。然后，将视频摘要方法得到的视频摘要结果与参考标准进行比较，得到准确度来衡量视频摘要结果好坏。</p><p>在已有视频摘要研究中，最常用的评估方法是计算Precision、Recall和F-measure值，在有些方法中也会用到mAP（mean Average Precision）。</p><h1 id="部分视频摘要方法复现及评估"><a href="#部分视频摘要方法复现及评估" class="headerlink" title="部分视频摘要方法复现及评估"></a>部分视频摘要方法复现及评估</h1><h2 id="SeDMi"><a href="#SeDMi" class="headerlink" title="SeDMi"></a>SeDMi</h2><ul><li>论文：Video Synopsis based on a Sequential Distortion Minimization Method</li></ul><blockquote><p>4个引用。</p></blockquote><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/1.png" title="Optional title"></p><blockquote><p>Fig. 1 illustrates a scheme of the proposed system architecture. The proposed<br>method can be divided into several steps. Initially, we estimate the CLD for each frame of the original video. Next, we performed shot detection (see Section 3.1). Based on the shot detection results and to the given parameter α we estimate the number of frames per shot that the video synopsis (see Section 3.1). Finally, the video distortion is sequentially minimized according to the proposed methods resulting to the video synopsis (see Section 3.2).</p></blockquote><ul><li>代码：官方提供的代码为matlab版本。</li></ul><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/2.png" title="Optional title"></p><ul><li>示例视频：foreman.avi。</li></ul><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/3.png" title="Optional title"></p><ul><li><p>实验：<strong>最主要的参数为“关键帧抽取百分比”</strong>，论文中给出的结果里，这项参数设置为百分之十。修改为0.2、0.05以及0.02分别运行。</p></li><li><p>结果：在上述4组关键帧抽取百分比下运行，代码运行的时常都不超过10s。可在此处下载结果：<a href="/download/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/SeDMi.zip">SeDMi在foreman下的四组结果视频</a> 。</p></li><li><p>观感：<strong>非常像快进</strong>，而且foreman.avi本身就很短，看不太出效果来。</p></li><li><p>注意：后期版本的Matlab（2018a）或者是Mac环境下，使用VideoReader函数读取视频文件时，不支持.avi格式，需要进行格式转换（大概率是Mac环境不兼容，上面的实验都将avi转为mp4后才不会报错）。</p></li></ul><h2 id="Web-based-video-synopsis-system-using-Apache-Spark"><a href="#Web-based-video-synopsis-system-using-Apache-Spark" class="headerlink" title="Web-based video synopsis system using Apache Spark"></a>Web-based video synopsis system using Apache Spark</h2><ul><li>简介：基于Apache Spark的视频概要系统，分为前端页面和后台算法处理。</li></ul><blockquote><p>The project proposes a system that can be divided into two parts: the frontend web pages and the backstage processing algorithm based on Apache Spark. In the web pages, users can upload as well as download video clip. This project designs and implements a synopsis algorithm in the backstage which uses background subtraction to grab all the frames containing moving targets in a video and then concatenate all the frames into a new shorter clip. The algorithm connects to Spark cluster. After users upload a video to be condensed on web page, the algorithm will process it and return success information to users after generating the new video. Then users can download the new video from the download page.</p></blockquote><ul><li>代码：<a href="https://github.com/question0914/VideoSynopsis">https://github.com/question0914/VideoSynopsis</a></li></ul><blockquote><p>5个星标，用的人不是很多。</p></blockquote><ul><li>运行：clone下来之后本地运行网页，给提交视频的按钮过不去：会提示无法找到h5代码中该处的form标签下的/video/upload，所以就无法验证运行结果。</li></ul><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/4.png" title="Optional title"></p><ul><li>其他：有前端的话感觉比较容易实现和看结果，这一项比较希望能复现。后端代码用的是java。</li></ul><h2 id="DimensionFour"><a href="#DimensionFour" class="headerlink" title="DimensionFour"></a>DimensionFour</h2><blockquote><p>这个模型没有打底的论文，不清楚为什么叫这个名字。</p></blockquote><ul><li>简介：一个git上的开源工具，用到了Keras YOLOv3做目标识别，用到了ImageAI（猜测是用来做遮挡物后的人的运动预测），然后做动态物体的标注，可能会有合成的操作（后面会根据运行的结果提到）。</li></ul><blockquote><p>YOLOv3：</p><blockquote><p><a href="https://github.com/qqwweee/keras-yolo3">https://github.com/qqwweee/keras-yolo3</a><br><a href="https://pjreddie.com/media/files/papers/YOLOv3.pdf">https://pjreddie.com/media/files/papers/YOLOv3.pdf</a></p></blockquote></blockquote><ul><li>代码：<a href="https://github.com/kevinvincent/DimensionFour">https://github.com/kevinvincent/DimensionFour</a></li></ul><blockquote><p>8个星标，用的人不是很多。</p></blockquote><ul><li>示例视频：项目提供了dataset，共有三个视频，根据长度的不同命名为long、preferred以及short，都是街头监控探头拍下的画面，主要的对象为移动的人：</li></ul><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/5.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/6.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/7.png" title="Optional title"></p><ul><li><p>实验：先要对视频进行预处理，然后对提取出来的视频帧做集合和标注。</p></li><li><p>结果：在本机的cpu版本的tf下运行，最长的视频在1h内处理完成，最短的视频处理时间不到10min。但是经过处理后的视频的大小会有非常明显的变大。视频格式由.mp4转为.avi。以下给出的是long的展示：</p></li></ul><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/8.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/9.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/10.png" title="Optional title"></p><ul><li><p>观感：整体效果而言，对每个移动的人的标注做的很不错。视频有拼接的痕迹，不是很明显：移动到画面边缘的人会直接消失；在遮挡物背后的人的有些画面的处理会变得模糊。但是缩放比例不是特别出色，5min的long.mp4处理后也有4min，但各个视频的缩放比例确实不一样，推测是根据具体的场景来做的，不是按比例抽帧。</p></li><li><p>注意：tensorflow==1.7.0、keras==2.1.6、Opencv、h5py、ImageAI，以及下载需要yolo.h5（代码中会检测，没有这个模型文件的话会自动下载，需要科学上网，238m，早期版本的yolo文件不适用）。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;视频摘要概念简介&quot;</summary>
      
    
    
    
    
    <category term="视频摘要" scheme="http://example.com/tags/%E8%A7%86%E9%A2%91%E6%91%98%E8%A6%81/"/>
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>论文研读：SRGAN</title>
    <link href="http://example.com/2020/07/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASRGAN/"/>
    <id>http://example.com/2020/07/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASRGAN/</id>
    <published>2020-07-18T02:41:02.000Z</published>
    <updated>2020-09-09T11:58:05.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><blockquote><p>Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network</p></blockquote><p><strong>这篇文章第一次将将生成对抗网络用在了解决超分辨率问题上。</strong></p><blockquote><p>生成对抗网络，Generative Adversarial Network，GAN；</p><blockquote><p>GAN = G + D + 其他；</p></blockquote><blockquote><p>G：以次充好；D：明辨是非；其他：具体问题具体分析；</p></blockquote></blockquote><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/1.png" title="Optional title"></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>G：残差块 + 卷积层 + BN层 + PReLU</p><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>常规的卷积层。</p><h3 id="BN层"><a href="#BN层" class="headerlink" title="BN层"></a>BN层</h3><blockquote><p>Batch Normalization: Accelerating Deep Network Training by  Reducing Internal Covariate Shift</p></blockquote><p>在多数网络中，BN层的作用主要有以下四个：</p><ul><li>可以选择比较大的初始学习率，显著提高网络的训练速度</li></ul><blockquote><p>在此之前的深度网络的训练，需要慢慢的调整学习率，甚至在网络训练到中间的时候，还需要考虑对学习率进行渐进的调整，有了BN之后，可以采用初始很大的学习率，然后学习率的衰减速度也很大，因为这个算法收敛很快。当然这个算法即使在选择了较小的学习率，也比以前的收敛速度快，因为它具有快速训练收敛的特性。</p></blockquote><ul><li><p>无需再理会过拟合中drop out、L2正则项参数的选择问题。采用BN算法后，网络可以移除这两项了参数，或者可以选择更小的L2正则约束参数了，因为BN具有提高网络泛化能力的特性；</p></li><li><p>再也无需使用使用局部响应归一化层（局部响应归一化是Alexnet网络用到的方法），因为BN本身就是一个归一化网络层；</p></li><li><p>可以把训练数据彻底打乱。</p></li></ul><blockquote><p>防止每批训练的时候，某一个样本都经常被挑选到，原文说可以提高1%的精度。</p></blockquote><p>BN在SRGAN里并不是重点。<strong>ESRGAN有改进到这个点。</strong></p><h3 id="Residual-blocks"><a href="#Residual-blocks" class="headerlink" title="Residual blocks"></a>Residual blocks</h3><blockquote><p>为什么要使用残差块？意义如何？</p></blockquote><p>在生成器的前6层网络中，运用了残差块。</p><p>使用残差块的意义是：当损失函数从D开始反向传播回G的时候，实际上进过来很多层。<strong>众所周知，越深的网络隐藏参数越多，在反向传播的过程中也越容易梯度弥散。</strong>而且残差连接的方法，就有效的保证了梯度信息能够有效的传递而增强生成对抗网络的鲁棒性。</p><p><strong>很多的GAN类模型有这样的操作。</strong></p><p><strong>ESRGAN也针对残差做了改进。</strong></p><h2 id="为什么使用GAN来解决Image-SR的问题？"><a href="#为什么使用GAN来解决Image-SR的问题？" class="headerlink" title="为什么使用GAN来解决Image SR的问题？"></a>为什么使用GAN来解决Image SR的问题？</h2><p>传统插值方法可以看做把像素复制放大倍数后，用某种固定的卷积核去卷积。</p><p>类似于SRCNN这样的基于卷积神经网络的方案也容易理解：学习上述卷积核，根据构建出的超分图像与真实的高分辨率图像(Ground Truth)的差距去更新网络参数。这种方法的损失函数一般都采用均方误差MSE。</p><p>当前监督SR效果的算法（损失函数）的优化目标是使恢复后的HR图像与ground truth间的均方差（MSE）最小化。这样做的目的是：取得很高的PSNR。但是由于PSNR是基于像素级图像（pixel-wise image）的差异来定义的，因此PSNR捕捉到和人的感官非常密切的差异（纹理细节）的能力十分有限，<strong>因此最高的PSNR不一定能反映人感官上最好的结果。</strong>放大倍数越大，越不平滑的情况下PSNR越低。不过从视觉上说最为真实，因为过于平滑会使得图像内部物体的边缘看起来模糊。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/2.png" title="Optional title"></p><p>上图中的图三是SRGAN给出的结果。PSNR虽然比图二低了近0.1，但是图二的脸和手明显是模糊的，看起来很不真实，图三的各个细节都很清晰，真实度比图二更高。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/3.png" title="Optional title"></p><blockquote><p>while GAN drives the reconstruction towards the natural image manifold producing perceptually more convincing solutions.</p></blockquote><p>这张图也说明的是上述问题。一旦放大倍数超过4，那么基于MSE优化的网络产生出来的HR图像在纹理细节方面就会过于平滑，看起来就像是糊成一团，但就是这样PSNR还有很高的得分。</p><p><strong>换言之，SRGAN没有以PSNR/MSE为“最高指示”，它更注重人的主观的评价（SRGAN在PSNR的表现确实很一般）。</strong></p><p>为了证明“高PSNR并不能带来良好的感官效果”这个观点，原文给出了一个指标，称为Mean opinion score（MOS），是26位评判者的打分。在这26位评委眼中，SRGAN产生的图像更真实：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/4.png" title="Optional title"></p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/5.png" title="Optional title"></p><h2 id="Discriminator"><a href="#Discriminator" class="headerlink" title="Discriminator"></a>Discriminator</h2><p>D：VGG19 + LeakyReLU + max-pooling</p><h3 id="VGG19"><a href="#VGG19" class="headerlink" title="VGG19"></a>VGG19</h3><blockquote><p>Very deep convolutional networks for large-scale image recognition</p></blockquote><p>上面提到了SRGAN以人的主观感受为主旨来进行网络的训练。</p><p>于是会出现一个无法避免的问题：即使在同一个领域内以及对评判人做过筛选，人的感官也是一定是极其主观的评判。<strong>换言之，人的主观感受是无法用数学的语言去确切表达的。</strong>那么该如何实现以感官的标准来指定监督算法（损失函数）呢？</p><p><strong>作者所选择的是基于VGG的内容损失。</strong>先基于预训练的19层VGG网络的ReLU激活层来定义损失函数。内容损失的实质就是从VGG19网络里提取的特征图之间欧式距离的损失函数，无论是超分辨率还是艺术风格的转移，效果都非常好。</p><h2 id="如何使用GAN解决Image-SR的问题？"><a href="#如何使用GAN解决Image-SR的问题？" class="headerlink" title="如何使用GAN解决Image SR的问题？"></a>如何使用GAN解决Image SR的问题？</h2><p>GAN的工作过程：给定一个低分辨率图片作为噪声z的输入，通过生成器的变换把噪声的概率分布空间尽可能的去拟合真实数据的分布空间。</p><p>而在SRGAN中生成器的输入不再是噪声，而是低分辨率图像；而判别器结构跟普通的GAN没有什么区别。</p><p>综上，SRGAN的功能叙述为：<strong>把LR看成是一个噪声z的输入，那么G的作用就是生成的是一个fake的HR，D的作用是要去分辨G生成的fakeHR与原始的HR之间的区别，给出判断。</strong></p><h1 id="min-max方程"><a href="#min-max方程" class="headerlink" title="min-max方程"></a>min-max方程</h1><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/6.png" title="Optional title"></p><p>对于判别器D，希望D最大,所以加号之前的log部分应该最大,意味着判别器D可以很好的识别出，真实的高分辨率图像是”true”。而要让log尽可能的大，加号后的这部分中的ΘD(ΘG(z))要尽可能的小，意味着生成模型复原的图片应该尽可能的被D视为”FALSE”。</p><p>对于生成器G，应该让G尽可能的小，加号前面的式子并没有G，加号后面的式子中要让ΘG尽可能地小,就要ΘD(ΘG(Z))尽可能的大，也就是说本来就一张低分辨率生成的图片，判别器却被迷惑了，以为是一张原始的高分辨率图片。</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><h2 id="Perceptual-loss-function"><a href="#Perceptual-loss-function" class="headerlink" title="Perceptual loss function"></a>Perceptual loss function</h2><blockquote><p>Perceptual Losses for Real-Time Style Transfer and Super-Resolution and Super-Resolution</p></blockquote><p>最重要的就是本文特别定制的生成器D的损失函数，可以说就是为了这个损失函数才采用GAN的。这个特制的损失函数被称为感知损失，Perceptual loss function。结构如下：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/7.png" title="Optional title"></p><p>其中，加号左边是Content loss（内容损失），加号右边是Adversarial loss（对抗损失，包括系数）。</p><h3 id="Content-loss"><a href="#Content-loss" class="headerlink" title="Content loss"></a>Content loss</h3><p>与先前的基于深度学习的超分方法相比，SRGAN的D在Loss上只有一个明显的变化：Loss不再单是对构建出来图片与真实高分辨率图片求MSE，而是<strong>加上对构建出图片的特征图与真实高分辨率图片在VGG19下的特征图求MSE</strong>。</p><p>简言之，内容损失=原MSE+特征图MSE：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/8.png" title="Optional title"></p><blockquote><p>原文中没有上述公式。</p><p>原文中也并未明确地指出要加和原MSE，只是给出了VGG19特征图的MSE。</p></blockquote><p>加号左边是原MSE：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/9.png" title="Optional title"></p><p>其中，θσ是网络参数，ILR是低分辨率图像，减号后面的部分是重建出来的高分辨率图像，  减号之前的是真实的高分辨率图像，r、W、H分别是图片数量、图片宽和高，都可以看成常数。</p><p>加号右边是VGG19特征图的MSE，称为VGG loss：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/10.png" title="Optional title"></p><p>VGG loss与原MSE相比，多的部分是φij，指的是第i个maxpooling层前的第j个卷积的特征图。</p><blockquote><p>VGG Loss的权重，1e-6是个超参，是TensorLayer的设置，设置到这么小应该是因为用了所有的特征图。</p></blockquote><h3 id="Adversarial-loss"><a href="#Adversarial-loss" class="headerlink" title="Adversarial loss"></a>Adversarial loss</h3><p>除了内容损失以外，还要加上一个GAN原有的对抗损失：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/11.png" title="Optional title"></p><p>其中，log内的部分是判别器对于生成超分图片的输出，-log(x)在（0,1）上是个单调递减的函数。前面提到，生成器D希望log内部分的值越大越好，也就是-log(x)越小越好，因此梯度更新的时候需要最小化对抗损失。</p><h3 id="生成器D的Loss"><a href="#生成器D的Loss" class="headerlink" title="生成器D的Loss"></a>生成器D的Loss</h3><p>综上，生成器D的Loss</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/12.png" title="Optional title"></p><p>这一部分在Tensorflow平台上的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_gan_loss = <span class="number">1e-3</span> * tl.cost.sigmoid_cross_entropy(logits_fake, tf.ones_like(logits_fake))</span><br><span class="line">mse_loss = tl.cost.mean_squared_error(fake_patchs, hr_patchs, is_mean=<span class="literal">True</span>)</span><br><span class="line">vgg_loss = <span class="number">2e-6</span> * tl.cost.mean_squared_error(feature_fake, feature_real, is_mean=<span class="literal">True</span>)</span><br><span class="line">g_loss = mse_loss + vgg_loss + g_gan_loss</span><br></pre></td></tr></table></figure><p>代码中的logits_real和logits_fake分别判别器对是真实高分图片、GAN生成的高分图片的输出。fake_patchs, hr_patchs分别是生成器的输出、真实的高分图片。feature_fake、feature_real是构建的图片、真实图片在VGG网络中的特征图。</p><h2 id="判别器D的Loss"><a href="#判别器D的Loss" class="headerlink" title="判别器D的Loss"></a>判别器D的Loss</h2><p>D的Loss用到了sigmoid交叉熵。</p><p>这一部分在Tensorflow平台上的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d_loss1 = tl.cost.sigmoid_cross_entropy(logits_real, tf.ones_like(logits_real))</span><br><span class="line">d_loss2 = tl.cost.sigmoid_cross_entropy(logits_fake, tf.zeros_like(logits_fake))</span><br><span class="line">d_loss = d_loss1 + d_loss2</span><br></pre></td></tr></table></figure><blockquote><p>损失函数softmax_cross_entropy、binary_cross_entropy、sigmoid_cross_entropy之间的区别与联系：<a href="https://www.jianshu.com/p/47172eb86b39">https://www.jianshu.com/p/47172eb86b39</a></p></blockquote><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>实验部分给出的结论是</p><ul><li><p>未针对实时视频SR进行优化；</p></li><li><p>较浅的网络有可能提供非常有效的替代方案，但质量性能会有小幅度的降低。而更深层次的网络架构是也可以给出更高的结果。原文针对这一点给出的解释是：推测ResNet的设计对深层网络的性能有很大的影响：即使是更深层次的网络（B&gt;16）也可以进一步提高SRResNet的性能，但代价是需要更长的培训和测试时间。且由于高频伪影的出现，更深层次网络的SRGAN变体越来越难以训练。</p></li></ul><blockquote><p> In contrast to Dong et al. [10], we found deeper network architectures to be beneficial. We speculate that the ResNet design has a substantial impact on the performance of deeper networks. We found that even deeper networks (B &gt; 16) can further increase the performance of SRResNet, however, come at the cost of longer training and testing times (c.f. supple- mentary material). We further found SRGAN variants of deeper networks are increasingly difficult to train due to the appearance of high-frequency artifacts.</p></blockquote><p>对比实验做的是SRGAN在不同的卷积网络的深度下的效果，显然也是网络越深效果越好。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/13.png" title="Optional title"></p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SRGAN/14.png" title="Optional title"></p><p>VGG54取得了最好的视觉效果，原文给出的解释是：更深层的网络层在远离像素空间的情况下代表更高抽象的特征。</p><blockquote><p>In this work, we found lSR VGG/5.4 to yield the perceptually most convincing results, which we attribute to the potential of deeper network layers to represent features of higher abstraction [68, 65, 40] away from pixel space.</p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>文章：<a href="https://arxiv.org/pdf/1609.04802.pdf">https://arxiv.org/pdf/1609.04802.pdf</a></p></li><li><p>code：<a href="https://github.com/tensorlayer/srgan">https://github.com/tensorlayer/srgan</a> 、<a href="https://github.com/aitorzip/PyTorch-SRGAN">https://github.com/aitorzip/PyTorch-SRGAN</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Photo-Realistic Single Image Super-Resolution Using a Generative Adv</summary>
      
    
    
    
    
    <category term="论文研读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    <category term="图像超分辨率" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>论文研读：SRCNN</title>
    <link href="http://example.com/2020/07/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASRCNN/"/>
    <id>http://example.com/2020/07/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASRCNN/</id>
    <published>2020-07-18T02:38:15.000Z</published>
    <updated>2020-09-09T11:58:37.788Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><blockquote><p>Learning a Deep Convolutional Network for Image Super-Resolution</p></blockquote><p><strong>SRCNN是深度学习用在超分辨率重建上的开山之作。</strong></p><h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><p>SRCNN的网络结构非常简单，仅仅用了三个卷积层，网络结构如下所示：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/17.png" title="Optional title"></p><p>SRCNN网络包含三个模块：Patch extraction and representation（块析出与表示）、Non-linear mapping（非线性映射）、Reconstruction（重构）。<strong>这三个模块对应三个卷积操作。</strong></p><ul><li><p>第一层CNN：对输入图片的特征提取。（9x9x64卷积核）；</p></li><li><p>第二层CNN：对第一层提取的特征的非线性映射（1x1x32卷积核）；</p></li><li><p>第三层CNN：对映射后的特征进行重建，生成高分辨率图像（5x5x1卷积核）。</p></li></ul><p>在进行卷积操作之前，SRCNN对图像进行了一个预处理：将输入的低分辨率图像进行bicubic插值，将低分辨率图像放大成目标尺寸。接下来才是上面提到的三层卷积网络拟合非线性映射，最后输出高分辨率图像结果。</p><blockquote><p>插值后的图像依旧称为“低分辨率图像”，并用Y表示；将ground-truth（真实的高分辨率图像）用X表示；将网络记为映射函数F（·）；</p></blockquote><p>网络的总思路来源于稀疏编码，作者将上述三个过程表述为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/18.png" title="Optional title"></p><h2 id="Patch-extraction-and-representation"><a href="#Patch-extraction-and-representation" class="headerlink" title="Patch extraction and representation"></a>Patch extraction and representation</h2><p>块析出和表示的目的是通过输入图像Y获得一系列特征图：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/19.png" title="Optional title"></p><p>其中W1和B1表示滤波器（卷积核）的权重和偏置，max操作对应ReLU激活函数。</p><blockquote><p>Here W1 is of a size c × f1 × f1 × n1, where c is the number of channels in the input image, f1 is the spatial size of a filter, and n1 is the number of filters.<br>B1 is an n1-dimensional vector, whose each element is associated with a filter.</p></blockquote><blockquote><p>卷积+激活操作。</p></blockquote><h2 id="Non-linear-mapping"><a href="#Non-linear-mapping" class="headerlink" title="Non-linear mapping"></a>Non-linear mapping</h2><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/20.png" title="Optional title"></p><p>其中W2和B2表示滤波器的权重和偏置，max操作依旧对应ReLU激活函数。</p><blockquote><p>第二层和第一层的思路完全一致，实际上这里想表述的是可以添加更多的层，但是这样的操作会显著增加网络的计算开销。</p><blockquote><p>It is possible to add more convolutional layers (whose spatial supports are 1× 1) to increase the non-linearity. But this can significantly increase the complexity of the model, and thus demands more training data and time. In this paper, we choose to use a single convolutional layer in this operation, because it has already provided compelling quality.</p></blockquote></blockquote><h2 id="Reconstruction"><a href="#Reconstruction" class="headerlink" title="Reconstruction"></a>Reconstruction</h2><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/21.png" title="Optional title"></p><blockquote><p>Here W3 is of a size n2 ×f3 ×f3 ×c, and B3 is a c-dimensional vector.<br>W3：线型滤波器</p><blockquote><p>we expect that W3 behaves like first projecting the coefficients onto the<br>image domain and then averaging. In either way, W3 is a set of linear filters.</p></blockquote></blockquote><p>重构依旧是卷积操作，但是这里没有激活函数了。</p><p><strong>根据上面的三个公式，SRCNN仅有6个需要学习的参数：W1、B1、W2、B2、W3、B3。</strong></p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>损失的计算也仅仅需要网络的输出F(Y)与真实高分图像X，<strong>损失函数选择MSE损失：</strong></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/22.png" title="Optional title"></p><p>选择MSE作为Loss的原因：有利于提高PSNR。</p><blockquote><p>Using MSE as the loss function favors a high PSNR.</p></blockquote><p>实际上，卷积神经网络对损失函数的限制只有一个，即损失函数为可导函数。<strong>如果在训练过程中给出一个更好的感知激励指标，则网络可以灵活地适应该指标。</strong>但原文提到“会做研究但很难实现”。</p><blockquote><p>The PSNR is a widely-used metric for quantitatively evaluating image restoration quality, and is at least partially related to the perceptual quality. It is worth noticing that the convolu- tional neural networks do not preclude the usage of other kinds of loss functions, if only the loss functions are derivable. If a better perceptually motivated metric is given during training, it is flexible for the network to adapt to that metric. We will study this issue in the future. On the contrary, such a flexibility is in general difficult to achieve for traditional “hand-crafted” methods.</p></blockquote><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>分别以Running Time和PSNR为指标并与多种方法进行了对比实验。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/23.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/24.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/25.png" title="Optional title"></p><blockquote><p>SC：sparse coding，稀疏编码</p><blockquote><p>Image super-resolution via sparse representation, 2010</p></blockquote><p>K-SVD</p><blockquote><p>On single image scale-up using sparse representations, 2012</p></blockquote><p>NE+LLE：neighbour embedding + locally linear embedding，邻域嵌入+局部线性嵌入</p><blockquote><p>Super-resolution through neighbor embedding, 2004</p></blockquote><p>NE+NNLS：neighbour embedding + non-negative least squares，邻域嵌入+非负最小二乘法</p><blockquote><p>Low-complexity single image super-resolution based on nonnegative neighbor embedding, 2012</p></blockquote><p>ANR：Anchored Neighbourhood Regression，锚定邻域回归</p><blockquote><p>Anchored neighborhood regression for fast example-based super-resolution, 2013</p></blockquote></blockquote><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/26.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/27.png" title="Optional title"></p><p>给出了4个种类的图片的SR结果及对比。原文中提到，在“baby”的类别上PSNR并未达到最好的效果。以下给出两组。</p><blockquote><p>经典的“Butterfly”和原文中提到的PSNR不达标的“Baby”。</p><blockquote><p>In spite of the best average PSNR values, the proposed SRCNN does not achieve the highest PSNR on images “baby” and “head” from Set5. Nevertheless, our results are still visually appealing (see Figure 10).</p></blockquote></blockquote><h2 id="模型对数据量的敏感性"><a href="#模型对数据量的敏感性" class="headerlink" title="模型对数据量的敏感性"></a>模型对数据量的敏感性</h2><p>文章使用SRCNN分别在ImageNet和Timofte数据集这两个数据集上分别进行了实验。在ImageNet上获得的PSNR值明显高于在Timofte数据集上的结果。这里的结论是：<strong>在迭代次数相同的情况下，数据量的增加可能会提高网络的性能。</strong></p><h2 id="模型对卷积核数量的敏感性"><a href="#模型对卷积核数量的敏感性" class="headerlink" title="模型对卷积核数量的敏感性"></a>模型对卷积核数量的敏感性</h2><p>SRCNN中第一层包含n1=64个卷积核，第二层包含n2=32个卷积核。<strong>根据理论，增加网络的卷积核数量必然会提升模型的性能。</strong></p><p>作者尝试做了额外的增加以及减少卷积核数量两种情况：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/28.png" title="Optional title"></p><p>从上表可以看出，增加卷积核数量确实会获得更高的PSNR值，但是同时会增加计算时间。<strong>所以需要在时间和质量之间做一个权衡。</strong></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>训练数据集：Timofte数据集（包含91幅图像）和ImageNet数据集（数据量超大）；</p></li><li><p>文章：<a href="http://personal.ie.cuhk.edu.hk/~ccloy/files/eccv_2014_deepresolution.pdf">http://personal.ie.cuhk.edu.hk/~ccloy/files/eccv_2014_deepresolution.pdf</a> ；</p></li><li><p>code：<a href="http://mmlab.ie.cuhk.edu.hk/projects/SRCNN.html">http://mmlab.ie.cuhk.edu.hk/projects/SRCNN.html</a> ,有matlab版本和Caffe版本；</p></li><li><p>文章比较简单，内容都在字面上，比较好理解。方法超前但是借鉴的痕迹很重，因此没有那种“专事专办”的味道。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Learning a Deep Convolutional Network for Image Super-Resolution&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="论文研读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    <category term="图像超分辨率" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>基础：图像超分辨率</title>
    <link href="http://example.com/2020/07/18/%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    <id>http://example.com/2020/07/18/%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/</id>
    <published>2020-07-18T02:37:07.000Z</published>
    <updated>2020-09-09T11:58:54.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>图像超分辨率，Image Super Resolution（SR）；</p></li><li><p>概念：SR是指通过<strong>软件或硬件</strong>的方法，从观测到的低分辨率（low resolution）图像重建出相应的高分辨率（high resolution）图像；</p></li></ul><blockquote><p>更直白的表述为：提高图像的分辨率，使被观察图像给出更清晰的图像表述。</p><blockquote><p>图像超分辨率重建关注的是恢复图像中丢失的细节，即高频信息。在大量的电子图像应用领域，人们经常期望得到高分辨率（简称HR）图像。但由于设备、传感器等原因，我们得到的图像往往是低分辨率图像（LR）。增加空间分辨率最直接的解决方法就是通过传感器制造技术减少像素尺寸（例如增加每单元面积的像素数量）；另外一个增加空间分辨率的方法是增加芯片的尺寸，从而增加图像的容量。因为很难提高大容量的偶合转换率，所以这种方法一般不认为是有效的，因此，引出了图像超分辨率技术。</p></blockquote><blockquote><p>图像分辨率：指图像中存储的信息量，是每英寸图像内有多少个像素点，分辨率的单位为PPI（Pixels Per Inch），通常叫做像素每英寸。一般情况下，图像分辨率越高，图像中包含的细节就越多，信息量也越大。图像分辨率分为空间分辨率和时间分辨率。通常，分辨率被表示成每一个方向上的像素数量，例如64*64的二维图像。但分辨率的高低其实并不等同于像素数量的多少，例如一个通过插值放大了5倍的图像并不表示它包含的细节增加了多少。</p></blockquote></blockquote><ul><li><p>应用：在监控设备、卫星图像遥感、数字高清、显微成像、视频编码通信、视频复原和医学影像等领域都有重要的应用价值。</p></li><li><p>分类：SR的应用方向大致可分为两种。一是Image SR。只参考当前低分辨率图像，不依赖其他相关图像，称之为单幅图像的超分辨率（single image super resolution，SISR）。Image SR的方法多种多样，从最基础的插值到现如今的深度学习，是一个非常热门的研究方向。另一是Video SR。参考多幅图像或多个视频帧的超分辨率技术，称之为多帧视频/多图的超分辨率（multi-frame super resolution）。</p></li></ul><hr><h1 id="传统的Image-SR技术"><a href="#传统的Image-SR技术" class="headerlink" title="传统的Image SR技术"></a>传统的Image SR技术</h1><h2 id="基于插值的Image-SR"><a href="#基于插值的Image-SR" class="headerlink" title="基于插值的Image SR"></a>基于插值的Image SR</h2><h3 id="何为“插值”？"><a href="#何为“插值”？" class="headerlink" title="何为“插值”？"></a>何为“插值”？</h3><p>通过某个点周围若干个已知点的值，以及周围点和此点的位置关系，根据一定的公式，算出此点的值，就是插值法。</p><p>例如，有如下2*2的图像，不同颜色代表不同的像素点值：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/1.png" title="Optional title"></p><p>使用插值算法给上面的这张图像做细节扩充，形成一张4*4大小的图像：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/2.png" title="Optional title"></p><p>由于已经得知原2*2图像中的4个像素点的值，那么在接下来的操作中，仅需要求剩余12个点（黑色）的值即可。通过某个点周围若干个已知点的值，以及周围点和此点的位置关系，根据一定的公式，算出此点的值，就是插值法。如何把原图像的点摆放在新图中（确定具体坐标）；未知的点计算时，需要周围多少个点参与，公式如何。对于上面的问题，<strong>不同的方案选择，就是不同的插值算法。</strong></p><p><strong>常用的插值算法有：最邻近元法,双线性内插法,双三次内插法等</strong>。</p><p>实际上，这类插值算法，提升的图像细节有限，所以使用较少。通常，通过多幅图像之间的插值算法来重建是一个手段。</p><blockquote><p>以2*2为例。放大2倍后，得到一个4*4的图片。其中(0,0)的灰度值与之前的(0,0)相同。(2,0) 与之前的 (1,0)的灰度值相同。那么，这个放大图像的 (1,0)的灰度值等于什么呢？等于原图像的（1/2,0）的灰度值。但是原图像并没有这个点，通过以下插值方法，可计算该点的像素值灰度。</p></blockquote><h3 id="最邻近插值"><a href="#最邻近插值" class="headerlink" title="最邻近插值"></a>最邻近插值</h3><p>这是最简单的插值算法。思路是：当图片放大时，缺少的像素通过直接使用与之最近原有颜色生成。</p><blockquote><p>可理解为“按比例放大”：放大之后缺少的内容，直接照搬最近的已知的内容。</p></blockquote><p>首先要确定：原图像的像素摆放在新图中的具体坐标。新坐标对应源图中的坐标可以由如下公式得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srcX &#x3D; dstX * ( srcWidth &#x2F; dstWidth )</span><br><span class="line">srcY &#x3D; dstY * ( srcHeight &#x2F; dstHeight )</span><br></pre></td></tr></table></figure><blockquote><p>这里依旧可以用“按比例放大”来理解：将srcWidth / dstWidth称为缩放系数K。</p></blockquote><blockquote><p>坐标必然是整数，但是上述公式不一定会得到整数（K不一定为整数）。当2*2放大到4*4，结果和2.2.1中相同。但如果将2*2放大到3*3，就会出现新的像素点坐标计算出来有小数点的情况。这里需要采用的策略是四舍五入的方法（也可直接舍掉小数位），把非整数坐标转换成整数。</p></blockquote><p>接下来，以图片的左上角建立坐标，并将待求象素的四已知邻象素中左上角的看作[i,j]，则待求像素的值依赖于以下四个已知坐标：[i,j]、[i,j+1]、[i+1,j]、[i+1,j+1]，对于每一个待求象素，将距离待求象素最近的邻灰度赋给待求象素。</p><blockquote><p>当待求像素距离四个已知邻象素的距离中的两个及以上都是最小时，给定一个统一的规则即可，例如：要么都取原坐标中的小值，要么都取大值等。</p></blockquote><blockquote><p>图像右侧和下侧的待求像素并不像图像中部的像素，拥有四个已知邻象素。它们最多拥有1个（图像右下角的区域）或2个邻象素，规则也是同样的。</p></blockquote><p>对于上面的2*2图像，扩大到3*3和4*4时，将得到：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/3.png" title="Optional title"></p><blockquote><p>由于2*2实在是太小，下面的两种插值法的到的3*3和4*4实际上和上面这个结果是一致的。</p></blockquote><p><strong>最邻近插值有着明显的缺陷，它会使结果图像产生明显可见的锯齿。</strong></p><h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>在数学上，双线性插值是有两个变量的插值函数的线形插值扩展，其核心思想是在两个方向分别进行一次线性插值。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/4.png" title="Optional title"></p><p>假设已知上图中已知红色数据点的值，要求是通过双线性插值得到绿色数据点的值。将需求描述为数学方式：预得到未知函数f在点P(x,y)的值，并假设已知函数f有Q11、Q12、Q21、Q22四个坐标。</p><p>首先在x方向进行线性插值，得到：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/5_1.png" title="Optional title"><br><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/5_2.png" title="Optional title"></p><p>然后在y方向进行线性插值，得到：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/6.png" title="Optional title"></p><p>那么未知函数f就可以描述如下：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/7_1.png" title="Optional title"><br><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/7_2.png" title="Optional title"></p><p>如果选择一个坐标系统使得f的四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，那么插值公式就可以化简为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/8.png" title="Optional title"></p><p>用矩阵运算表示为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/9.png" title="Optional title"></p><p>双线性内插法的结果通常不是线性的，线性插值的结果与插值的顺序无关。双线性内插法的计算比最邻近点法复杂，计算量较大但，没有灰度不连续的缺点。具有低通滤波性质，使高频分量受损，图像轮廓可能会有一点模糊。</p><blockquote><p>先进行y方向的插值，然后进行x方向的插值，所得到的结果同先x后y是一致的。</p></blockquote><p><strong>相对于最近邻插值简单的四舍五入，双线性插值的处理更为科学，优化了边缘保护。</strong></p><h3 id="双三次内插法"><a href="#双三次内插法" class="headerlink" title="双三次内插法"></a>双三次内插法</h3><blockquote><p>Cubic Convolution Interpolation for Digtial Image Processing</p></blockquote><p>双三次插值（bicubic）又称双立方插值。</p><p>在数值分析这个数学分支中，双三次插值是二维空间中最常用的插值方法。在这种方法中，函数f在点(x,y)的值可以通过矩形网格中最近的十六个采样点的加权平均得到，在这里需要使用两个多项式插值三次函数，每个方向使用一个。</p><p>双三次插值的本质就是用使用了两次Cubic Interpolation。</p><h4 id="Cubic-Interpolation"><a href="#Cubic-Interpolation" class="headerlink" title="Cubic Interpolation"></a>Cubic Interpolation</h4><h5 id="f-0-、f-1-已知"><a href="#f-0-、f-1-已知" class="headerlink" title="f(0)、f(1)已知"></a>f(0)、f(1)已知</h5><blockquote><p>假设已知f(0)，f(1)以及其导数一共四个值。用Cubic Interpolation计算f(0.5)的值。</p></blockquote><p>假设：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/10.png" title="Optional title"></p><p>因为已知f(0)、f(1)以及其导数四个值：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/11.png" title="Optional title"></p><p>可得：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/12.png" title="Optional title"></p><p>通过解出上述四个代数，可以算出f(0.5)。 </p><h5 id="f-0-、f-1-未知"><a href="#f-0-、f-1-未知" class="headerlink" title="f(0)、f(1)未知"></a>f(0)、f(1)未知</h5><blockquote><p>大多数情况下，并不知道f(0)、f(1)的导数。</p></blockquote><p>设f(-1)=P0、f(0)=P1、f(1)=P2、f(2)=P3。有：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/13.png" title="Optional title"></p><p>后两值一般使用相邻两个点的斜率代替。但在更多的情况下，并不知道边缘值的斜率（因为边缘点的相邻两个点知道不完全）。所以有如下两个方法去代替：</p><ul><li><p>Left: p0 = p1、Right: p3 = p2</p></li><li><p>Left: p0 = 2p1 - p2、Right: p3 = 2p2 - p1</p></li></ul><h4 id="两次Cubic-Interpolation"><a href="#两次Cubic-Interpolation" class="headerlink" title="两次Cubic Interpolation"></a>两次Cubic Interpolation</h4><blockquote><p>原来的一次导数，变成了偏导。</p></blockquote><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/14.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/15.png" title="Optional title"></p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/16.png" title="Optional title"></p><p><strong>这四个点的灰度值必然满足第一个方程。</strong>通过上述三组方程，求出所有未知数。从而计算f(0.5,0)。</p><h3 id="插值法的总结"><a href="#插值法的总结" class="headerlink" title="插值法的总结"></a>插值法的总结</h3><p>对于上述三种不同的插值技术：</p><p><strong>特性</strong>：最邻近插值，名称非常直白，核心是四舍五入选取最接近的整数。这样的做法就会导致像素的变化不连续，在图像中的体现就是会有锯齿。双线性插值则是利用与坐标轴平行的两条直线去把小数坐标分解到相邻的四个整数坐标点的和。双三次插值与双线性插值类似，只不过用了相邻的16个点。</p><p><strong>坐标权重</strong>：前两种方法能回保证两个方向的坐标权重和为1，但是双三次插值不能保证这点，所以又可能去出现像素值越界的情况，需要截断。</p><p><strong>效果与泛用性</strong>：双三次插值通常能产生效果最好、最精确的插补图形，但它速度也是最慢的。双线性插值的速度则要快一些，但没有前者精确。在商业性图像编辑软件中，经常采用的是速度最快，但也是最不准确的最近相邻插值。</p><h2 id="基于重建的Image-SR"><a href="#基于重建的Image-SR" class="headerlink" title="基于重建的Image SR"></a>基于重建的Image SR</h2><h3 id="何为“重建”？"><a href="#何为“重建”？" class="headerlink" title="何为“重建”？"></a>何为“重建”？</h3><p>基于重建的SR，其基础是均衡及非均衡采样定理。这类算法的思路大多都是通过多帧低分辨率的图像恢复出一幅高分辨率图像，利用低分辨率图像中的丰富信息来进行超分辨处理，从而获得比观测图像分辨率更高的图像，即它假设低分辨率的输入采样信号（图像）能很好地预估出原始的高分辨率信号（图像）。绝大多数超分辨率算法都属于这一类，进一步的分类则有频域法和空域法。</p><blockquote><p>Nyquist-Shannon采样定理：如果希望得到的采样型号有旋转和相位变化，那么采样周期要小于整数周期的1/2，采样频率应该大于原始频率的2倍。同理，对于模拟信号，如果希望得到信号的各种特性，采样频率应该大于原始模拟信号的最大频率的两倍，否则将发生混叠（相位/频率模糊）。</p></blockquote><blockquote><p>在统计、信号处理和相关领域中，混叠是指取样信号被还原成连续信号时产生彼此交叠而失真的现象。当混叠发生时，原始信号无法从取样信号还原。而混叠可能发生在时域上，称做时间混叠，或是发生在频域上，被称作空间混叠。</p></blockquote><h4 id="频率域方法"><a href="#频率域方法" class="headerlink" title="频率域方法"></a>频率域方法</h4><p>频率域方法是图像超分辨率重建中一类重要方法，其中最主要的是消混叠重建方法。</p><blockquote><p>消混叠重建方法是通过解混叠而改善图像的空间分辨率实现超分辨率复原。在原始场景信号带宽有限的假设下，利用离散傅立叶变换和连续傅立叶变换之间的平移、混叠性质，给出了一个由一系列欠采样观察图像数据复原高分辨率图像的公式。多幅观察图像经混频而得到的离散傅立叶变换系数与未知场景的连续傅立叶变换系数以方程组的形式联系起来，方程组的解就是原始图像的频率域系数，再对频率域系数进行傅立叶逆变换就可以实现原始图像的准确复原。</p></blockquote><h4 id="空间域方法"><a href="#空间域方法" class="headerlink" title="空间域方法"></a>空间域方法</h4><p>在空间域方法中，其线性空域观测模型涉及全局和局部运动、光学模糊、帧内运动模糊、空间可变点扩散函数、非理想采样等内容。空域方法具有很强的包含空域先验约束的能力，主要包括非均匀空间样本内插、迭代反投影方法（IBP）、凸集投影法（POCS）、最大后验概率、最优和自适应滤波方法、确定性重建方法等。</p><h3 id="非均匀空间样本内插"><a href="#非均匀空间样本内插" class="headerlink" title="非均匀空间样本内插"></a>非均匀空间样本内插</h3><p>非均匀空域样本内插法是最直观的超分辨率图像重建算法，一般包含三个基本步骤：（1）运动估计；（2）非线性内插得到高分辨率图像；（3）解除混叠。非均匀空间样本内插法首先对低分辨率视频序列进行运动补偿，继而采用内插的方法产生分辨率较高的合成图像，以这个合成图像中作为初始值，再用Landweber迭代法重建超分辨率图像，最后对超分辨率图像进行去模糊操作。</p><p>非均匀空间样本内插方法运算量较低，能适用于实时任务；但过于简单化，在重建时不能得到比低分辨率图像中更多地频率成分，退化模型受限制，只适用于模糊和嗓声特性对全部低分辨率图像都一样的情况，也没有使用先验约束。</p><h3 id="凸集投影法（POCS）"><a href="#凸集投影法（POCS）" class="headerlink" title="凸集投影法（POCS）"></a>凸集投影法（POCS）</h3><p>凸集投影算法是把未知图像假设为一个适宜的希尔伯特空间中的元素，关于未知图像的每一个先验知识或约束限制了希尔伯特空间中的一个封闭凸集的解，引入幅度边界的限制，导出求解未知图像的迭代公式,由初始估计迭代计算超分辨率图像。利用集合论方法来恢复超分辨率图像，它有效地利用了空间范围观察模型，同时允许包含先验信息。</p><p>综上，POCS算法是一个迭代过程，给定超分辨率图像空间上的任意一个点，来定位一个能满足所有凸集的点。</p><h3 id="迭代反投影法（IBP）"><a href="#迭代反投影法（IBP）" class="headerlink" title="迭代反投影法（IBP）"></a>迭代反投影法（IBP）</h3><p>顾名思义，该算法也是一个迭代过程。在迭代反投影法中，首先估计一个高分辨率图像作为初始解（通常采用的是单幅低分辨率图像的额差值结果），然后根据系统模型，计算其模拟低分辨率图像（1984年提出时，示例为线型模型）。如果初始解与与原始的高分辨率图像精确相等，并且模拟成像过程符合实际情况，则模拟低分辨率序列应与观察到的实际的低分辨率图像相等。当两者不同时，将它们之间的误差反向投影到初始解上，使其得到修正。当误差满足要求时，结束迭代过程，给出最终结果。</p><p><strong>IBP算法直观，计算简单，但是由于没有考虑嗓声的影响，对高频嗓声非常敏感，并且由于逆问题的病态性，该方法没有唯一解，选择系数也有一些难度。与POCS等一些空间域方法相比，IBP算法难以利用空间先验信息。</strong></p><h3 id="统计复原类方法"><a href="#统计复原类方法" class="headerlink" title="统计复原类方法"></a>统计复原类方法</h3><p>统计复原方法将SR看成是一个统计估计问题。它为求解病态的超分辨率问题加入必要的先验约束，为能得到满意解提供了可能。<strong>常用的统计复原方法包括最大后验概率（MAP）估算法和最大似然（ML）估算方法。</strong>最大后验概率就是在己知低分辨率序列的前提下，使出现高分辨率图像的后验概率达到最大，最大似然估算方法可认为是最大后验概率先脸模型下的特例。</p><blockquote><p>最大后验概率估计是后验概率分布的众数。利用最大后验概率估计可以获得对实验数据中无法直接观察到的量的点估计。</p></blockquote><blockquote><p>最大似然估计一种重要而普遍的求估计量的方法。最大似然法明确地使用概率模型，其目标是寻找能够以较高概率产生观察数据的系统发生树。</p></blockquote><h3 id="混合MAP-POCS方法"><a href="#混合MAP-POCS方法" class="headerlink" title="混合MAP/POCS方法"></a>混合MAP/POCS方法</h3><p>POCS和MAP是重建类SR算法中效果出众的两种，两者都很容易引入先验知识。其中POCS算法保持图像边缘和细节的能力很强，但收敛稳定性不高，没有唯一解，降嗓能力不强；MAP有唯一解且收效稳定性高，降嗓能力强，但边缘和细节保持能力不如POCS。混合MAP/POCS方法则结合两者的优势特征，得到HR图像的最佳估计。</p><p>混合MAP/POCS方法有效结合了全部先验知识，并且能确保唯一的最优解，是一种重建效果较好的算法。</p><h3 id="滤波类方法"><a href="#滤波类方法" class="headerlink" title="滤波类方法"></a>滤波类方法</h3><p><strong>IBP、POCS、MAP、MAP/POCS等几种超分辨率算法的运算量大，只能应用于实时性要求不高的图像SR情况，如遥感图像和医学图像的超分辨率处理。</strong>在实时性要求比较高的情况下，例如实时视频的超分辨率复原，要求算法既能提高图像的分辨率，运算复杂度又比较低。滤波的方法，如自适应滤波、Wiener滤波和Kalman滤波等方法运算复杂度低，适用于对运算速度要求比较高的场合。 </p><h2 id="基于学习的Image-SR"><a href="#基于学习的Image-SR" class="headerlink" title="基于学习的Image SR"></a>基于学习的Image SR</h2><p>在超分辨率重建的过程中，随着要求分辨率倍数的增加，低分辨率图像序列的冗余信息已经不能提供满足要求的高频细节。通过增加低分辨率图像序列帧数的方法得到的高频信息也是不能满足实际要求的。在这种情况下，利用神经网络的方法，通过学习训练来获得图像的先验信息，可以得到包含更多细节的高分辨率图像。</p><p><strong>从理论上讲，如果训练集合是通用的，就可以利用这个训练集合对各种类型的图像进行放大。</strong></p><p>机器学习领域（非深度学习邻域）的一些主流的Image SR方法如下：</p><ul><li><p>Example-based方法</p></li><li><p>邻域嵌入方法</p></li><li><p>支持向量回归方法</p></li><li><p>虚幻脸</p></li></ul><blockquote><p>很多人脸图像是被现场照相机获取的,由于环境限制或设备原因,这些图像经常存在分辨率较低的问题。在人脸分析识别领域,怎样恢复人脸图像已经成为一个重要的课题。这个问题在Baker和Kanade的先驱工作中第一次被定义为虚幻脸。</p></blockquote><ul><li>稀疏表示法</li></ul><hr><h1 id="基于深度学习的Image-SR技术"><a href="#基于深度学习的Image-SR技术" class="headerlink" title="基于深度学习的Image SR技术"></a>基于深度学习的Image SR技术</h1><p>基于深度学习的图像超分辨率重建的大值研究流程如下：</p><ul><li><p>给出初始图像输入Image_1；</p></li><li><p>然后将初始图像输入进行分辨率的降低，称为Image_2；</p></li><li><p>通过各种深度学习算法，将Image2重建为Image3，且Image3和Image1的分辨率一致（SR的工作部分），再由PSNR等方法比较Image1与Image3，验证SR重建的效果，并根据效果调节神经网络中的节点模型和参数；</p></li><li><p>迭代第三步直到得到满意的结果。</p></li></ul><p>接下来给出近年来较为有代表性的基于深度学习的Image SR方法：</p><blockquote><p>发展历程：SRCNN -&gt; FSRCNN -&gt; ESPCN -&gt; VDSR -&gt; SRGAN -&gt; ESRGAN -&gt; EDSR</p><p>额外的一篇：PULSE</p></blockquote><h2 id="SRCNN"><a href="#SRCNN" class="headerlink" title="SRCNN"></a>SRCNN</h2><p>见《论文研读：SRCNN》。</p><h2 id="FSRCNN"><a href="#FSRCNN" class="headerlink" title="FSRCNN"></a>FSRCNN</h2><blockquote><p>Accelerating the Super-Resolution Convolutional Neural Networks</p></blockquote><p>这篇文章指出，SRCNN在速度方面有着显著的限制。体现在：</p><ul><li><p>低分辨率图像需要上采样（双三次插值）；</p></li><li><p>非线性映射步骤，参数量依旧影响速度。</p></li></ul><p><strong>这篇文章主要的目的是对SRCNN进行加速。</strong>文章重新设计SRCNN结构，体现在以下三个方面：</p><ul><li><p><strong>在网络的最后新增添了一个解卷积层</strong>，作用是从没有插值的低分辨率图像直接映射到高分辨率图像；</p></li><li><p>重新改变输入特征维数；</p></li><li><p>使用了更小的卷积核但是使用了更多的映射层。</p></li></ul><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/29.png" title="Optional title"></p><p>对于上述第一个问题，采用解卷积层代替三次插值，针对第二个问题，添加萎缩层和扩张层，并将中间那一个大层用一些小层（卷积核大小是3*3）来代替。整个网络结构类似于漏斗的形状，中间细两端粗。这个网络不仅仅速度快，而且不需要更改参数（除新增添的在最后的解卷积层）。</p><p>损失函数：同SRCNN一致的MSE。</p><blockquote><p>Cost function: Following SRCNN, we adopt the mean square error (MSE) as the cost function.</p></blockquote><p>激活函数：改成了PReLU。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/prelu.png" title="Optional title"></p><blockquote><p>PReLU（Parametric Rectified Linear Unit），带参数的ReLU。i表示不同的通道，如果ai=0，那么PReLU退化为ReLU；如果ai是一个很小的固定值（如ai=0.01），则PReLU退化为Leaky ReLU（LReLU）。有实验证明，与ReLU相比，LReLU对最终的结果几乎没什么影响。</p></blockquote><p>实验结果：</p><p>不同倍数、不同数据集、不同方法的对比：在SET5上的结果最好，放大2、3倍时的效果最好。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/30.png" title="Optional title"></p><p>经典的lenna的结果，SET14在3倍下的模型。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/31.png" title="Optional title"></p><p>三个贡献：</p><ul><li><p>设计漏斗结构的卷积网络，不需要预处理操作；</p></li><li><p><strong>速度提升；</strong></p></li><li><p>训练速度快。</p></li></ul><p>链接：<a href="https://arxiv.org/pdf/1608.00367v1.pdf">https://arxiv.org/pdf/1608.00367v1.pdf</a></p><p>代码：<a href="https://github.com/yifanw90/FSRCNN-TensorFlow">https://github.com/yifanw90/FSRCNN-TensorFlow</a></p><h2 id="ESPCN"><a href="#ESPCN" class="headerlink" title="ESPCN"></a>ESPCN</h2><blockquote><p>Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network</p></blockquote><p>这篇文章指出，像SRCNN这一类的方法，需要将低分辨率图像通过上采样插值得到与高分辨率图像相同大小的尺寸，再输入到网络中，这意味着要在较高的分辨率上进行卷积操作，从而增加了计算复杂度。</p><p>然后这篇文章给出了一种直接在低分辨率图像尺寸上提取特征，计算得到高分辨率图像的高效方法，称为ESPCN。网络结构如下所示：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/32.png" title="Optional title"></p><p>最大贡献：亚像素卷积层/子像素卷积层/pixel shuffle</p><p>SR的流程里需要将一张低分辨率图像转换成一张高分辨率图像。如果直接用deconvolution作为upscale手段的话，通常会带入过多人工因素进来（有不少论文提到这个）。<strong>在反卷积里会存在大量补0的区域，这可能对结果有害。</strong>因此pixel shuffle通过亚像素卷积，实现从低分辨图到高分辨图的重构，通过将多通道feature上的单个像素组合成一个feature上的单位即可，每个feature上的像素就相当于新的feature上的亚像素。</p><p>所以在图像超分辨的任务多使用pixel shuffle的方式获得高分辨图像（ESPCN等很多论文都有）。</p><blockquote><p>亚像素：在相机成像的过程中，获得的图像数据是将图像进行了离散化的处理，由于感光元件本身的能力限制，到成像面上每个像素只代表附近的颜色。例如两个感官原件上的像素之间有4.5um的间距，宏观上它们是连在一起的，微观上它们之间还有无数微小的东西存在，这些存在于两个实际物理像素之间的像素，就被称为“亚像素”。亚像素实际上应该是存在的，只是缺少更小的传感器将其检测出来而已，因此只能在软件上将其近似计算出来。</p><blockquote><p>若输出是原来的 r * r 倍（如，r=2，200x200 变成 400x400），则输出的 channel 数是输入 channel 数除以 r * r （如200x200x40 变成 400x400x10）。</p></blockquote><blockquote><p>一文搞懂 deconvolution、transposed convolution、sub-­pixel or fractional convolution：<a href="https://www.cnblogs.com/shine-lee/p/11559825.html#convolution%E8%BF%87%E7%A8%8B">https://www.cnblogs.com/shine-lee/p/11559825.html#convolution过程</a></p></blockquote></blockquote><p>链接：<a href="https://arxiv.org/pdf/1609.05158.pdf">https://arxiv.org/pdf/1609.05158.pdf</a></p><p>code：<a href="https://github.com/JuheonYi/VESPCN-tensorflow">https://github.com/JuheonYi/VESPCN-tensorflow</a></p><h2 id="VDSR"><a href="#VDSR" class="headerlink" title="VDSR"></a>VDSR</h2><blockquote><p>Accurate Image Super-Resolution Using Very Deep Convolutional Networks</p></blockquote><p>本文提出，输入的低分辨率图像和输出的高分辨率图像在很大程度上是相似的，也就是指低分辨率图像携带的低频信息与高分辨率图像的低频信息相近，训练时带上这部分会多花费大量的时间，实际上只需要学习高分辨率图像和低分辨率图像之间的高频部分残差即可。残差网络结构的思想特别适合以这个思路来解决SR问题，可以说影响了之后的深度学习超分辨率方法。</p><blockquote><p>对SRCNN收敛速度的分析有点牵强，主要是提出了论文的基于残差建模。</p><blockquote><p>何恺明在2015年的时候提出了残差网络ResNet。ResNet的提出，解决了之前网络结构比较深时无法训练的问题，性能也得到了提升，ResNet也获得了CVPR2016的best paper。残差网络结构(residual network)被应用在了大量的工作中。</p></blockquote></blockquote><p>这篇文章依旧以SRCNN开启叙述，先提了SRCNN的优势，然后指出了SRCNN的三个缺点：</p><ul><li><p>依赖小图像区域的上下文；</p></li><li><p>收敛太慢；</p></li><li><p>只能做单个倍数的采样。</p></li></ul><blockquote><p>first, it relies on the context of small image regions; second, training converges too slowly; third, the network only works for a single scale</p></blockquote><p>然后针对上面三个问题来概括本篇创新点：</p><ul><li><p>Context（增大感受野）；</p></li><li><p>Convergence（残差学习和高学习率）；</p></li><li><p>Scale Factor（使用mutil-scale）。</p></li></ul><p>提出如下的VDSR：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/33.png" title="Optional title"></p><ul><li><p>20层的卷积核大小都为3*3*64，</p></li><li><p>使用插值将LR图片放大到期望的尺寸，再作为网络的输入</p></li><li><p>每经过一层，feature map将会变小，论文只用补0的方法来保持其尺寸不变。</p></li></ul><p>Loss依旧使用的是MSE：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/34.png" title="Optional title"></p><p>链接：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Kim_Accurate_Image_Super-Resolution_CVPR_2016_paper.pdf">https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Kim_Accurate_Image_Super-Resolution_CVPR_2016_paper.pdf</a></p><p>code：<a href="https://github.com/huangzehao/caffe-vdsr">https://github.com/huangzehao/caffe-vdsr</a> 、<a href="https://github.com/Jongchan/tensorflow-vdsr">https://github.com/Jongchan/tensorflow-vdsr</a> 、<a href="https://github.com/twtygqyy/pytorch-vdsr">https://github.com/twtygqyy/pytorch-vdsr</a></p><h2 id="SRGAN"><a href="#SRGAN" class="headerlink" title="SRGAN"></a>SRGAN</h2><p>见《论文研读：SRGAN》。</p><h2 id="ESRGAN"><a href="#ESRGAN" class="headerlink" title="ESRGAN"></a>ESRGAN</h2><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/35.png" title="Optional title"></p><p>ESRGAN的整体框架和SRGAN保持一致。相比SRGAN，ESRGAN有5处改进：</p><h3 id="去除BN层"><a href="#去除BN层" class="headerlink" title="去除BN层"></a>去除BN层</h3><blockquote><p>为什么要去除BN层？</p><p>How does batch normalization help optimization</p></blockquote><p>对于有些像素级图片生成任务来说，BN效果不佳。对于图片分类等任务，只要能够找出关键特征，就能正确分类，这算是一种粗粒度的任务，在这种情形下通常BN是有积极效果的。但是对于有些输入输出都是图片的像素级别图片生成任务，比如图片风格转换等应用场景，使用BN会带来负面效果，这很可能是因为在Mini-Batch内多张无关的图片之间计算统计量，弱化了单张图片本身特有的一些细节信息。</p><p>以图像超分辨率来说，网络输出的图像在色彩、对比度、亮度上要求和输入一致，改变的仅仅是分辨率和一些细节。而BN，对图像来说类似于一种对比度的拉伸，任何图像经过BN后，其色彩的分布都会被归一化。也就是说，它破坏了图像原本的对比度信息，所以BN的加入反而影响了网络输出的质量。ResNet可以用BN，但也仅仅是在残差块当中使用。</p><h3 id="用Dense-Block替换Residual-Block"><a href="#用Dense-Block替换Residual-Block" class="headerlink" title="用Dense Block替换Residual Block"></a>用Dense Block替换Residual Block</h3><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/36.png" title="Optional title"></p><p>BN的作用是网络更容易优化，不容易陷入局部极小值。ESRGAN去掉了BN，可以猜想，如果保持原有的Residual Block结构，网络会变得非常难易训练，而且很容易陷入局部极小值导致结果不好。</p><p>而DenseNet的解空间非常平滑，换言之，DenseNet相比其他网络要容易训练的多，Dense Block和BN提升网络性能的原因是相同的。</p><p><strong>总的来说，去掉BN层是因为BN层有副作用，但是BN也有众多的优点且与Dense Block的作用相似，那么用Dense Block替换Residual Block是要弥补去掉BN带来的负面效果。</strong></p><h3 id="使用Relativistic-GAN改进对抗损失函数"><a href="#使用Relativistic-GAN改进对抗损失函数" class="headerlink" title="使用Relativistic GAN改进对抗损失函数"></a>使用Relativistic GAN改进对抗损失函数</h3><h3 id="使用relu激活前的特征图计算损失"><a href="#使用relu激活前的特征图计算损失" class="headerlink" title="使用relu激活前的特征图计算损失"></a>使用relu激活前的特征图计算损失</h3><p>原文给出的解释如下：</p><ul><li><p>激活后的特征图变的非常稀疏，丢失了很多信息；</p></li><li><p>使用激活后的特征图会造成重建图片在亮度上的不连续。</p></li></ul><p>生成器的损失函数为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/37.png" title="Optional title"></p><blockquote><p>ESRGAN在生成器上的Loss几乎沿用了SRGAN，但是命名是有出入的。</p></blockquote><h3 id="使用network-interpolation平衡主客观指标"><a href="#使用network-interpolation平衡主客观指标" class="headerlink" title="使用network interpolation平衡主客观指标"></a>使用network interpolation平衡主客观指标</h3><p>基于GAN的方法有一个缺点，经常会生成奇怪的纹理，而非GAN的方法总是缺失细节，能不能把两种方法生成的图片加权相加呢？将这样的思路称为Network Interpolation，网络插值。</p><p>具体做法是，训练一个非GAN的网络，在这个网络的基础上fine-tuning出GAN的生成器，然后把两个网络的参数加权相加：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/38.png" title="Optional title"></p><p>链接：<a href="https://arxiv.org/pdf/1809.00219.pdf">https://arxiv.org/pdf/1809.00219.pdf</a></p><p>code：<a href="https://github.com/xinntao/ESRGAN%E2%80%8Bgithub.com">https://github.com/xinntao/ESRGAN​github.com</a></p><h2 id="EDSR和MDSR"><a href="#EDSR和MDSR" class="headerlink" title="EDSR和MDSR"></a>EDSR和MDSR</h2><blockquote><p>Enhanced Deep Residual Networks for Single Image Super-Resolution</p></blockquote><p>EDSR是NTIRE2017超分辨率挑战赛上获得冠军的方案。</p><p>EDSR的最大贡献是去除了SRResNet上的BN。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/39.png" title="Optional title"></p><p>原文中提到，原始的ResNet最一开始是被提出来解决高层的计算机视觉问题，比如分类和检测，直接把ResNet的结构应用到像超分辨率这样的低层计算机视觉问题，显然不是最优的。由于批规范化层消耗了与它前面的卷积层相同大小的内存，在去掉这一步操作后，相同的计算资源下，EDSR就可以堆叠更多的网络层或者使每层提取更多的特征，从而得到更好的性能表现。EDSR用L1范数样式的损失函数来优化网络模型。在训练时先训练低倍数的上采样模型，接着用训练低倍数上采样模型得到的参数来初始化高倍数的上采样模型，这样能减少高倍数上采样模型的训练时间，同时训练结果也更好。</p><blockquote><p>训练结果给的是2、3、4倍，效果依次递减。也就是2倍的PSNR和SSIM效果是最好的。</p></blockquote><p>文中同时还给出了一个能同时进行不同上采样倍数的网络结构MDSR：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/40.png" title="Optional title"></p><p>链接：见4.2.2节。</p><p>code：<a href="https://github.com/jmiller656/EDSR-Tensorflow">https://github.com/jmiller656/EDSR-Tensorflow</a> 、<a href="https://github.com/thstkdgus35/EDSR-PyTorch">https://github.com/thstkdgus35/EDSR-PyTorch</a> 、<a href="https://github.com/LimBee/NTIRE2017">https://github.com/LimBee/NTIRE2017</a></p><h2 id="PULSE"><a href="#PULSE" class="headerlink" title="PULSE"></a>PULSE</h2><blockquote><p>PULSE: Self-Supervised Photo Upsampling via Latent Space Exploration of Generative Models</p></blockquote><p>来自2020年CVPR，一篇非常amazing的文章：PULSE最多能将16*16放大至1024*1024，即64倍放大。</p><blockquote><p>Starting with a pre-trained GAN, our method operates only at test time, generating each image in about 5 seconds on a single GPU.</p></blockquote><p>传统方法处理此类问题时，一般拿到LR图像后，会“猜测”需要多少额外的像素，然后试着将此前处理过的HR图像中相应的像素，匹配给LR图像。而这种单纯匹配像素的结果是，像头发和皮肤的纹理这种区域，会出现像素匹配错位的现象。而且该方法还会忽略了HR图像中，感光性等感知细节。所以最终在平滑度、感光度上出现问题，结果依然会显得模糊或者不真实。</p><p>PULSE则给出了一个新的思路：在拿到一张LR图像后，PULSE系统不会慢慢添加新的细节，而是遍历GAN生成的HR图像，将这些HR图像对应的LR图像与原图对比，找到最接近的那张。实际上就是用LR图片做反推导：找到最相似的LR版本，那么再反推回去，这张LR图像所对应的HR图像，就是最终要输出的结果。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/41.png" title="Optional title"></p><p>使用的基本模型是GAN。在复原的过程中，该网络会“想象”出一些原本不存在的特征，即使是原本LR照片中无法看到的细节，比如毛孔、细纹、睫毛、头发和胡茬等，经过其算法处理后，都能看得一清二楚。</p><p>实验结果：在著名的高分辨率人脸数据集CelebA HQ用64×，32×和8×的比例因子进行了这些实验。并要求40个人对通过PULSE和其他五种缩放方法生成的1440张图像进行MOS评分，PULSE的效果最佳，得分几乎与真实的高质量照片一样高。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/42.png" title="Optional title"></p><p>对不同类型的人脸的复原Success rates也做了统计：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/43.png" title="Optional title"></p><p>比较在意的人像位置：头发、眼睛、嘴唇：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/44.png" title="Optional title"></p><p>该模型有如下局限性：</p><ul><li>只针对人脸（虚幻脸）；</li></ul><blockquote><p>We show extensive experimental results demonstrating the efficacy of our approach in the domain of face super-resolution (also known as face hallucination).</p></blockquote><blockquote><p>However, we also note significant limitations when evaluated on natural images past the standard benchmark.</p></blockquote><ul><li>不能用于识别身份：无法将安全摄像头拍摄的失焦、不能识别的照片，变成真人的清晰图像。</li></ul><blockquote><p>意思就是说仅会生成不存在但看上去很真实的新面孔。</p></blockquote><p>链接：<a href="https://arxiv.org/pdf/2003.03808.pdf">https://arxiv.org/pdf/2003.03808.pdf</a></p><p>code：<a href="https://github.com/adamian98/pulse">https://github.com/adamian98/pulse</a></p><hr><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="常用的Image-SR评价指标"><a href="#常用的Image-SR评价指标" class="headerlink" title="常用的Image SR评价指标"></a>常用的Image SR评价指标</h2><h3 id="PSNR"><a href="#PSNR" class="headerlink" title="PSNR"></a>PSNR</h3><p>􏱏􏱐􏰝􏱑􏱒􏰆峰值信噪比（Peak Signal to Noise Ratio，PSNR）是一种极其普遍且在各个领域进行图像处理工作时都广泛使用的评估图像质量的客观量测法。评价的指向为经过压缩、降噪等操作后的图像，相对于原图像的噪声强度。失真程度越大，该指标给出的值就越小。</p><p>给定不含噪声的图像I（大小为M*N）和带有噪声的图像K，将均方误差MSE定为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/45.png" title="Optional title"></p><p>PSNR则定义为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/46.png" title="Optional title"></p><p>作为一种客观的评价指标，众多的实验都指出，PSNR同人的眼睛所看到的图像的视觉品质的主观评价是由很大出入的，也就是说，PSNR评分高的图像，在人眼的主观评价中，反而可能不如PSNR低分图像。实际上该指标并未考虑视觉评价的感知特性。</p><h3 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h3><p>结构相似性（Structural Similarity index，SSIM）是对比两图相似程度的指标。SSIM分别使用协方差、均值和标准差作为图片的结构相似程度、亮度和对比度的评价指标，这三个因素共同组合成图片失真程度的评价。三个评价的范围都是从0到1，无单位。若进行评价的两张图像完全相同，SSIM就会等于1。</p><p>给定进行对比的两张图像x和y，SSIM定义为：</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/47.png" title="Optional title"></p><p>其中，α，β，γ&gt;0，l(x,y)是亮度的评价，c(x,y)是对比度的评价，s(x,y)是结构的评价。</p><p><img src="/images/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/48.png" title="Optional title"></p><p>c1，c2，c3均为非零常数，μ为均值，σ为方差和协方差。在实际工程计算中，一般设定α，β，γ=1，c3=c2/2。</p><p>SSIM具有对称性，即SSIM(x,y)=SSIM(y,x)。</p><p>SSIM是视频及图像质量评估的一种常见且效果良好的算法，不过它依久具有同PSNR相似的缺陷。</p><h2 id="NTIRE"><a href="#NTIRE" class="headerlink" title="NTIRE"></a>NTIRE</h2><p>NTIRE英文全称是New Trends in Image Restoration and Enhancement，也就是<strong>“图像恢复与增强的新趋势”</strong>，是近年来计算机图像修复领域最具影响力的一场赛事，每年都会吸引大量的关注者和参赛者。</p><p>该比赛自2017年开始第一届，到今年已经举办了四届。2017年该比赛共拥有三个赛道，而今年的比赛增加到了5个赛道（2020.6比赛结果已出），分别是：</p><h3 id="2020年赛道"><a href="#2020年赛道" class="headerlink" title="2020年赛道"></a>2020年赛道</h3><h4 id="Real-World-Image-Super-Resolution"><a href="#Real-World-Image-Super-Resolution" class="headerlink" title="Real-World Image Super-Resolution"></a>Real-World Image Super-Resolution</h4><p>经典赛道，自2017年开始就有的图像超分辨率。</p><h4 id="Image-Dehazing"><a href="#Image-Dehazing" class="headerlink" title="Image Dehazing"></a>Image Dehazing</h4><p>经典赛道，自2017年开始就有的图像去雾。</p><h4 id="Image-Demoireing"><a href="#Image-Demoireing" class="headerlink" title="Image Demoireing"></a>Image Demoireing</h4><p>图像去摩尔纹，是今年的新赛道。</p><blockquote><p>摩尔纹是一种在数码照相机或者扫描仪等设备上，感光元件出现的高频干扰的条纹，是一种会使图片出现彩色的高频率不规则的条纹。</p></blockquote><h4 id="Spectral-Reconstruction-from-an-RGB-Image"><a href="#Spectral-Reconstruction-from-an-RGB-Image" class="headerlink" title="Spectral Reconstruction from an RGB Image"></a>Spectral Reconstruction from an RGB Image</h4><p>该任务的目的是从RGB图像中重建全场景高光谱（HS）信息。</p><h4 id="Video-Quality-Mapping"><a href="#Video-Quality-Mapping" class="headerlink" title="Video Quality Mapping"></a>Video Quality Mapping</h4><p>该挑战拟解决从源视频域到目标视频域的质量映射问题。挑战包括两个子任务：监督轨道和弱监督轨道。 其中，轨道1提供了一个新的Internet视频基准数据集，要求算法以监督训练的方式学习从压缩程度更高的视频到压缩程度更低的视频间的映射关系。 在轨道2中，需要算法来学习从一个设备到另一个设备的质量映射关系。</p><h3 id="Image-SR赛道冠军论文"><a href="#Image-SR赛道冠军论文" class="headerlink" title="Image SR赛道冠军论文"></a>Image SR赛道冠军论文</h3><h4 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h4><blockquote><p>EDSR</p></blockquote><p><a href="https://arxiv.org/abs/1707.02921v1">Enhanced Deep Residual Networks for Single Image Super-Resolution</a></p><h4 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h4><blockquote><p>WDSR</p></blockquote><p><a href="https://arxiv.org/abs/1808.08718">Wide Activation for Efficient and Accurate Image Super-Resolution</a></p><h4 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h4><blockquote><p>UDSR</p></blockquote><h4 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h4><p><a href="https://openaccess.thecvf.com/content_CVPRW_2020/html/w31/Ji_Real-World_Super-Resolution_via_Kernel_Estimation_and_Noise_Injection_CVPRW_2020_paper.html">Real-World Super-Resolution via Kernel Estimation and Noise Injection</a></p><h3 id="NTIRE中Image-SR赛道结果综述"><a href="#NTIRE中Image-SR赛道结果综述" class="headerlink" title="NTIRE中Image SR赛道结果综述"></a>NTIRE中Image SR赛道结果综述</h3><blockquote><p>Single Image SR -&gt; Real Image SR -&gt; Real-World Image SR<br>从最开始的模拟下采样（Bicubic）图像到现在的Real-World Image，可见现在的挑战任务越来越走向通用化和实用化，当然这也意味着难度的升级。</p></blockquote><p><a href="http://ieeexplore.ieee.org/document/8014883/">NTIRE 2017 Challenge on Single Image Super-Resolution: Methods and Results</a></p><p><a href="http://ieeexplore.ieee.org/document/8575282/">NTIRE 2018 Challenge on Single Image Super-Resolution: Methods and Results</a></p><p><a href="https://ieeexplore.ieee.org/xpl/conhome/8972688/proceeding">NTIRE 2019 Challenge on Real Image Super-Resolution: Methods and Results</a></p><p><a href="http://ieeexplore.ieee.org/document/9022354/">NTIRE 2020 Challenge on Real-World Image Super-Resolution: Methods and Results</a></p><h2 id="Image-SR相关资源（持续更新）"><a href="#Image-SR相关资源（持续更新）" class="headerlink" title="Image SR相关资源（持续更新）"></a>Image SR相关资源（持续更新）</h2><ul><li><p>2000-2020的Image SR文献总结：<a href="https://github.com/YapengTian/Single-Image-Super-Resolution">https://github.com/YapengTian/Single-Image-Super-Resolution</a></p></li><li><p>CVPR2020｜图像重建(超分辨率，图像恢复，去雨，去雾，去模糊，去噪等)相关论文汇总：<a href="https://blog.csdn.net/Kobaayyy/article/details/106815083">https://blog.csdn.net/Kobaayyy/article/details/106815083</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;图像超分辨</summary>
      
    
    
    
    
    <category term="论文研读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="图像超分辨率" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>论文研读：Single Image Deraining: From Model-Based to Data-Driven and Beyond</title>
    <link href="http://example.com/2020/03/30/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASingle-Image-Deraining-From-Model-Based-to-Data-Driven-and-Beyond/"/>
    <id>http://example.com/2020/03/30/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASingle-Image-Deraining-From-Model-Based-to-Data-Driven-and-Beyond/</id>
    <published>2020-03-30T07:06:06.000Z</published>
    <updated>2020-09-09T12:26:58.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这是一篇关于单图像去雨和视频去雨方法的综述性论文。作者在文中总结了过去20年内的一些去雨方法，并对它们进行分类，对它们的结果做了定性和定量分析以及结果之间的对比。</p><blockquote><blockquote><p>The goal of single-image deraining is to restore the rain-free background scenes of an image degraded by rain streaks and rain accumulation. The early single-image deraining methods employ a cost function, where various priors are developed to represent the properties of rain and background layers. Since 2017, single-image deraining methods step into a deep-learning era, and exploit various types of networks, i.e. convolutional neural networks, recurrent neural networks, generative adversarial networks, etc., demonstrating impressive performance. </p></blockquote><blockquote><p>Given the current rapid development, in this paper, we provide a comprehensive survey of deraining methods over the last decade. We summarize the rain appearance models, and discuss two categories of deraining approaches: model-based and data-driven approaches. For the former, we organize the literature based on their basic models and priors. For the latter, we discuss developed ideas related to architectures, constraints, loss functions, and training datasets. </p></blockquote><blockquote><p>We present milestones of single-image deraining methods, review a broad selection of previous works in different categories, and provide insights on the historical development route from the model-based to data-driven methods. We also summarize performance comparisons quantitatively and qualitatively. Beyond discussing the technicality of deraining methods, we also discuss the future directions.</p></blockquote></blockquote><blockquote><blockquote><p>单幅图像排空的目标是恢复因雨水条纹和雨水堆积而退化的图像的无雨背景场景。早期的单图像排空方法采用成本函数，其中开发了各种先验以表示雨层和背景层的属性。自2017年以来，单图像排空方法进入了深度学习时代，并利用了各种类型的网络，即卷积神经网络，递归神经网络，生成对抗网络等，展示了令人印象深刻的性能。</p></blockquote><blockquote><p>鉴于当前的快速发展，本文对过去十年中的去雨方法进行了全面的调查。我们总结了降雨外观模型，并讨论了两种减雨方法：基于模型的方法和基于数据驱动的方法。对于前者，我们根据其基本模型和先验知识来整理文献。对于后者，我们讨论与体系结构，约束，损失函数和训练数据集有关的已开发思想。</p></blockquote><blockquote><p>我们介绍了单图像排空方法的里程碑，回顾了不同类别的大量先前作品，并提供了从基于模型的方法到数据驱动方法的历史发展路线的见解。我们还定量和定性总结了性能比较。除了讨论去雨方法的技术性之外，我们还讨论了未来的发展方向。</p></blockquote></blockquote><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><blockquote><p>An early study of video deraining was started in 2004 by Garg and Nayar [3]. They analyze rain dynamic appearances, and develop an approach to remove rain streaks from videos. Kang et al. [4] was a pioneer in the single image deraining by publishing a method in 2012. The method extracts the high-frequency layer of a rain image, and decomposes the layer further into rain and non-rain components using dictionary learning and sparse coding. Starting from 2017, by the publications of [1, 18], data-driven deep-learning methods that learn features automatically become dominant in the literature.</p></blockquote><blockquote><blockquote><p>Garg和Nayar [3]于2004年开始了对视频去雨的早期研究。他们分析了雨水的动态外观，并开发了一种方法来消除视频中的雨水条纹。 </p></blockquote><blockquote><p>Kang等。 [4]是通过在2012年发布一种方法来进行单幅图像去雨的先驱。该方法提取了降雨图像的高频层，并使用字典学习和稀疏编码将其进一步分解为降雨和非降雨成分。 </p></blockquote><blockquote><p>从[1，18]的出版物开始，从2017年开始，学习特征的数据驱动的深度学习方法自动成为文献中的主导。</p></blockquote></blockquote><ul><li>单一图像去雨研究的历史：在2017年之前，典型的方法是基于模型的方法（或非深度学习方法）。基于模型的方法的主要发展受到以下观念的推动：图像分解（2012年），稀疏编码（2015年）和基于先验的高斯混合模型（2016年）。自2017年以来，单图像清除方法进入了数据驱动方法（或深度学习方法）时期。</li></ul><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/11.png" title="Optional title"></p><blockquote><p>单一图像排空方法的里程碑：图像分解，稀疏编码，高斯混合模型，深度卷积网络，生成对抗网络以及半/无监督学习。在2017年之前，典型的方法是基于模型的方法（或非深度学习方法）。自2017年以来，单图像去雨方法进入了数据驱动方法（或深度学习方法）时期。</p></blockquote><ul><li>基于模型的方法及相关论文。</li></ul><blockquote><blockquote><p>Model-based methods rely more on the statistical analysis of rain streaks and background scenes. The methods enforce handcrafted priors on both rain and background layers, then build a cost function and optimize it. The priors are extracted from various ways: Luo et al. [5] learn dictionaries for both rain streak and background layers, Li et al. [6] build Gaussian mixture models from clean images to model background scenes, and from rain patches of the input image to model rain streaks, Zhu et al. [7] enforce a certain rain direction based on rain-dominated regions so that the background textures can be differentiated from rain streaks.</p></blockquote><blockquote><p>基于模型的方法更多地依赖于雨条纹和背景场景的统计分析。该方法在雨层和背景层都执行手工制作的先验，然后构建成本函数并对其进行优化。先验是通过各种方式提取的：Luo等。 [5] Li等人学习了有关雨条纹和背景层的词典。［6］建立了高斯混合模型，从干净的图像到背景场景，从输入图像的雨斑到雨条纹，朱等人。 [7]基于降雨为主的地区实施一定的降雨方向，以便可以将背景纹理与降雨条纹区分开。</p></blockquote></blockquote><ul><li>基于数据驱动的相关方法和论文：数据驱动方法的主要发展：深度卷积网络（2017），生成对抗网络（2019）和半/无监督方法（2019）。在2017-2019年间，关于这种深度学习方法的论文超过30篇，大大超过了2017年之前的枯竭论文数量。</li></ul><blockquote><blockquote><p>In recent years, the popularity of data-driven methods has overtaken model-based methods. These methods exploits deep net- works to automatically extract hierarchical features, enabling them to model more complicated mappings from rain images to clean ones. Some rain-related constraints are usually injected into the networks to learn more effective features, such as rain masks [1], background features [8], etc. Architecture wise, some methods utilize recurrent network [1], or recursive network [9] to remove rain progressively. There are also a series of works focusing on the hierarchical information of deep features, e.g. [10, 11].<br>While deep networks lead to a rapid progress in deraining performance, many of these deep-learning deraining methods train the networks in a fully supervised way. This can cause a problem, since to obtain paired images of rain and rain-free images is intractable. The simplest solution is to utilize synthetic images. Yet, there are domain gaps between synthetic rain and real rain images, which can make the deraining performance not optimum. To overcome the problem, unsupervised/semi-supervised methods thatexploitrealrainimages [12]and [13]areintroduced.</p></blockquote><blockquote><p>近年来，数据驱动方法的普及已经取代了基于模型的方法。这些方法利用深层网络自动提取层次结构特征，从而使它们能够建模从降雨图像到干净图像的更复杂的映射。通常会向网络中注入一些与雨水相关的约束条件，以学习更有效的功能，例如防雨罩[1]，背景特征[8]等。在架构上，某些方法利用循环网络[1]或递归网络[9] ]逐步去除雨水。还有一系列针对深度特征的分层信息的作品，例如[10，11]。<br>虽然深层网络在去雨性能方面取得了迅速的进步，但许多深度学习去雨方法都以完全受监督的方式训练网络。这可能会引起问题，因为难以获得雨水和无雨水图像的配对图像。最简单的解决方案是利用合成图像。然而，合成降雨和真实降雨图像之间存在域间隙，这可能会使去雨性能不是最佳的。为了克服这个问题，引入了无监督/半监督的方法来利用真实的雨像[12]和[13]。</p></blockquote></blockquote><h1 id="RAINDROP-APPEARANCE-MODELS"><a href="#RAINDROP-APPEARANCE-MODELS" class="headerlink" title="RAINDROP APPEARANCE MODELS"></a>RAINDROP APPEARANCE MODELS</h1><p>此段结合雨滴的物理特性，给出合成雨模型的合成方法。</p><blockquote><blockquote><p>The shape of a raindrop is usually approximated by a spherical shape [14]. </p></blockquote><blockquote><p>雨滴的形状通常近似为球形[14]。</p></blockquote></blockquote><blockquote><blockquote><p>As a result, in most rain synthetic models, rain streaks are assumed to be superimposed on the background image.</p></blockquote><blockquote><p>最终，在大多数降雨合成模型中，降雨条纹是假定叠加在背景图像上。</p></blockquote></blockquote><h1 id="LITERATURE-SURVEY"><a href="#LITERATURE-SURVEY" class="headerlink" title="LITERATURE SURVEY"></a>LITERATURE SURVEY</h1><h2 id="Synthetic-Rain-Models"><a href="#Synthetic-Rain-Models" class="headerlink" title="Synthetic Rain Models"></a>Synthetic Rain Models</h2><p>六种合成雨模型。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/33.png" title="Optional title"></p><blockquote><blockquote><p>However, as we mentioned in the beginning of this section that all these models are heuristic; implying that they might not entirely correct physically. Nevertheless, as shown in the literature, they can be effective, at least to some extent, for image deraining.</p></blockquote><blockquote><p>但是，正如我们在本节开始时提到的那样，所有这些模型都是启发式的。暗示它们可能在物理上不完全正确。 然而，如文献所示，它们可以至少在一定程度上有效地消除图像。</p></blockquote></blockquote><h3 id="Additive-Composite-Model-（ACM）"><a href="#Additive-Composite-Model-（ACM）" class="headerlink" title="Additive Composite Model （ACM）"></a>Additive Composite Model （ACM）</h3><p>现有研究中使用的最简单和流行的降雨模型是加法复合模型[4，6]，它遵循方程式：O = B + S。</p><blockquote><p>其中B表示背景层，S表示雨条纹层。 O是由于雨条纹而劣化的图像。在此，该模型假设降雨条纹的外观仅与背景重叠，并且在降雨退化图像中没有降雨积聚。</p></blockquote><h3 id="Screen-Blend-Model-（SBM）"><a href="#Screen-Blend-Model-（SBM）" class="headerlink" title="Screen Blend Model （SBM）"></a>Screen Blend Model （SBM）</h3><p>罗等[5]提出了一种非线性复合模型，称为背景混合模型：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/22.png" title="Optional title"></p><blockquote><p>其中◦表示逐点乘法运算。不同于加性复合模型，背景层和雨层相互影响。 罗等[5]声称，背景混合模型可以对真实降雨图像的某些视觉属性（例如内部反射的效果）进行建模，从而生成视觉上更真实的降雨图像。雨层和背景层的组合取决于信号。这意味着，当背景昏暗时，雨层将主导雨图像的外观；并且，当背景明亮时，背景层将主导图像。</p></blockquote><h3 id="Heavy-Rain-Model-（HRM）"><a href="#Heavy-Rain-Model-（HRM）" class="headerlink" title="Heavy Rain Model （HRM）"></a>Heavy Rain Model （HRM）</h3><blockquote><p>杨等[1]提出了一个包括降雨条纹和降雨积聚的降雨模型。这是去雨文献中包含两个降雨现象的第一个模型。雨水积聚或遮雨效果是大气中的水颗粒和无法单独看到的远距离雨水条纹的结果。雨水积累的视觉效果类似于雾气或雾气，导致对比度低。 考虑到降雨的两个主要方面：Koschmieder模型（用于近似浑浊介质中场景的视觉外观）以及方向和形状不同的重叠降雨条纹，引入了一种新颖的降雨模型.</p></blockquote><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/55.png" title="Optional title"></p><blockquote><p>其中，St表示条纹方向相同的雨条纹层。t标记雨条纹层，而s是最大雨条纹层数。A是整体大气光，α是大气透射率。</p></blockquote><h3 id="Rain-Model-with-Occlusion-（ROM）"><a href="#Rain-Model-with-Occlusion-（ROM）" class="headerlink" title="Rain Model with Occlusion （ROM）"></a>Rain Model with Occlusion （ROM）</h3><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/44.png" title="Optional title"></p><blockquote><p>刘等[15]将大雨模型扩展为可识别视频中雨的遮挡意识雨模型。该模型将雨条纹分为两种类型：添加到背景层的透明雨条纹和完全遮盖背景层的不透明雨条纹。这些不透明雨条纹的位置由称为信赖图的地图指示。</p></blockquote><h3 id="Comprehensive-Rain-Model-CRM"><a href="#Comprehensive-Rain-Model-CRM" class="headerlink" title="Comprehensive Rain Model (CRM)"></a>Comprehensive Rain Model (CRM)</h3><blockquote><p>杨等[2]结合以上所有内容在综合降雨模型中提到了退化因素用于在视频中模拟雨的外观。它考虑了时间雨景的属性，尤其是快速变化的降雨通常会引起闪烁的杂音。这种可见强度发生变化沿时间维度的时间称为降雨积累流。此外，它还考虑了其他因素，包括降雨条纹，降雨积聚和降雨遮挡。</p></blockquote><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/66.png" title="Optional title"></p><h3 id="Depth-Aware-Rain-Model-（DARM）"><a href="#Depth-Aware-Rain-Model-（DARM）" class="headerlink" title="Depth-Aware Rain Model （DARM）"></a>Depth-Aware Rain Model （DARM）</h3><blockquote><p>Hu等[16]进一步将α连接到场景深度d，以创建深度感知雨模型.</p></blockquote><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/SID/77.png" title="Optional title"></p><h2 id="Deraining-Challenges"><a href="#Deraining-Challenges" class="headerlink" title="Deraining Challenges"></a>Deraining Challenges</h2><ul><li>建模雨水图像的困难在现实世界中，雨水可能以多种不同的方式在视觉上出现。雨条纹的大小，形状，比例，密度，方向等可能会有所不同。同样，雨的积累取决于各种水颗粒和大气条件。此外，下雨的外观也极大地依赖于背景场景的纹理和深度。所有这些都导致对降雨的外观进行建模的困难，因此导致渲染物理上正确的降雨图像是一项复杂的任务。</li><li>去雨问题的不适性即使使用仅考虑雨条纹的简单降雨模型，从退化的图像估计背景场景也是不适性的问题。原因是我们只有由带有雨和背景场景的融合信息的光产生的像素强度值。更糟的是，在某些情况下，背景信息可能会完全被雨条纹或浓雨积累或两者同时遮挡。</li><li>难以找到合适的先验信息。由于特征空间中的雨水和背景信息可能会重叠，因此将它们分开并不容易。 背景纹理可能被错误地认为是雨，导致不正确的排水。 因此，有必要对背景纹理和雨水有很强的先验性。 但是，要找到这些先验是困难的，因为背景纹理是多种多样的，并且某些与雨条纹或雨水堆积的外观相似。</li><li>真正的配对真相。大多数深度学习方法都依赖配对的雨水和干净的背景图像来训练其网络。但是，要获得真实的降雨图像及其确切的干净背景图像对是很棘手的。 即使对于静态背景，照明条件也总是会变化。这个困难不仅影响深度学习方法，而且影响评估任何方法的有效性。当前，为了进行定性评估，所有方法都依赖于人类主观判断，以确定恢复后的图像是否良好。 对于定量评估，所有当前方法都依赖于合成图像。不幸的是，到目前为止，合成图像和真实图像之间还存在很大差距。</li></ul><h2 id="Single-image-Deraining-Methods"><a href="#Single-image-Deraining-Methods" class="headerlink" title="Single-image Deraining Methods"></a>Single-image Deraining Methods</h2><h3 id="Model-based-Methods"><a href="#Model-based-Methods" class="headerlink" title="Model-based Methods"></a>Model-based Methods</h3><h4 id="Sparse-Coding-Methods"><a href="#Sparse-Coding-Methods" class="headerlink" title="Sparse Coding Methods"></a>Sparse Coding Methods</h4><p>[56]将输入向量表示为基本向量的稀疏线性组合。这些基向量的集合称为字典，其用于重建特定类型的信号，例如信号。排水问题中有雨条纹和背景信号。</p><p>Lin等[4]首次尝试使用形态学成分分析通过图像分解进行单图像排水。通过字典学习和稀疏编码，将最初提取的雨图像的高频分量进一步分解为雨分量和非雨分量。这项先锋工作成功地消除了稀疏的小雨条纹。但是，它极大地依赖于双边过滤器的预处理，因此会产生模糊的背景细节。</p><p>在后续工作中，Luo等人[5]增强了降雨的稀疏性，并将互斥性引入了区分性稀疏编码（DSC）中，以帮助准确地将降雨/背景层与其非线性复合物分离。由于具有互斥性，DSC保留了干净的纹理细节；但是，它在输出中显示出一些残留的降雨条纹，特别是对于大而密集的降雨条纹。</p><p>为了进一步提高建模能力，Zhu等人[7]构建了一个迭代的层分离过程，以使用背景特定的先验技术从背景层中去除雨水条纹，并从雨层中去除背景的纹理细节。从数量上讲，该方法在某些合成数据集上可获得与同期发布的基于深度学习的方法（即JORDER [1]和DDN [18]）相当的性能。但是，从质量上说，在真实图像上，该方法在处理大雨的情况下往往会失败，因为大雨可能会在不同的方向上移动。</p><p>为了模拟雨条纹的方向和稀疏度，邓等人[17]制定了方向群稀疏模型（DGSM），其中包括三个稀疏项，代表着雨纹的内在方向和结构知识。它可以有效消除模糊的雨纹，但不能消除锐利的雨纹。</p><h4 id="Gaussian-Mixture-Model"><a href="#Gaussian-Mixture-Model" class="headerlink" title="Gaussian Mixture Model"></a>Gaussian Mixture Model</h4><p>Li等[6]应用高斯混合模型（GMM）来模拟雨层和背景层。背景层的GMM是从具有不同背景场景的真实图像中离线获取的。建议从输入图像中选择不具有背景纹理的雨斑来训练雨层的GMM。利用总变化量来消除小火花雨。该方法能够有效地去除小规模和中等规模的雨斑，但是不能处理大而尖的雨斑。</p><h3 id="Deep-Learning-Based-Methods"><a href="#Deep-Learning-Based-Methods" class="headerlink" title="Deep Learning Based Methods"></a>Deep Learning Based Methods</h3><h4 id="Deep-CNNs"><a href="#Deep-CNNs" class="headerlink" title="Deep CNNs"></a>Deep CNNs</h4><p>[1]构建一个联合降雨检测和清除网络。它可以处理大雨，重叠的雨条纹和雨水堆积。该网络可以通过预测二元防雨罩来检测雨水的位置，并采用递归框架来去除雨水条纹并逐步清除雨水积聚。该方法在下大雨的情况下取得了良好的效果。但是，它可能会错误地去除垂直纹理并生成曝光不足的照明。</p><p>同年，傅等人[18，19]尝试通过深层细节网络（DetailNet）去除雨水条纹。该网络仅将高频细节作为输入，并预测雨水残留和清晰的图像。该论文表明，删除网络输入中的背景信息是有益的，因为这样做可以使训练更容易，更稳定。但是，该方法仍然不能处理大而尖的雨纹。</p><p>继杨等[1]和傅等[18，19]，提出了许多基于CNN的方法[8，10，20-23]。这些方法采用了更先进的网络架构，并注入了与降雨相关的新先验。他们在数量和质量上都取得了更好的结果。但是，由于它们受完全监督的学习范式的局限性（即使用合成降雨图像），它们在处理训练中从未见过的真实降雨条件时往往会失败。</p><h4 id="Generative-Adversarial-Networks"><a href="#Generative-Adversarial-Networks" class="headerlink" title="Generative Adversarial Networks"></a>Generative Adversarial Networks</h4><p>生成对抗网络为了捕获无法建模和合成的某些视觉降雨属性，引入对抗学习以减少生成的结果与真实清晰图像之间的领域差距。典型的网络体系结构由两部分组成：生成器和鉴别器，其中鉴别器试图评估所生成的结果是真实的还是伪造的，这提供了额外的反馈以使生成器正规化，以产生更令人愉悦的结果。</p><p>张等[24]直接将条件生成对抗网络（CGAN）用于单图像除雨任务。CGAN能够捕获超出信号保真度的视觉属性，并以更好的照明，颜色和对比度分布呈现结果。但是，当测试降雨图像的背景与训练集中的背景不同时，CGAN有时可能会生成视觉伪像。</p><p>Li等[13]提出了一种结合物理驱动网络和对抗学习精炼网络的单幅图像去雨方法。第一阶段从合成数据中学习并估算与物理相关的成分，即降雨条纹，透射率和大气光。在第二细化阶段，提出了深度引导GAN，以补偿丢失的细节并在第一阶段抑制引入的伪影。从真实的降雨数据中学习，通过这些方法得出的结果在视觉上具有显着性改进，即彻底清除雨水堆积，并实现更加平衡的亮度分布。然而，因为基于GAN的方法并不擅长捕获细粒度细节信号，这些方法也无法正确模拟真实的雨水条纹的外观。</p><h1 id="代码和数据"><a href="#代码和数据" class="headerlink" title="代码和数据"></a>代码和数据</h1><p>作者在github发布了一个存储库，包括74篇雨水去除论文的直接链接，9种视频雨水去除方法和20种单图像雨水去除方法的源代码，19个相关项目页面，6个合成数据集和4个真实数据集，以及4个常用的图像质量度量。</p><p>&lt;hongwang01/Video-and-Single-Image-Deraining&gt;</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>按照原文的序号列出。</p><p>之前进行过阅读的论文序号：</p><ul><li>[1]：基于模型的去雨方法。</li><li>[19]：基于深度CNN网络的去雨方法，称为DerainNet。</li><li>[22]：提出一种密度感知多路稠密连接神经网络算法，DID-MDN。</li><li>[24、28]：GAN相关。</li><li>[29]：基于循环旋转CNN的不确定性多尺度残差学习。</li></ul><p>[1] W. Yang, R. T. Tan, J. Feng, J. Liu, Z. Guo, and S. Yan, “Deep joint rain detection and removal from a single image,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, July 2017.<br>[2] W. Yang, J. Liu, and J. Feng, “Frame-consistent recurrent video deraining with dual-level flow,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[3] K. Garg and S. K. Nayar, “Detection and removal of rain from videos,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, vol. 1, 2004, pp. I–528.<br>[4] L. W. Kang, C. W. Lin, and Y. H. Fu, “Automatic single- image-based rain streaks removal via image decomposition,” IEEE Trans. on Image Processing, vol. 21, no. 4, pp. 1742– 1755, April 2012.<br>[5] Y. Luo, Y. Xu, and H. Ji, “Removing rain from a single image via discriminative sparse coding,” in Proc. IEEE Int’l Conf. Computer Vision, 2015, pp. 3397–3405.<br>[6] Y. Li, R. T. Tan, X. Guo, J. Lu, and M. S. Brown, “Rain streak removal using layer priors,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, 2016, pp. 2736–2744.<br>[7] L. Zhu, C. Fu, D. Lischinski, and P. Heng, “Joint bi- layer optimization for single-image rain streak removal,” in Proc. IEEE Int’l Conf. Computer Vision, Oct 2017, pp. 2545– 2553.<br>[8] Z. Fan, H. Wu, X. Fu, Y. Huang, and X. Ding, “Residual- guide network for single image deraining,” in ACM Trans. Multimedia, 2018, pp. 1751–1759.<br>[9] D. Ren, W. Zuo, Q. Hu, P. Zhu, and D. Meng, “Progressive image deraining networks: A better and simpler baseline,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[10] G. Li, X. He, W. Zhang, H. Chang, L. Dong, and L. Lin, “Non-locally enhanced encoder-decoder network for single image de-raining,” in ACM Trans. Multimedia. ACM, 2018, pp. 1056–1064.<br>[11] X. Fu, B. Liang, Y. Huang, X. Ding, and J. Paisley, “Lightweight pyramid networks for image deraining,” IEEE Trans. on Neural Networks and Learning Systems, pp. 1–14, 2019.<br>[12] X.Jin,Z.Chen,J.Lin,Z.Chen,andW.Zhou,“Unsupervised single image deraining with self-supervised constraints,” in Proc. IEEE Int’l Conf. Image Processing, Sep. 2019, pp. 2761–2765.<br>[13] R. Li, L.-F. Cheong, and R. T. Tan, “Heavy rain image restoration: Integrating physics model and conditional adver- sarial learning,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[14] K. Garg and S. K. Nayar, “Vision and rain,” Int. J. Comput. Vision, vol. 75, no. 1, pp. 3–27, October 2007.<br>[15] J. Liu, W. Yang, S. Yang, and Z. Guo, “Erase or fill? deep joint recurrent rain removal and reconstruction in videos,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2018, pp. 3233–3242.<br>[16] X. Hu, C.-W. Fu, L. Zhu, and P.-A. Heng, “Depth-attentional features for single-image rain removal,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[17] L.-J. Deng, T.-Z. Huang, X.-L. Zhao, and T.-X. Jiang, “A di- rectional global sparse model for single image rain removal,” Applied Mathematical Modelling, vol. 59, pp. 662 – 679, 2018.<br>[18] X. Fu, J. Huang, X. Ding, Y. Liao, and J. Paisley, “Re- moving rain from single images via a deep detail network,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, Honolulu, Hawaii, USA, July 2017.<br>[19] ——, “Clearing the skies: A deep network architecture for single-image rain removal,” IEEE Trans. on Image Process- ing, vol. 26, no. 6, pp. 2944–2956, June 2017.<br>[20] R. Li, L.-F. Cheong, and R. T. Tan, “Single Image Deraining using Scale-Aware Multi-Stage Recurrent Network,” arXiv e-prints, p. arXiv:1712.06830, Dec 2017.<br>[21] X. Li, J. Wu, Z. Lin, H. Liu, and H. Zha, “Recurrent squeeze-and-excitation context aggregation net for single image deraining,” in Proc. IEEE European Conf. Computer Vision, 2018, pp. 262–277.<br>[22] H. Zhang and V. M. Patel, “Density-aware single image de- raining using a multi-stream dense network,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2018.<br>[23] J. Pan, S. Liu, D. Sun, J. Zhang, Y. Liu, J. Ren, Z. Li, J. Tang, H. Lu, Y.-W. Tai, and M.-H. Yang, “Learning dual convolu-tional neural networks for low-level vision,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2018.<br>[24] H. Zhang, V. Sindagi, and V. M. Patel, “Image De-raining Using a Conditional Generative Adversarial Network,” arXiv e-prints, p. arXiv:1701.05957, Jan 2017.<br>[25] W. Wei, D. Meng, Q. Zhao, Z. Xu, and Y. Wu, “Semi- supervised transfer learning for image rain removal,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recog- nition, June 2019.<br>[26] S. Li, I. B. Araujo, W. Ren, Z. Wang, E. K. Tokuda, R. H. Junior, R. Cesar-Junior, J. Zhang, X. Guo, and X. Cao, “Single image deraining: A comprehensive benchmark anal- ysis,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[27] D. Eigen, D. Krishnan, and R. Fergus, “Restoring an image taken through a window covered with dirt or rain,” in Proc. IEEE Int’l Conf. Computer Vision, December 2013.<br>[28] R. Qian, R. T. Tan, W. Yang, J. Su, and J. Liu, “Attentive generative adversarial network for raindrop removal from a single image,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2018.<br>[29] R. Yasarla and V. M. Patel, “Uncertainty guided multi-scale residual learning-using a cycle spinning cnn for single image de-raining,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[30] W. Yang, J. Liu, S. Yang, and Z. Guo, “Scale-free single image deraining via visibility-enhanced recurrent wavelet learning,” IEEE Trans. on Image Processing, vol. 28, no. 6, pp. 2948–2961, June 2019.<br>[31] X. Li, J. Wu, Z. Lin, H. Liu, and H. Zha, “Rescan: Re- current squeeze-and-excitation context aggregation net,” in Proc. IEEE European Conf. Computer Vision, Oct. 2018.<br>[32] Y. Wang, S. Liu, C. Chen, and B. Zeng, “A hierarchical approach for rain or snow removing in a single color image,” IEEE Trans. on Image Processing, vol. 26, no. 8, pp. 3936– 3950, Aug 2017.<br>[33] W. Yang, R. T. Tan, J. Feng, J. Liu, S. Yan, and Z. Guo, “Joint rain detection and removal from a single image with contex- tualized deep networks,” IEEE Trans. on Pattern Analysis and Machine Intelligence, pp. 1–1, 2019.<br>[34] T. Wang, X. Yang, K. Xu, S. Chen, Q. Zhang, and R. W. Lau, “Spatial attentive single-image deraining with a high quality real rain dataset,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2019.<br>[35] R. Li, L.-F. Cheong, and R. T. Tan, “Single Image Deraining using Scale-Aware Multi-Stage Recurrent Network,” ArXiv e-prints, December 2017.<br>[36] M. S. Gerald Schaefer, “Ucid: an uncompressed color image database,” 2003.<br>[37] P. K. Nathan Silberman, Derek Hoiem and R. Fergus, “In- door segmentation and support inference from rgbd images,” in Proc. IEEE European Conf. Computer Vision, 2012.<br>[38] C. Godard, O. Mac Aodha, and G. J. Brostow, “Unsupervised monocular depth estimation with left-right consistency,” 2017.<br>[39] M. Cordts, M. Omran, S. Ramos, T. Rehfeld, M. Enzweiler, R. Benenson, U. Franke, S. Roth, and B. Schiele, “The cityscapes dataset for semantic urban scene understanding,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, 2016.<br>[40] P. Arbelaez, M. Maire, C. Fowlkes, and J. Malik, “Contour detection and hierarchical image segmentation,” IEEE Trans. Pattern Anal. Mach. Intell., vol. 33, no. 5, pp. 898–916, May 2011.<br>[41] Zhou Wang, A. C. Bovik, H. R. Sheikh, and E. P. Simoncelli, “Image quality assessment: from error visibility to structural similarity,” IEEE Trans. on Image Processing, vol. 13, no. 4, pp. 600–612, April 2004.<br>[42] S. Gu, D. Meng, W. Zuo, and L. Zhang, “Joint convolutional analysis and synthesis sparse representation for single image layer separation,” in Proc. IEEE Int’l Conf. Computer Vision, Oct 2017, pp. 1717–1725.<br>[43] A. C. Brooks, X. Zhao, and S. Member, “Structural similarity quality metrics in a coding context: Exploring the space of realistic distortions,” IEEE Trans. on Image Processing, pp. 1261–1273, 2008.<br>[44] A. Mittal, R. Soundararajan, and A. C. Bovik, “Making a completely blind image quality analyzer,” IEEE Signal Processing Letters, vol. 20, no. 3, pp. 209–212, March 2013.<br>[45] N. Venkatanath, D. Praneeth, B. M. Chandrasekhar, S. S. Channappayya, and S. S. Medasani, “Blind image quality evaluation using perception based features,” in Proc. IEEE National Conf. Communications, 2008.<br>[46] A. Mittal, A. K. Moorthy, and A. C. Bovik, “Blind/referenceless image spatial quality evaluator,” in Conf. Record of Asilomar Conf. on Signals, Systems and Computers, Nov 2011, pp. 723–727.<br>[47] L. Zhang, L. Zhang, and A. C. Bovik, “A feature-enriched completely blind image quality evaluator,” IEEE Trans. on Image Processing, vol. 24, no. 8, pp. 2579–2591, Aug 2015.<br>[48] L. Liu, B. Liu, H. Huang, and A. C. Bovik, “No-reference image quality assessment based on spatial and spectral en- tropies,” Signal Processing: Image Communication, vol. 29, no. 8, pp. 856 – 863, 2014.<br>[49] C. Ma, C.-Y. Yang, X. Yang, and M.-H. Yang, “Learn- ing a no-reference quality metric for single-image super- resolution,” Comput. Vis. Image Underst., vol. 158, pp. 1–16, May 2017.<br>[50] X. Chen, Q. Zhang, M. Lin, G. Yang, and C. He, “No- reference color image quality assessment: from entropy to perceptual quality,” EURASIP Journal on Image and Video Processing, vol. 2019, no. 1, p. 77, Sep 2019. [Online]. Available: <a href="https://doi.org/10.1186/s13640-019-0479-7">https://doi.org/10.1186/s13640-019-0479-7</a><br>[51] S. Gabarda and G. Cristo ́bal, “Blind image quality assess- ment through anisotropy,” J. Opt. Soc. Am. A, vol. 24, no. 12, pp. B42–B51, Dec 2007.<br>[52] L. Zhang, L. Zhang, and A. C. Bovik, “A feature-enriched completely blind image quality evaluator,” IEEE Trans. on Image Processing, vol. 24, no. 8, pp. 2579–2591, Aug 2015.<br>[53] M. A. Saad, A. C. Bovik, and C. Charrier, “A dct statistics- based blind image quality index,” IEEE Signal Processing Letters, vol. 17, no. 6, pp. 583–586, June 2010.<br>[54] H. Wang, Y. Wu, M. Li, Q. Zhao, and D. Meng, “A Survey on Rain Removal from Video and Single Image,” arXiv e- prints, p. arXiv:1909.08326, Sep 2019.<br>[55] R. A. Bradley and M. E. Terry, “Rank analysis of incom- plete block designs: The method of paired comparisons,” Biometrika, vol. 39, no. 3-4, pp. 324–345, 12 1952.<br>[56] M. Elad and M. Aharon, “Image denoising via learned dictionaries and sparse representation,” in Proc. IEEE Int’l Conf. Computer Vision and Pattern Recognition, June 2006,pp. 895–900.<br>[57] A.Yamashita,Y.Tanaka,andT.Kaneko,“Removalofadher-<br>ent waterdrops from images acquired with stereo camera,” in IEEE/RSJ Int’l Conf. on Intelligent Robots and Systems, Aug 2005, pp. 400–405.<br>[58] A. Yamashita, I. Fukuchi, and T. Kaneko, “Noises removal from image sequences acquired with moving camera by esti- mating camera motion from spatio-temporal information,” in IEEE/RSJ Int’l Conf. on Intelligent Robots and Systems, Oct 2009, pp. 3794–3801.<br>[59] S. You, R. T. Tan, R. Kawakami, Y. Mukaigawa, and K. Ikeuchi, “Adherent raindrop modeling, detectionand re- moval in video,” IEEE Trans. on Pattern Analysis and Machine Intelligence, vol. 38, no. 9, pp. 1721–1733, Sep. 2016.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;这是一篇关于单图像去雨和视频</summary>
      
    
    
    
    
    <category term="论文研读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    <category term="图像去雨" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%A8/"/>
    
  </entry>
  
  <entry>
    <title>“去雨”相关论文研读（二）</title>
    <link href="http://example.com/2020/01/01/%E2%80%9C%E5%8E%BB%E9%9B%A8%E2%80%9D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2020/01/01/%E2%80%9C%E5%8E%BB%E9%9B%A8%E2%80%9D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-01-01T03:34:29.000Z</published>
    <updated>2020-09-09T12:26:46.820Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="Clearing-the-Skies-A-deep-network-architecture-for-single-image-rain-removal"><a href="#Clearing-the-Skies-A-deep-network-architecture-for-single-image-rain-removal" class="headerlink" title="Clearing the Skies: A deep network architecture for single-image rain removal"></a>Clearing the Skies: A deep network architecture for single-image rain removal</h1><blockquote><p>晴空万里：一种用于单图像雨水去除的深层网络结构</p></blockquote><p>该论文第一次将深度卷积神经网络CNN用于单幅图像去雨，同时在细节层而不是在图像域训练网络。</p><p>之前的方法仅通过低层特性将雨纹从对象细节中分离出来。当物体的结构和方向与雨纹相似时，这些方法很难同时去除雨纹和保存结构信息。另一方面，人类可以利用上下文信息等高级功能，轻松地在一张图像中分辨出雨纹。因此，提出了一种基于深度CNN网络的去雨方法。称为DerainNet。</p><h2 id="DerainNet结构"><a href="#DerainNet结构" class="headerlink" title="DerainNet结构"></a>DerainNet结构</h2><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A82/1.png" title="Optional title"></p><p>首先将输入的含雨图像分离成高频细节层及低频的base 层，将高频细节层作为输入，使用CNN进行特征的提取，得到去雨后的细节层，然后分别对base层及去雨后的细节层进行图像增强，然后相加得到输出图像。</p><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A82/2.png" title="Optional title"></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A82/3.png" title="Optional title"></p><h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A82/4.png" title="Optional title"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p>DerainNet直接自动从数据中学习了干净层和雨的细节层(即，高分辨率层)之间的非线性映射函数，同时进行了去雨和图像增强来改善视觉效果。</p><p>使用图像处理领域的知识来修正目标函数，提高去雨质量，而不是使用增加神经元或叠加隐藏层等常用策略来有效地逼近期望的映射函数。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>350张室外清晰图片，（UCID、BSD、Google），使用Photoshop生成训练数据集。添加14种不同方向和强度的雨纹。</p><h3 id="数据及代码是否开源"><a href="#数据及代码是否开源" class="headerlink" title="数据及代码是否开源"></a>数据及代码是否开源</h3><p>未提及。</p><hr><h1 id="Uncertainty-Guided-Multi-Scale-Residual-Learning-using-a-Cycle-Spinning-CNN-for-Single-Image-De-Raining"><a href="#Uncertainty-Guided-Multi-Scale-Residual-Learning-using-a-Cycle-Spinning-CNN-for-Single-Image-De-Raining" class="headerlink" title="Uncertainty Guided Multi-Scale Residual Learning-using a Cycle Spinning CNN for Single Image De-Raining"></a>Uncertainty Guided Multi-Scale Residual Learning-using a Cycle Spinning CNN for Single Image De-Raining</h1><blockquote><p>基于循环旋转CNN的不确定性多尺度残差学习</p></blockquote><hr><blockquote><p>CNN<br><a href="https://blog.csdn.net/liangchunjiang/article/details/79030681">https://blog.csdn.net/liangchunjiang/article/details/79030681</a></p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Clearing-the-Skies-A-deep-network-architecture-for-single-image-rain-removal</summary>
      
    
    
    
    
    <category term="论文研读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    <category term="图像去雨" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%A8/"/>
    
  </entry>
  
  <entry>
    <title>“去雨”相关论文研读</title>
    <link href="http://example.com/2019/12/30/%E2%80%9C%E5%8E%BB%E9%9B%A8%E2%80%9D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    <id>http://example.com/2019/12/30/%E2%80%9C%E5%8E%BB%E9%9B%A8%E2%80%9D%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/</id>
    <published>2019-12-30T07:48:45.000Z</published>
    <updated>2020-09-09T12:26:19.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="Attentive-Generative-Adversarial-Network-for-Raindrop-Removal-from-A-Single-Image"><a href="#Attentive-Generative-Adversarial-Network-for-Raindrop-Removal-from-A-Single-Image" class="headerlink" title="Attentive Generative Adversarial Network for Raindrop Removal from A Single Image"></a>Attentive Generative Adversarial Network for Raindrop Removal from A Single Image</h1><blockquote><p>一幅单一图像中雨滴去除的专注生成对抗性网络</p></blockquote><p>这篇论文主要介绍了一个新的利用单张图片去除图片中雨滴的算法。</p><p>作者使用了两种不同的神经网络来实现这三步，作者使用了Generative Network来识别图像中的雨滴，并对其进行复原。通过使用Discriminative Network来对复原后的图片进行识别，以提高复原质量。</p><p>作者使用GAN作为自己方法的算法架构。GAN通过中至少两个模块（生成模块与识别模块）的相互博弈学习产生相当好的输出。作者的生成模块和识别模块都使用神经网络组成。</p><h2 id="Generative-Network"><a href="#Generative-Network" class="headerlink" title="Generative Network"></a>Generative Network</h2><p>作者的生成模块由两个副网络组成，分别是Attentive-recurrent network和Contextual autoencoder。</p><blockquote><p>Given an input image degraded by raindrops, our generative network attempts to produce an image as real as possible and free from raindrops. The discriminative network will validate whether the image produced by the generative network looks real.</p></blockquote><blockquote><p>如果输入的图像因雨滴而退化，我们的生成网络试图生成尽可能真实、不受雨滴影响的图像。判别网络将验证生成网络产生的图像是否真实。</p></blockquote><h3 id="Attentive-recurrent-Network"><a href="#Attentive-recurrent-Network" class="headerlink" title="Attentive-recurrent Network"></a>Attentive-recurrent Network</h3><p>attentive-recurrent network的作用在于寻找原始输入图片中可能存在雨滴的部分，并将这些部分构造成attention map，从而为contextual autoencoder指定雨滴部分及雨滴附近的需要注意的区域。这个网络可以说是作者整个方法的核心部分，正是attention map的引入使得后续的操作变得精准而简单，为图像的复原提供了较好的前提条件。</p><p>attention map的实质是一个大小与原图相等的二维数组，数组中的每一个元素的值是0-1内的一个值。元素的值越大，在后续的操作中，网络会给其及其附近的区域进行优先度更高的操作。</p><p>关于attention map的数值在图片中被雨滴遮盖部分的分布，总的概括就是雨滴的边缘数值最大，雨滴的正中心数值相对来说最小。</p><blockquote><p>Our attention map, which is learned at each time step, is a matrix ranging from 0 to 1, where the greater the value, the greater attention it suggests, as shown in the visualization in Fig. 3. Unlike the binary mask, M, the attention map is a non-binary map, and represents the increasing attention from non-raindrop regions to raindrop regions, and the values vary even inside raindrop regions. This increasing attention makes sense to have, since the surrounding regions of raindrops also needs the attention, and the transparency of a raindrop area in fact varies (some parts do not totally occlude the background, and thus convey some background information).</p></blockquote><blockquote><p>我们的注意力图，是在每个时间步骤中学习的，是一个从0到1的矩阵，其中值越大，它所表示的注意力就越多，如图3中的可视化所示。与二值掩码M不同，注意映射是一种非二值映射，它代表着从非雨滴区域到雨滴区域的注意力的增加，雨滴区域内部的关注度也是不同的。这种注意力的增加是有意义的，因为雨滴周围的区域也需要注意，而雨滴区域的透明度实际上是不同的(有些部分并不完全遮住背景，从而传达了一些背景信息)。</p></blockquote><p>attractive-recurrent network的组成可以由先前的图片中得出，每一层由若干个Residual Block，一个LSTM和一个Convs组成。需要说明的是，图中的每一个“Block”由5层ResNet组成，其作用是得到输入图片的精确特征与前一个Block的模。</p><blockquote><p>Our convolution LSTM unit consists of an input gate i t , a forget gate  ft , an output gate  ot as well as a cell state ct . The interaction between states and gates along time dimension is defined as follows:</p></blockquote><blockquote><p>我们的卷积LSTM单元包括一个输入门 i t 、一个忘记门ft、一个输出门ot以及一个单元状态ct。状态与门随时间维度的相互作用定义如下：</p></blockquote><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/1.png" title="Optional title"></p><blockquote><p>where X t is the features generated by ResNet. C t encodes the cell state that will be fed to the next LSTM. H t represents the output features of the LSTM unit. Operator ∗ represents the convolution operation. The LSTM’s output feature is then fed into the convolutional layers, which generate a 2D attention map. In the training process, we initialize the values of the attention map to 0.5. In each time step, we concatenate the current attention map with the input image and then feed them into the next block of our recurrent network.</p></blockquote><blockquote><p>其中，X t 是由ResNet生成的特征； C t 对将要转递到下一个LSTM的状态进行编码； H t代表LSTM单元的输出特性；运算符 * 表示卷积运算。LSTM的输出特征随后被输入到卷积层，这将产生一个2D的注意图。在训练过程中，我们将注意力图的值初始化为0.5。在每个时间步骤中，我们将当前的注意力映射与输入连接起来，然后将它们输入到我们的递归网络的下一个块中。</p></blockquote><p>attention map并不是一次生成的，其生成过程是一个不断叠加，不断优化的过程。作者让神经网络对分别有雨点和没有雨点的图片进行学习，并找出两幅图中信息不相等的部分，并对其进行一定的运算，以找到图片中的所有雨滴.</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/2.png" title="Optional title"></p><blockquote><p>In training the generative network, we use pairs of images with and without raindrops that contain exactly the same background scene. The loss function in each recurrent block is defined as the mean squared error (MSE) between the output attention map at time step t, or A t , and the binary mask, M. We apply this process N time steps. The earlier attention maps have smaller values and get larger when approaching the N th time step indicating the increase in confidence.</p></blockquote><blockquote><p>在训练生成网络时，我们使用包含和不包含雨滴的具有完全相同背景场景的图像对。每个循环块中的损失函数定义为在时间步长t的输出注意映射，或者说At与二值掩码M之间的均方误差(MSE)。我们在N个时间步骤中应用这个过程。较早的注意映射值较小，且随着时间步长的增加而变大，这说明信任度的增加。</p></blockquote><h3 id="Contextual-Autoencoder"><a href="#Contextual-Autoencoder" class="headerlink" title="Contextual Autoencoder"></a>Contextual Autoencoder</h3><p>该部分的组成由图2可以看出，该部分的作用在于根据Attractive-recurrentNetwork得出的attention map对于雨点图像进行还原。很讨巧的是，由于attention map的给出，这一部分的工作类似于将attention map中attention值较高的部分通过该部分周围的图片信息形成的新的色块进行替换，从而实现图片信息的还原。</p><p>直接得到的复原图像G(I)并不是十分清晰，其中有一些复原点还很模糊。这是因为在复原过程中除了复原点周围过少造成的无法复原外，还有一部分是由于在卷积过程中的大小变换造成的，作者分别对两类误差进行了量化描述。</p><h2 id="Discriminative-Network"><a href="#Discriminative-Network" class="headerlink" title="Discriminative Network"></a>Discriminative Network</h2><p>GAN中Generative network的作用类似于学生根据题目进行解答，Discriminative network的作用则类似于老师。</p><p>由先前对于Generative network的介绍可以看出，最终输出的复原图像有的误差。为了鉴别这部分的误差是否能被看出，从而引入了Discriminative network。其工作原理是将Generative Network生成的复原图像和原图像作为输入，让Discriminative network对其进行鉴别，判断其是否是同一个图像，若是同一图像，则该图像的复原是成功的，若不是，则不成功，需要继续复原。</p><p>在这里作者又一次引入了attention map来简化操作。由于Generative Network的操作区域只有“attention map”所标注的区域。所以只对这些区域的误差进行判别，既减少了计算量，也在一定程度上提高了识别精度。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><blockquote><p>Our novelty lies on the use of the attention map in both generative and discriminative network. We also consider that our method is the first method that can handle relatively severe presence of raindrops, which the state of the art methods in raindrop removal fail to handle.</p></blockquote><blockquote><p>我们的方法新奇之处在于注意力图在生成网络和判别网络中的使用。我们还认为，我们的方法是第一种能够处理相对严重的雨滴存在的方法，这是目前最先进的雨滴清除方法所不能处理的。</p></blockquote><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>论文里所用到的两类图片，即干净图片和雨滴污染之后的图片均是由作者及其研究团队自行拍摄完成。所用设备原文中有提到。雨滴图片是使用玻璃板驾在镜头之前，人为泼水模拟雨滴。</p><h3 id="代码和数据是否开源"><a href="#代码和数据是否开源" class="headerlink" title="代码和数据是否开源"></a>代码和数据是否开源</h3><p>代码和数据开源。</p><hr><h1 id="Density-aware-Single-Image-De-reaining-using-a-Multi-stream-Dense-Network"><a href="#Density-aware-Single-Image-De-reaining-using-a-Multi-stream-Dense-Network" class="headerlink" title="Density-aware Single Image De-reaining using a Multi-stream Dense Network"></a>Density-aware Single Image De-reaining using a Multi-stream Dense Network</h1><blockquote><p>使用多流密集网络的密度感知单图像去雨</p></blockquote><p>这篇论文提出一种密度感知多路稠密连接神经网络算法，DID-MDN，来雨量密集估计和去雨。这种方法可以使网络自动地判断雨密度，然后有效地去除雨线。</p><p>这个方法主要针对的是，目前的去雨方法只能处理一类雨水的图片，而没有考虑不同密度和尺度的雨水，因此通用性不是很好。如果是将数据集给扩展成不同的雨水密度的数据集，单一的网络无法处理这种多密度的雨水分布。如果是为不同密度的雨水设计网络，又缺少灵活性，所以这篇文章的目的是设计一个网络可以同时处理不同密度雨水的去雨工作。基本思路是先设计一个密度分类网络，得到雨水的密度估计，然后将其fuse到雨水去除网络，实现雨水的自动去除。</p><h2 id="DID-MDN"><a href="#DID-MDN" class="headerlink" title="DID-MDN"></a>DID-MDN</h2><blockquote><p>Density-aware Image De-raining Multi-stream Dense Network</p></blockquote><p>这种网络可以自动的判断雨量密度信息（大、中、小）。这种方法包括两步：雨密度分类和雨线去除。</p><p>（1）为了准确估计雨密度级别，一种新的残差网络利用残差模块在有雨的做分类。</p><p>（2）雨线去除算法基于多流密集连接网络，它考虑了雨线的尺寸和形状信息。</p><p>一旦雨密度级别估计出来，融合已估计的雨密度信息到多流密集连接网络，得到最终的除雨的输出结果。</p><p>DID-MDN主要包括两个模块：Residual-aware Rain-density Classifier和Multi-stream Dense Network。</p><h3 id="Residual-aware-Rain-density-Classifier"><a href="#Residual-aware-Rain-density-Classifier" class="headerlink" title="Residual-aware Rain-density Classifier"></a>Residual-aware Rain-density Classifier</h3><blockquote><p>残差感知雨密度分类器</p></blockquote><p>过去的一些方法总是存在着不足：</p><p>其一，不同雨密度下效果不好。</p><blockquote><p>As discussed above, even though some of the previous methods achieve significant improvements on the de-raining performance, they often tend to over de-rain or under de-rain the image. This is mainly due to the fact that a single network may not be sufficient enough to learn different rain-densities occurring in practice.</p></blockquote><blockquote><p>如上所述，尽管先前的一些方法在去雨性能上取得了显著的改进，但它们往往倾向于过去雨或欠去雨图像。这主要是因为一个单一的网络可能不足以了解实际中发生的不同雨密度。</p></blockquote><p>其二，通用分类模型不好使。</p><blockquote><p>However, we observed that directly fine-tuning such a ‘deep’ model on our task is not an efficient solution. This is mainly due to the fact that high-level features (deeper part) of a CNN tend to pay more attention to localize the discriminative objects in the input image 46. Hence, relatively small rain-streaks may not be localized well in these high-level features. In other words, the rain-streak information may be lost in the high-level features and hence may degrade the overall classification performance. </p></blockquote><blockquote><p>然而，我们观察到，直接微调这样一个“深度”模型对我们的任务不是一个有效的解决方案。这主要是因为CNN的高层次特征（更深的部分）倾向于更关注输入图像中的可分辨对象的局部化。因此，相对较小的雨带可能不会很好地局部化在这些高层特征中。换言之，雨痕信息可能在高层特征中丢失，因此可能降低总体分类性能。</p></blockquote><p>所以这里需要估计出带雨图片和干净图片的残差也就是雨水信息，这里使用了一个多流的densenet网络，估计得到雨水的残差信息，然后输入到分类网络。残差估计模块可以看做是特征提取模块。这里在训练时，首先对残差特征提取模块进行训练，然后训练分类网络。最后两步合在一起训练，损失函数表示为:</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/3.png" title="Optional title"></p><p>其中第一项是残差信息像素的欧式距离，第二项是分类的交叉熵损失函数。</p><h3 id="Multi-stream-Dense-Network"><a href="#Multi-stream-Dense-Network" class="headerlink" title="Multi-stream Dense Network"></a>Multi-stream Dense Network</h3><blockquote><p>多流密集感知去雨网络</p></blockquote><p>由于不同的雨水密度不一样，所以这里使用多尺度的特征更有利于捕捉不同的雨水密度信息，通过使用不同卷积核的densenet实现。最后通过一个concat将这些信息融合在一起，从而融合多尺度的雨水信息。为了将雨水密度信息来引导去雨过程，上采样之后的雨水label被concat到这些雨水feature上，然后这些concat之后的特征被用来估计雨水的残差信息，用有雨水的图片减去残差信息获得coarse的去雨图片，最后通过一个refine的网络去获得输出的去雨之后的图片。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/4.png" title="Optional title"></p><p>最后损失函数被定义为:</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/5.png" title="Optional title"></p><p>其中第二项是去雨图片的欧式距离，最后一项是基于relu1_2的VGG的feature loss。</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="贡献-1"><a href="#贡献-1" class="headerlink" title="贡献"></a>贡献</h3><blockquote><p>This paper makes the following contributions:</p><ol><li>AnovelDID-MDNmethodwhichautomaticallydeter- mines the rain-density information and then efficiently removes the corresponding rain-streaks guided by the estimated rain-density label is proposed.</li><li>Based on the observation that residual can be used as a better feature representation in characterizing the rain- density information, a novel residual-aware classifier to efficiently determine the density-level of a given rainy image is proposed in this paper.</li><li>A new synthetic dataset consisting of 12,000 training images with rain-density labels and 1,200 test images is synthesized. To the best of our knowledge, this is the first dataset that contains the rain-density label in- formation. Although the network is trained on our syn- thetic dataset, it generalizes well to real-world rainy images.</li><li>Extensive experiments are conducted on three highly challenging datasets (two synthetic and one real- world) and comparisons are performed against several recent state-of-the-art approaches. Furthermore, an ab- lation study is conducted to demonstrate the effects of different modules in the proposed network.</li></ol></blockquote><blockquote><p>DID-MDN自动的判断雨量密度信息，然后通过估计出来的雨量密度标签去除雨线；基于残差可以作为更好的描述雨密度信息的特征，论文提出残差感知分类器来判断雨量密度；合成数据集包括 12000 带有雨量密度的训练图片和1200张测试图片；据作者所知这是第一个包含雨量标签的数据集。尽管是在合成数据上训练的，它可以泛化到真实世界的图片；在三个高挑战性的数据集上（两个合成、一个真实）和比赛上进行了大量的实验。</p></blockquote><h3 id="数据-1"><a href="#数据-1" class="headerlink" title="数据"></a>数据</h3><p>来自论文【4.1. Synthetic Dataset】。</p><h3 id="代码和数据是否开源-1"><a href="#代码和数据是否开源-1" class="headerlink" title="代码和数据是否开源"></a>代码和数据是否开源</h3><p>未提及。</p><hr><h1 id="Densely-Connected-Pyramid-Dehazing-Network"><a href="#Densely-Connected-Pyramid-Dehazing-Network" class="headerlink" title="Densely Connected Pyramid Dehazing Network"></a>Densely Connected Pyramid Dehazing Network</h1><blockquote><p>密集连接金字塔除雾网络</p></blockquote><blockquote><p>这是一片研究图像去雾的论文。选择这样一篇与“去雨”不相合但是有一定的相关性的论文，是想要借鉴一些这类问题的共性，即图像进化或者图像去污，而不只是着眼于“去雨”。</p></blockquote><blockquote><p>此篇略读。</p></blockquote><p>基于大气散射模型的图像去雾研究很多，主要的步骤是估计transmission map和自然光。但是绝大部分研究更多的放在精确的估计transmission map， 而利用经验公式去估计自然光，似乎都默认好的transmission map会带来比较好的去雾效果，对自然光的估计并没有很重视。现有方法主要分为基于先验信息（prior-based)的和基于深度学习(learning-based)的方法来估计transmission map。</p><p>作者认为现有的方法存在以下不足：首先是transmission map估计还不够准确。另外是估计transmission map/ 自然光等步骤是分开估计（优化）的，并非end to end，因此作者认为上述几个部分同时估计的情况下，效果会有提升。</p><p>文章中所叙述的网络包含以下几个部分：</p><h2 id="Pyramid-densely-connected-network"><a href="#Pyramid-densely-connected-network" class="headerlink" title="Pyramid densely connected network"></a>Pyramid densely connected network</h2><h3 id="dense-block"><a href="#dense-block" class="headerlink" title="dense block"></a>dense block</h3><p>用dense block做CNN的基本block来提取feature。dense block被认为是有利于融合多尺度特征。</p><h3 id="multi-level-pyramid-pooling-method"><a href="#multi-level-pyramid-pooling-method" class="headerlink" title="multi-level pyramid pooling method"></a>multi-level pyramid pooling method</h3><p>该方法是将得到的特征用不同尺寸的pooling，四个池化层，4，8，16，32分别进行，然后再扩张回到原尺寸，就算多尺度的feature。</p><p>同时优化多个task的网络还是比较难训练的，作者使用leverage stage-wise 训练的方案，先分别优化网络的每一个部分，然后再联合优化整个网络。</p><h3 id="自然光估计"><a href="#自然光估计" class="headerlink" title="自然光估计"></a>自然光估计</h3><p>作者同样假设大气光是均匀的e.g. A(z)=c constant。采用U-net来估计图像的大气光。</p><h3 id="去雾图像"><a href="#去雾图像" class="headerlink" title="去雾图像"></a>去雾图像</h3><p>根据得到的tranmission map和大气光，按照大气散射模型，估计得到去雾图像。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/6.png" title="Optional title"></p><h3 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h3><blockquote><p>与第一篇的相似之处。</p></blockquote><p>增加了一个discriminator来refine生成的transmission map， A(z)。 discriminator的作用就是让产生的transmission map 和 A(z) 像ground-truth 靠拢，而更加难以分辨。</p><h3 id="边沿的loss和总loss"><a href="#边沿的loss和总loss" class="headerlink" title="边沿的loss和总loss"></a>边沿的loss和总loss</h3><p>边沿的loss按照如下公式进行。总loss的训练方面，由于多task的同时训练不好收敛，作者提出initialization stage，先分块优化每一个小block，然后再统一训练。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/7.png" title="Optional title"></p><h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><h3 id="代码和数据是否开源-2"><a href="#代码和数据是否开源-2" class="headerlink" title="代码和数据是否开源"></a>代码和数据是否开源</h3><p>开源。</p><p>github：<a href="https://github.com/hezhangsprinter/DCPDN">https://github.com/hezhangsprinter/DCPDN</a></p><hr><h1 id="Deep-Joint-Rain-Detection-and-Removal-from-a-Single-Image"><a href="#Deep-Joint-Rain-Detection-and-Removal-from-a-Single-Image" class="headerlink" title="Deep Joint Rain Detection and Removal from a Single Image"></a>Deep Joint Rain Detection and Removal from a Single Image</h1><blockquote><p>单图像深度联合雨水检测与去除</p></blockquote><p>本文在现有的模型上，开发了一种多任务深度学习框架，学习了三个方面，包括二元雨条纹映射(binary rain streak map)，雨条纹外观和干净的背景。特别是新添加的二元雨条纹映射，其损失函数可以为神经网络提供额外的强特征。对于雨带积累现象（暴雨形成的如烟如雾的现象），采取循环雨检测和清除，以迭代和渐进方式清除。</p><p>针对去雨问题已经提出了各种算法，当前算法主要存在的问题如下：因为雨水和背景纹理的内在重叠性，当前大部分算法会平滑没有雨区域的纹理细节；雨水在图像中引起的变化是复杂的，但是当前对雨水常用的模型没有很好的覆盖真是雨水图像中的一些重要因素，例如水气，雨水的不同形状，或方向；一个重要的信息： spatial contextual information 没有被考虑。</p><p>为此该文章提出了一个新的模型用于去雨,思路大致如下： </p><p>（1）首先提出了一个基于区域的雨水模型，在模型中使用了一个二值雨水图，如果该像素位置有可见雨，那么二值图中的值为1，否则为0。 </p><p>（2）基于上面建立的模型，构建一个深度网络用于检测雨水和去除雨水。可以自动检测出雨水区域，对这些区域进行雨水去除。 </p><p>（3）提出了一个回归雨水检测去除网络，a recurrent rain detection and removal network。</p><h2 id="雨水模型及变化"><a href="#雨水模型及变化" class="headerlink" title="雨水模型及变化"></a>雨水模型及变化</h2><h3 id="常用雨水模型"><a href="#常用雨水模型" class="headerlink" title="常用雨水模型"></a>常用雨水模型</h3><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/8.png" title="Optional title"></p><p>这里B是没有雨水的图像，S是rain streak layer雨水层，O是有雨水的图像。基于该模型，去雨水被看做是两个信号的分离问题，基于观察到的O恢复B和S。</p><p>这个模型有两个问题：</p><p>（1）没有区分对待 heavy rain 和 light rain；</p><p>（2）没有区分对待 rain and non-rain regions。</p><h3 id="广义雨水模型"><a href="#广义雨水模型" class="headerlink" title="广义雨水模型"></a>广义雨水模型</h3><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/9.png" title="Optional title"></p><p>针对上述问题，提出了一个广义的雨水模型。</p><p>引入的 R 是一个二值图，1表示该位置有雨，0表示没雨。</p><h3 id="Rain-Accumulation-and-Heavy-Rain"><a href="#Rain-Accumulation-and-Heavy-Rain" class="headerlink" title="Rain Accumulation and Heavy Rain"></a>Rain Accumulation and Heavy Rain</h3><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/10.png" title="Optional title"></p><p>针对雨雾和问题，提出了上述模型来解决。</p><p>上式中每个St表示雨纹相同即方向和形状类似。</p><blockquote><p>t is the overlapping streak numbers</p></blockquote><p>t表示图像中含有的雨纹个数，即方向和形状类似种类，其中B是原图，O是带雨的图片，其他的量代表雨滴带来的影响。S指叠加的雨滴的强度，R指含雨滴范围的一个 binary mask，A对雨雾进行建模。</p><p>之所以将S、R分别描述并分别用网络预测，是为了避免只回归S影响了图中不含雨滴的部分，R实际上描述了雨滴存在的区域，这也是标题中rain detection的含义。t指的是图片中多个方向的雨叠加的效果，训练所用的合成雨的图片就是多次叠加的结果。最后A描述了一个图像整体的偏移，这是由大雨中远处大量雨滴叠加造成的类似雾的效果，实际算法中也用了去雾算法做处理。</p><h2 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h2><h3 id="数据-2"><a href="#数据-2" class="headerlink" title="数据"></a>数据</h3><p>训练数据和测试方法上都是沿用之前工作的方法。训练数据都是使用不带雨的图片人工合成带雨的图片，并从图中抽取patch进行训练。在测试流程上，对于合成图片，主要比较衡量图片结构相似度的SSIM指标。对于真实环境的带雨图片，主要是视觉上的qualitative比较。</p><h3 id="数据和代码是否开源"><a href="#数据和代码是否开源" class="headerlink" title="数据和代码是否开源"></a>数据和代码是否开源</h3><p>查询网页有提及会开源，但未找到。</p><hr><h1 id="Image-De-raining-Using-a-Conditional-Generative-Adversarial-Network"><a href="#Image-De-raining-Using-a-Conditional-Generative-Adversarial-Network" class="headerlink" title="Image De-raining Using a Conditional Generative Adversarial Network"></a>Image De-raining Using a Conditional Generative Adversarial Network</h1><blockquote><p>基于条件生成对抗网络的图像去雨</p></blockquote><p>这篇论文提出一种基于cGAN网络的一种新的去雨网络。</p><p>主要是试图使用具有强大的生成建模能力的条件GAN网络加上一个强制约束，即去雨图像必须与相应的背景图像不可区分。同时GAN网络的对抗损失提供了额外的正则化。同时，还提出了一种新的细化损失函数，旨在减少GAN网络引入的伪影。</p><p>ID-CGAN主要由两个子网络组成：密集连接的生成器（generator）和多尺度的判别器(discriminator)。</p><p>生成器子网络使用了密集连接网络。判别器主要通过多尺度池来捕获上下文信息。同时在GAN网络训练时会引入伪影，这里引入一个改进的感知损失作为额外的损失函数来去除伪影。</p><h2 id="GAN目标函数"><a href="#GAN目标函数" class="headerlink" title="GAN目标函数"></a>GAN目标函数</h2><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/11.png" title="Optional title"></p><p>G为生成器，D是判别器。</p><h2 id="对称结构Generator"><a href="#对称结构Generator" class="headerlink" title="对称结构Generator"></a>对称结构Generator</h2><p>在分离之后，新的域中的背景图像必须要转换回原来的域，这便要求了对称结构的使用。密集块体使强梯度流动成为可能，并提高了参数效率。此外，我们还引入了跨越密集块的跳跃连接，以有效地利用来自不同级别的特性，并保证更好的收敛性。</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/12.png" title="Optional title"></p><p>其中，CBLP是一组卷积层，后面依次是BN 、leaky ReLU激活函数和池化模块，括号内的数字表示每个块的输出特征映射的通道数。</p><h2 id="多尺度Discriminator"><a href="#多尺度Discriminator" class="headerlink" title="多尺度Discriminator"></a>多尺度Discriminator</h2><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/13.png" title="Optional title"></p><p>前人工作发现，基于Patch的判别是有效的，但是仍然不能捕捉到足够的上下文全局信息。因此，需要一个更强大的判别器捕捉局部和全局信息来判断图像是真是假。</p><h2 id="感知损失函数"><a href="#感知损失函数" class="headerlink" title="感知损失函数"></a>感知损失函数</h2><p>GANs训练中会引入伪影，于是引入感知损失来去除伪影。</p><p>新的损失函数为：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/14.png" title="Optional title"></p><p>其中，每个像素的欧几里得损失为：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/15.png" title="Optional title"></p><p>感知损失为：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/16.png" title="Optional title"></p><p>对抗损失为：</p><p><img src="/images/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/%E5%8E%BB%E9%9B%A8/17.png" title="Optional title"></p><h2 id="其他-4"><a href="#其他-4" class="headerlink" title="其他"></a>其他</h2><h3 id="贡献-2"><a href="#贡献-2" class="headerlink" title="贡献"></a>贡献</h3><p>提出了一种基于cGAN网络的框架用于处理单幅图像去雨问题，同时不需要任何后续处理。</p><p>提出了一个密集连接的生成器子网络。</p><p>提出了一种多尺度鉴别器，利用局部信息和全局信息来判断去雨图像的真伪。</p><h3 id="数据-3"><a href="#数据-3" class="headerlink" title="数据"></a>数据</h3><p>使用PS自建合成数据集。700张训练图，100张测试，256x256。50张真实世界图片。</p><p>评价指标：PSNR、SSIM、UQI、VIF。</p><h3 id="数据和代码是否开源-1"><a href="#数据和代码是否开源-1" class="headerlink" title="数据和代码是否开源"></a>数据和代码是否开源</h3><p>开源。</p><p><a href="https://github.com/hezhangsprinter/ID-CGAN">https://github.com/hezhangsprinter/ID-CGAN</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Attentive-Generative-Adversarial-Network-for-Raindrop-Removal-from-A-Single-</summary>
      
    
    
    
    
    <category term="论文研读" scheme="http://example.com/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/"/>
    
    <category term="图像去雨" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%A8/"/>
    
  </entry>
  
  <entry>
    <title>“一场战争”</title>
    <link href="http://example.com/2019/12/25/%E2%80%9C%E4%B8%80%E5%9C%BA%E6%88%98%E4%BA%89%E2%80%9D/"/>
    <id>http://example.com/2019/12/25/%E2%80%9C%E4%B8%80%E5%9C%BA%E6%88%98%E4%BA%89%E2%80%9D/</id>
    <published>2019-12-25T01:39:48.000Z</published>
    <updated>2020-09-09T12:01:28.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，不可转载。</p></blockquote><hr><blockquote><p>这是一场战争，我从战场归来。</p></blockquote><p>半年的时光就这么匆匆过去，我也完成了这场不知结果的考试。</p><p>现在我在图书馆，坐在这半年里我一直坐着的位置。按理说现在应该是休息的时间，只是我睡不着。说来也奇怪，考研养成的早起习惯，到今天都没有消退掉。想想之前，早起过一段时间，只要放假的日子侵蚀一两天，也就变得懒散至极，10点钟起床是常有的事情。</p><p>其实，我并不想赋予这场考试和我这半年的努力以太多的意义，因为这本身就可能是无意义的事情。和我一样战斗的朋友们也有很多，沉浸在这样的氛围里，不自觉地就把自己的所作所为当成了一种必要，当成了一种无畏的勇气和自然的选择。倒不是说这样子有什么不好，只是对我自己，我更习惯保持一种平和。</p><p>我幻想过考完之后的狂欢：睡觉睡到天昏地暗，打游戏打到日月无光。考前的那个周五晚上，我甚至下了决心，我要把我这半年欠着的所有游戏，在一周之内打得干干净净。想法是真的美好，现实也是真的无力。考完的那晚上就已经非常没劲头了。放假的第一天，上午处理了点学期末的正事，然后开始过肥宅生活直到今早。打游戏？一个小时就变得索然无味。看视频？电视剧综艺我本来就不爱看，考研前攒着的一些喜欢的up主的视频，完事之后就不想看了。睡觉？我熬夜到一两点，早晨照样7点钟醒。</p><p>仿佛一起事情都在这场战争宣告结束之后变得没有意义了起来。所以我就思考，是这场考试赋予我意义，还是我赋予这场考试意义？我觉着都不是。</p><p>在我看来，“宠辱偕忘”是人生的最高境界，也是我追求和向往的人格。不管是考前还是考后，其实我一直在给自己洗脑：你考不上的，这个考试你就是分母，就是炮灰，你就是人菜瘾大。其实这还是有点反向效果的，越是这样我就越想考上，越是这样我就越想翻身，越是这样我就觉得我越不该是这样。我本来就不该是这样。只不过这么想呢，宠倒是忘了大半，辱的感觉越来越重了。毕竟以毒攻毒和双管齐下是两种疗法，这我懂。</p><p>说起来，这半年也体味了非比寻常的生活。我不止一次的想过如果我坚持不下去了会怎样。失眠的晚上总是止不住的心跳加速，我真的好怕自己就交代在这儿了。坐在图书馆里摸鱼的时候，前半分钟想的是我怎么这么堕落，后半分钟想的是我前半分钟看的那个视频真有意思。晚上从图书馆出来，不想回宿舍，就绕着学校一圈一圈的走，走到路上都没有几个人了，才慢慢走回去。</p><p>我原本以为我是很强大的，不管是从内心还是在表面。我已经过了两年没有什么人陪伴的生活，再过半年“强化版”的也无大所谓。可事实上，每一天我都比前一天更加渴望有人能够一起交流。我这样的性格，要去主动找一个研友，在我自己这里显得没多大必要。另外一个考研的舍友是一位极度佛系的人，总之叫人家来图书馆学习是一件很难的事情，人家更享受宿舍的生活。宿舍里另有一位同学，倒是经常一起聊天，只不过并不是同一战场的朋友。图书馆里经常碰到的一位同班的同学成了这段时间的好朋友，大家关系一般，他也是一个独立惯了的人，只是枯燥的生活逼得大家团结在一起。我信任这种力量，这样的力量是比所学到的知识更加有用的收获。</p><p>中间还有过一段玻璃心的日子。其实后半段的两三个月都非常玻璃心。我关掉了朋友圈，关掉了qq，微博取关了周围的大部分人，只是不想看到他们的生活过得比我好。每天也不怎么和人交流，因为我也不知道说些什么样的话。沉默是另一种力量，是一种磨砺，哪怕在沉默中灭亡，都要比叽叽喳喳的人更有尊严。我更明白了沉默的意义，比以前。即使这半年的努力全部都是白给，但这种生活的体味，一定是不可多得的财富。</p><p>考完政治英语的那一天晚上，临睡前，莫名的想到了家人，都是一些悲观的设想。我突然觉得我对自己和家人是不是都没有做到位？如果这半年都是白费的，那么我给予周围人、家人和我自己的这么多负面情绪，连一个好的解释都没有。考前我的母亲就说要去医院体检，这件事我一直挂在心上。可现在考完了也是一堆事情压在身上，想要早回家都不现实。所以我一定要把这种残忍给我的家人们吗？多陪陪他们和实现自己的梦想，到底该选什么？我做不出选择，因为我都想要。我觉得我不称职，我只能感谢能够理解我的人。</p><p>我想要更加热爱生活，我想要做好生活中的每一件事情。追逐是一个过程，结果不是一场宣判，没有什么东西可以充当宣判，如果有的话，那只能是我自己。因为这半年的时间让我明白，不管是怎样难过的日子，都会过来的。这放在以前只是一句无力的安慰，但是我现在真切的感受到了，除了死亡，没有什么过不去的事情。只是我更希望我以后不要再体会到这些了，因为这些都是在每一个睡不着的晚上，给自己的遗言。</p><p>痛苦的意义是让以后的日子不再痛苦，成长的过程是让以后的日子少些幼稚。即使幼稚，即使痛苦，即使这样的标签会跟随一生，那又怎样？我有前进的欲望，足矣。珍惜现在的生活，才是最有意义的，除此之外，都是虚妄。现在的我，很淡然，足矣。</p><p>感谢在这半年里鼓励过着我的人，有从小玩到大的发小，有一同战斗的战友，有给予我深刻思考的信友，有老师，有家人。今后的我会不吝自己的热忱和真诚，只因为曾经有人在我战斗的时候给予我力量，也为了以后的我在战斗的时候能有更多的力量源泉。</p><p>这是一场战争，我从战场归来。不知道这是败退还是凯旋，我无谓输赢，我必然是赢家。</p><hr><p align="right">2019年12月25日 星期三上午11时主区图书馆</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，不可转载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一场战争，我从战场归来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;半年的时光就这么匆匆过去，我也完成了这场不知结果的考试。&lt;/p&gt;
&lt;p&gt;现在</summary>
      
    
    
    
    
    <category term="闲谈" scheme="http://example.com/tags/%E9%97%B2%E8%B0%88/"/>
    
    <category term="考研" scheme="http://example.com/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>操作系统五：文件管理系统</title>
    <link href="http://example.com/2019/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%94%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2019/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%94%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2019-06-16T14:40:05.000Z</published>
    <updated>2019-06-16T15:38:43.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！<br>代码、文章及图片挂载地址：<a href="https://github.com/MoyangSensei/OS">https://github.com/MoyangSensei/OS</a></p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本实验要求在模拟的I/O系统之上开发一个简单的文件系统。用户通过create,open,read等命令与文件系统交互。文件系统把磁盘视为顺序编号的逻辑块序列，逻辑块的编号为0至L−1。I/O系统利用内存中的数组模拟磁盘。</p><h2 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h2><p>实际物理磁盘的结构是多维的：有柱面、磁头、扇区等概念。I/O系统的任务是隐藏磁盘的结构细节，把磁盘以逻辑块的面目呈现给文件系统。逻辑块顺序编号，编号取值范围为0至L−1，其中L表示磁盘的存储块总数。实验中，我们可以利用数组ldisk[C][H][B]构建磁盘模型，其中CHB分别表示柱面号，磁头号和扇区号。每个扇区大小为512字节。I/O系统从文件系统接收命令，根据命令指定的逻辑块号把磁盘块的内容读入命令指定的内存区域，或者把命令指定的内存区域内容写入磁盘块。文件系统和I/O系统之间的接口由如下两个函数定义：<br>• read_block(int i, char *p);<br>该函数把逻辑块i的内容读入到指针p指向的内存位置，拷贝的字符个数为存储块的长度B。<br>• write block(int i, char *p);<br>该函数把指针p指向的内容写入逻辑块i，拷贝的字符个数为存储块的长度B。此外，为了方便测试，我们还需要实现另外两个函数：一个用来把数组ldisk 存储到文件；另一个用来把文件内容恢复到数组。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统位于I/O系统之上。</p><h3 id="用户与文件系统之间的接口"><a href="#用户与文件系统之间的接口" class="headerlink" title="用户与文件系统之间的接口"></a>用户与文件系统之间的接口</h3><p>文件系统需提供如下函数；create, destroy, open, read, write。<br>• create(filename): 根据指定的文件名创建新文件。<br>• destroy(filename): 删除指定文件。<br>• open(filename): 打开文件。该函数返回的索引号可用于后续的read, write, lseek,或close操作。<br>• close(index): 关闭制定文件。<br>• read(index, mem_area, count): 从指定文件顺序读入count个字节memarea指定的内存位置。读操作从文件的读写指针指示的位置开始。<br>• write(index, mem_area, count): 把memarea指定的内存位置开始的count个字节顺序写入指定文件。写操作从文件的读写指针指示的位置开始。<br>• lseek(index, pos): 把文件的读写指针移动到pos指定的位置。pos是一个整数，表示从文件开始位置的偏移量。文件打开时，读写指针自动设置为0。每次读写操作之后，它指向最后被访问的字节的下一个位置。lseek能够在不进行读写操作的情况下改变读写指针能位置。<br>• directory: 列表显示所有文件及其长度。</p><h3 id="文件系统的组织"><a href="#文件系统的组织" class="headerlink" title="文件系统的组织"></a>文件系统的组织</h3><p>磁盘的前k个块是保留区，其中包含如下信息：位图和文件描述符。位图用来描述磁盘块的分配情况。位图中的每一位对应一个逻辑块。创建或者删除文件，以及文件的长度发生变化时，文件系统都需要进行位图操作。前k个块的剩余部分包含一组文件描述符。每个文件描述符包含如下信息：<br>• 文件长度，单位字节<br>• 文件分配到的磁盘块号数组。该数组的长度是一个系统参数。在实验中我们可以把它设置为一个比较小的数，例如3。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>我们的文件系统中仅设置一个目录，该目录包含文件系统中的所有文件。除了不需要显示地创建和删除之外，目录在很多方面和普通文件相像。目录对应0号文件描述符。初始状态下，目录中没有文件，所有，目录对应的描述符中记录的长度应为0，而且也没有分配磁盘块。每创建一个文件，目录文件的长度便增加一分。目录文件的内容由一系列的目录项组成，其中每个目录项由如下内容组成：<br>• 文件名<br>• 文件描述符序号</p><h3 id="文件的创建与删除"><a href="#文件的创建与删除" class="headerlink" title="文件的创建与删除"></a>文件的创建与删除</h3><p>创建文件时需要进行如下操作；<br>• 找一个空闲文件描述符(扫描ldisk [0]～ldisk [k - 1])<br>• 在文件目录里为新创建的文件分配一个目录项（可能需要为目录文件分配新的磁盘块）<br>• 在分配到的目录项里记录文件名及描述符编号．<br>• 返回状态信息（如有无错误发生等）</p><p>删除文件时需要进行如下操作（假设文件没有被打开）：<br>• 在目录里搜索该文件的描述符编号<br>• 删除该文件对应的目录项并更新位图<br>• 释放文件描述符<br>• 返回状态信息</p><h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>文件系统维护一张打开文件表．打开文件表的长度固定，其表目包含如下信息：<br>• 读写缓冲区<br>• 读写指针<br>• 文件描述符号</p><p>文件被打开时，便在打开文件表中为其分配一个表目；文件被关闭时，其对应的表目被释放。读写缓冲区的大小等于一个磁盘存储块。打开文件时需要进行的操作如下：<br>• 搜索目录找到文件对应的描述符编号<br>• 在打开文件表中分配一个表目<br>• 在分配到的表目中把读写指针置为０，并记录描述符编号<br>• 读入文件的第一块到读写缓冲区中<br>• 返回分配到的表目在打开文件表中的索引号</p><p>关闭文件时需要进行的操作如下：<br>• 把缓冲区的内容写入磁盘<br>• 释放该文件在打开文件表中对应的表目<br>• 返回状态信息</p><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><p>文件打开之后才能进行读写操作．读操作需要完成的任务如下：</p><ol><li>计算读写指针对应的位置在读写缓冲区中的偏移</li><li>把缓冲区中的内容拷贝到指定的内存位置，直到发生下列事件之一：<br>• 到达文件尾或者已经拷贝了指定的字节数。这时，更新读写指针并返回相应信息<br>• 到达缓冲区末尾。这时，把缓冲区内容写入磁盘，然后把文件下一块的内容读入磁盘。最后返回第2步。</li></ol><p>其他操作请同学们自己考虑。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为了能够对我们的模拟系统进行测试，请编写一个操纵文件系统的外壳程序或者一个菜单驱动系统。</p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="Liunx视角下的文件"><a href="#Liunx视角下的文件" class="headerlink" title="Liunx视角下的文件"></a>Liunx视角下的文件</h2><p><strong>在LINUX系统中有一个重要的概念：一切都是文件。</strong>其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><p>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。之后可以自动或手动挂载其他的文件系统。因此，一个系统中可以同时存在不同的文件系统。</p><p>对于Linux系统来说，从物理磁盘到文件系统有如下概念：</p><p>我们知道文件最终是保存在硬盘上的。硬盘最基本的组成部分是由坚硬金属材料制成的涂以磁性介质的盘片，不同容量硬盘的盘片数不等。每个盘片有两面，都可记录信息。盘片被分成许多扇形的区域，每个区域叫一个扇区，每个扇区可存储128×2的N次方（N＝0.1.2.3）字节信息。在DOS中每扇区是128×2的2次方＝512字节，盘片表面上以盘片中心为圆心，不同半径的同心圆称为磁道。硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面。磁道与柱面都是表示不同半径的圆，在许多场合，磁道和柱面可以互换使用，我们知道，每个磁盘有两个面，每个面都有一个磁头，习惯用磁头号来区分。扇区，磁道（或柱面）和磁头数构成了硬盘结构的基本参数，帮这些参数可以得到硬盘的容量，基计算公式为：</p><pre><code>存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数</code></pre><p>基本要点有：</p><pre><code>（1）硬盘有数个盘片，每盘片两个面，每个面一个磁头（2）盘片被划分为多个扇形区域即扇区（3）同一盘片不同半径的同心圆为磁道（4）不同盘片相同半径构成的圆柱面即柱面（5）存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数（6）信息记录可表示为：××磁道（柱面），××磁头，××扇区</code></pre><p>那么这些空间又是怎么管理起来的呢？unix/linux使用了一个简单的方法。它将磁盘块分为以下三个部分：</p><p>（1）超级块，文件系统中第一个块被称为超级块。这个块存放文件系统本身的结构信息。比如，超级块记录了每个区域的大小，超级块也存放未被使用的磁盘块的信息。<br>（2）I-切点表。超级块的下一个部分就是i-节点表。每个i-节点就是一个对应一个文件/目录的结构，这个结构它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号<br>（3）数据区。文件系统的第3个部分是数据区。文件的内容保存在这个区域。磁盘上所有块的大小都一样。如果文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中。一个较大的文件很容易分布上千个独产的磁盘块中。</p><p>而Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成：</p><pre><code>目录项:包括文件名和inode节点号。Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。数据块：文件的具体内容存放地。</code></pre><h2 id="总体设计与代码"><a href="#总体设计与代码" class="headerlink" title="总体设计与代码"></a>总体设计与代码</h2><h3 id="磁盘分布"><a href="#磁盘分布" class="headerlink" title="磁盘分布"></a>磁盘分布</h3><p>磁盘第0块对应于文件描述符位图，共328bit；第1块到第4块，共324*8 = 1024bit对应于1024个数据块位图；接下来100块，每块一个文件描述符；接下来有1024块为数据块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEBLOCK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATABLOCK 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILEDESSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L 1129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEEPSIZE  105</span></span><br><span class="line"><span class="keyword">char</span> ldisk[L][B];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">8</span>] = &#123;<span class="number">127</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> temp_block[B];</span><br><span class="line"><span class="keyword">int</span> noofblock;</span><br></pre></td></tr></table></figure><h3 id="文件系统组织"><a href="#文件系统组织" class="headerlink" title="文件系统组织"></a>文件系统组织</h3><p>文件系统的组织磁盘的前K个块是保留区，其中包含如下信息：位图和文件描述符。位图用来描述磁盘块的分配情况。位图中的每一位对应一个逻辑块。创建或者删除文件，以及文件的长度发生变化时，文件系统都需要进行位图操作。前K个块的剩余部分包含一组文件描述符。每个文件描述符包含如下信息：</p><ul><li><p>文件长度，单位字节</p></li><li><p>文件分配到的磁盘块号数组，该数组的长度是一个指定的系统参数。</p></li></ul><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>主函数中包括系统的初始化和输入指令选择功能。功能选择模块使用输出string字符串并与关键字进行匹配来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    InitFMS();</span><br><span class="line">    load();</span><br><span class="line">    printTips();</span><br><span class="line">    <span class="keyword">int</span> opCounter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;++opCounter&lt;&lt;<span class="string">&quot;]：&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> op=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!op.compare(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">            savedata();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;create&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;File Name: &quot;</span>);</span><br><span class="line">            <span class="keyword">char</span> filename1[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,filename1);</span><br><span class="line">            <span class="keyword">if</span>(!create(filename1))&#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;delete&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;File Name: &quot;</span>);</span><br><span class="line">            <span class="keyword">char</span> filename[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,filename);</span><br><span class="line">            getchar();</span><br><span class="line">            destroy(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;open&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;File Name: &quot;</span>);</span><br><span class="line">            <span class="keyword">char</span> filename[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,filename);</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span>(!open(filename))&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR: 请输入正确的文件名！&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接下来的指令需为读写指令，请输入:&quot;</span>);</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">            <span class="keyword">if</span>(!op.compare(<span class="string">&quot;read&quot;</span>))&#123;</span><br><span class="line">                getchar();</span><br><span class="line">                <span class="keyword">char</span> temp[B];</span><br><span class="line">                read(<span class="literal">NULL</span>,temp,B);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,temp);</span><br><span class="line">                close(filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;write&quot;</span>))&#123;</span><br><span class="line">                getchar();</span><br><span class="line">                <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请输入写入内容：\n&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">                write(<span class="literal">NULL</span>,str,<span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">                close(filename);</span><br><span class="line">                getchar();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;dir&quot;</span>))&#123;</span><br><span class="line">            directory();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;clean&quot;</span>))&#123;</span><br><span class="line">            InitFMS();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!op.compare(<span class="string">&quot;help&quot;</span>))&#123;</span><br><span class="line">            printTips();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR: 请正确输入指令！&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指令功能"><a href="#指令功能" class="headerlink" title="指令功能"></a>指令功能</h3><p>本文件系统提供以下指令功能：</p><p>指令名称|对应的函数名|函数位置|功能描述<br>:-:|:-:|:-:<br>exit|-|-|退出文件管理系统（自动保存文件）<br>help|void printTips()|AuxiliaryFunction.h|显示指令功能的操作提示信息<br>dir|bool destroy(char *filename)|SystemFunction.h|显示文件目录<br>create|bool create(char *filename)|SystemFunction.h|创建未存在的文件<br>delete|bool destroy(char *filename)|SystemFunction.h|删除已存在的文件<br>open|bool open(char *filename)|SystemFunction.h|打开已存在的文件<br>close|bool close(char *index)|SystemFunction.h|关闭已打开的文件<br>write|bool write(char *index, char *mem_area, int count)|SystemFunction.h|读取已存在的文件<br>clean|void InitFMS()|SystemFunction.h|清空所有存储内容</p><p>部分重点实现的函数如下：</p><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">create</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = filename;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((length = <span class="built_in">strlen</span>(filename))&gt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件名太长！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index  = getfileheadblock();</span><br><span class="line">    setfileheadblock();</span><br><span class="line">    p=filename;</span><br><span class="line">    filedes fd;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;fd.name,filename,length+<span class="number">1</span>);</span><br><span class="line">    fd.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fd.allo[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd.allo[<span class="number">0</span>] = getfreedatablock();</span><br><span class="line">    setfileheadblock();</span><br><span class="line">    <span class="built_in">memset</span>(temp_block,<span class="number">-1</span>,B);</span><br><span class="line">    write_block(fd.allo[<span class="number">0</span>],temp_block);</span><br><span class="line">    write_block(FILEBLOCK+DATABLOCK+index,(<span class="keyword">char</span>*)&amp;fd);</span><br><span class="line">    addfile(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">open</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filedes fd;</span><br><span class="line">    read_block(DATABLOCK+FILEBLOCK,(<span class="keyword">char</span>*)&amp;fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fd.allo[i]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件不存在!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        read_block(fd.allo[i],temp_block);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;B; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp_block[j]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                filedes temp_fd;</span><br><span class="line">                read_block(DATABLOCK+FILEBLOCK+temp_block[j],(<span class="keyword">char</span>*)&amp;temp_fd);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">memcmp</span>(filename,temp_fd.name,<span class="built_in">strlen</span>(filename))==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    openFileTable.id = temp_block[j];</span><br><span class="line">                    openFileTable.index = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp_fd.allo[<span class="number">0</span>]==<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        openFileTable.p==<span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    read_block(temp_fd.allo[<span class="number">0</span>],openFileTable.Buffer);</span><br><span class="line">                    openFileTable.p = openFileTable.Buffer;</span><br><span class="line">                    openFileTable.dsc = temp_fd;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> *index, <span class="keyword">char</span> *mem_area, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=B-(openFileTable.p-openFileTable.Buffer);</span><br><span class="line">    <span class="keyword">while</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count-left&gt;<span class="number">0</span>) <span class="comment">//当前缓冲区不能满足请求，再取</span></span><br><span class="line">        &#123;</span><br><span class="line">            count-=left;</span><br><span class="line">            <span class="keyword">if</span>(openFileTable.p==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;访问超过范围\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(openFileTable.Buffer,mem_area,left);</span><br><span class="line">            write_block(openFileTable.dsc.allo[openFileTable.index],openFileTable.Buffer);</span><br><span class="line">            openFileTable.index++;</span><br><span class="line">            <span class="keyword">if</span>(openFileTable.dsc.allo[openFileTable.index]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                openFileTable.p=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            openFileTable.p = openFileTable.Buffer;</span><br><span class="line">            </span><br><span class="line">            left = B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(openFileTable.p==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;访问超过范围\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(openFileTable.p,mem_area,count);</span><br><span class="line">            write_block(openFileTable.dsc.allo[openFileTable.index],openFileTable.Buffer);</span><br><span class="line">            openFileTable.p+=count;</span><br><span class="line">            openFileTable.dsc.length+=count;</span><br><span class="line">            write_block(DATABLOCK+FILEBLOCK+openFileTable.id,(<span class="keyword">char</span>*)&amp;openFileTable.dsc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTips</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------------------------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;TIPSNAME[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>-TIPSNAME[i].length();j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;TIPSINFO[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------------------------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试运行结果"><a href="#测试运行结果" class="headerlink" title="测试运行结果"></a>测试运行结果</h2><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab5/1.png" alt="创建新文件" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab5/2.png" alt="打开新文件并写入内容" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab5/3.png" alt="删除文件" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab5/4.png" alt="help指令和clean指令" title="Optional title"></p><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.cnblogs.com/alantu2018/p/8461749.html">Linux文件系统详解：https://www.cnblogs.com/alantu2018/p/8461749.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;br&gt;代码、文章及图片挂载地址：&lt;a href=&quot;https://github.com/MoyangSensei/OS&quot;&gt;https://github.com/MoyangSensei/OS&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔记（2）：使用神经网络识别手写数字</title>
    <link href="http://example.com/2019/06/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/"/>
    <id>http://example.com/2019/06/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97/</id>
    <published>2019-06-04T14:27:45.000Z</published>
    <updated>2020-09-09T12:16:51.114Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>时间长没有深度学习的新博客了，这也快到假期了，这门课程的学习还是得捡起来。</p><p>在此之前一直在考虑一个问题：这门纯属自学的课程，我要按照什么样的方式或者顺序去学呢？想来想去最好的方法还是找一本教科书，按照教科书的内容去学，会比我个人从百度上以查找的方式和联想今天自己该学什么内容这样子会好一些。在此先挂上我所选用的教科书的信息。教科书以后说不定是会换的，但是现阶段还是打算照着这本书的目录进行学习。</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/1.png" alt="封面" title="Optional title"></p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/2.png" alt="版权信息" title="Optional title"></p><h1 id="本章前言"><a href="#本章前言" class="headerlink" title="本章前言"></a>本章前言</h1><p>大多数进行深度学习或者机器学习的人有极大概率接触过<strong>MINST手写数据集</strong>。</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/3.png" alt="MINST手写数据集大概长这样" title="Optional title"></p><p>这个数据集在这类课程中的地位大概就和在学习编程语言的时候进行的第一次控制台输出的”hello world!“一样。</p><p><strong>本章的目的，就是通过实现手写数字识别的神经网络，来好好了解一下什么是深度学习。</strong></p><hr><h1 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h1><blockquote><p>什么是神经网络？神经网络由什么组成？它如何进行工作？</p></blockquote><p>首先解释一种被称为“感知器”的人工神经元：一个感知器接受一个或多个二进制输入，给出一个二进制输出。对于每一个输入，给予<strong>权重</strong>表示该输入相对于输出的重要性。神经元的输出为二值输出，由其阈值决定，该阈值也是神经元的一个参数。</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/4.png" alt="感知器" title="Optional title"></p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/5.png" alt="神经元的输出函数" title="Optional title"></p><p><strong>可以将上述感知器看作依据权重来做出决定的设备。</strong>随着权重和阈值的变化，将得到不同的“设备”（决策模型）。但单个感知器并不可能用来做出全部的决策，因为决策往往是复杂的，是多元的。<strong>既然单个感知器做不到这样的事情，那么我们就用多个感知器如何？</strong>看看下面的感知器网络：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/6.png" alt="一个简单的感知器网络" title="Optional title"></p><p><strong>在这个网络中，每一层网络都能比前一层网络考虑的内容更复杂。换言之，每一层网络都比前一层网络考虑了更多的细节。</strong>实际上我们完全可以用感知器来实现任何逻辑功能，即与或非的运算。这说明感知器的运算是具有通用性的，但从另外一个方向考虑，<strong>难道我们不是在学习一种新的逻辑计算设备？</strong>不过实际情况就是这样，只不过是感知器区别于一般的逻辑计算设备的思路是我们可以设计我们自己的<strong>学习算法，来自动调整人工神经元的权重和偏置（阈值），这一点是非常非常非常重要的。</strong></p><p>最后，<strong>简化感知器的数学描述</strong>，两个变动：将求和写为向量的点乘、将感知器的阈值（-threshold）用偏置b代替。</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/7.png" alt="简化感知器的数学描述" title="Optional title"></p><h1 id="S型神经元"><a href="#S型神经元" class="headerlink" title="S型神经元"></a>S型神经元</h1><blockquote><p>学习算法看上去也太理想太好用了，那么如何实现神经元的学习算法？</p></blockquote><p>假设我们有一个感知器网络来帮助我们进行手写数字图像的分类。我们希望该网络能自动的学习权重和偏置，来提高正确分类的成功率。<strong>为了看清楚这个网络是怎样的学习的，我们常规的做法是把网络中的参数作微小的改动。</strong>如果这个微小的改动对于网络的结果输出的影响是巨大的，那么我们就能让学习算法变得可能。</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/8.png" alt="感知器网络对于微小变化的感知" title="Optional title"></p><p>一个例子：假如你的网络总会把8错误的认为成9，那么我们可以通过<strong>反复的进行细微改动网络参数，使8越来越容易被识别成8，这时，我们就说这个网络在进行学习。</strong></p><p>但实际上这个想法里有很大的问题：网络中单个感知器上一个权重或偏置的微小改动有时候会引起那个感知器的输出完全翻转，如0变到1。<strong>这样的翻转可能接下来引起其余网络的行为以极其复杂的方式完全改变。</strong></p><blockquote><p>抓工作不能狗熊掰棒子，去过的每个地方都要抓反馈。——摘自习近平参加十二届全国人大四次会议湖南代表团审议的讲话，2016年3月8日。</p></blockquote><p>因此，虽然8可能被正确分类，但网络在其它图像上的行为很可能以一些很难控制的方式被完全改变。这么做，8是分对了，那么012345679呢？这使得逐步修改权重和偏置来让网络接近期望行为变得困难。</p><p>对于上述问题，引入S神经元来解决问题：S型神经元和感知器类似，不同是S型神经元受整个网络的微小偏置和改动的影响是较小的。</p><p>使用和感知器相同的方式可描述S型神经元，它们都是多输入单输出的单元。它们之间的区别是：<strong>感知器的输入输出都是二值的，而S型神经元的输入不是二值的，它的每一个输入是介于[0，1]的一个值。</strong>同样的，S型神经元也有用来描述重要性的权重$w$和描述阈值的偏置$b$。</p><p>其输出也不是0和1，变为：σ(w·x+b)，其中σ被称为sigmoid函数（sigmoid函数具体是什么不重要，重要的是这个函数绘制出来的形状）：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/9.png" alt="sigmoid函数绘制出来的形状" title="Optional title"></p><p>对于上面的sigmoid函数表达式，设置一个具有输入x、权重w和偏置b的S型神经元的输出为：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/10.png" alt="一个sigmoid函数下的S型神经元示例" title="Optional title"></p><p>对于上述输出中的e^-z来说：</p><ul><li><p>当z=w·x+b是一个很大的正数时，该输出趋近于1；</p></li><li><p>当z=w·x+b是一个很大的负数时，该输出趋近于0；</p></li><li><p>只有在z取中间的一些值的时候，这个S型神经元和感知器才有较大的出入。</p></li></ul><p><strong>如果σ是个阶跃函数，既然输出会依赖于w 4+ 6是正数还是负数2,那么S型神经元会成为一个感知器。所以σ函数的平滑特性，是重点中的重点：σ的平滑意呋着杈重和偏置的微小变化，即∆w和∆σ，会从神经元产生一个微小的输出变化∆output。</strong></p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/11.png" alt="output的函数表达" title="Optional title"></p><h1 id="神经网络的架构"><a href="#神经网络的架构" class="headerlink" title="神经网络的架构"></a>神经网络的架构</h1><blockquote><p>有了学习算法之后，我们如何搭建一个神经网络？</p></blockquote><p>看看下面的网络架构：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/12.png" alt="一个典型的神经网络架构" title="Optional title"></p><p>做如下定义：</p><ul><li>最右边的一列称作输出层（output layer）</li><li>最左边的一列称作输入层（input layer）</li><li>所有不是最左边也不是最右边的神经列称作隐藏层（hidden layer）</li></ul><p>设计网络的输入输出层通常是比较直接的。例如，假设我们尝试确定一张手写数字的图像上 是否写的是“9”。那么我们可以将图片像素的强度进行编码作为输入神经元来设计网络。 如果图像是一个64 x 64的灰度图像，那么我们会需要4096 = 64 x 64个输入神经元，每个强度 取0和1之间合适的值。输出层只需要包含一个神经元，当输出值小于0.5时表示“输入图像不 是一个9”，大于0.5的值表不“输入图像是一个9”。</p><p><strong>而对于隐藏层来说，其设计流程是非常复杂的，也是神经网络架构设计中最重要的部分。</strong>目前已有众多的最优法则来帮助我们完成这件事情，让我们所设计的网络的行为更加接近我们内心所想。</p><h1 id="一个简单的分类手写数字的网络"><a href="#一个简单的分类手写数字的网络" class="headerlink" title="一个简单的分类手写数字的网络"></a>一个简单的分类手写数字的网络</h1><blockquote><p>根据上面的理论，构造一个简单的分类手写数字的网络！</p></blockquote><p>首先，一个需要说明的问题是，这里的分类网路针对的问题仅仅是识别问题，而图像分割问题则不在考虑范围之内。<strong>实际上，只要有足够精准的识别算法，分割问题便不难解决。</strong></p><p>我们设想使用一个三层的神经网络来识别单个数字：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/13.png" alt="识别单个数字的三层神经网络" title="Optional title"></p><p>对上面的神经网络做出解释：</p><p>网络的输入层包含绐输入像素的值进行编码的神经元：因为绐网络的训练数据会有很多扫描得到的28x28的手写数字的图像组成，所有输入层包含有784=28x28个神经元。为了简化，上图中已经忽略了784中大部分的输入神经元。输入像素是灰度级的，值为0.0表示白色，值为1.0表示黑色，中间数值表示逐渐暗淡的灰色。</p><p>网络的第二层是一个隐藏层。我们用n来表示神经元的数量，我们将绐n实验不同的数值。示例中用一个小的隐藏层来说明，仅仅包含n=15个神经元。</p><p>网络的输出层包含有10个神经元。如果第一个神经元激活，即输出1，那么表明网络认为 数字是一个0。如果第二个神经元激活，就表明网络认为数字是一个1。依此类推。即此处把输出神经元的输出赋予编号0到9,并计算出那个神经元有最高的激活值。</p><p>接下来的这个问题非常重要，它将帮助我们理解<strong>隐藏层在干什么</strong>：有人可能会好奇为什么用10个输出神经元。毕竟我们的任务是能让神经网络告诉我们哪个数字（0，1，2，…，9)能和输入图片匹配。一个看起来更自然的方式就是使用4个输出神经元，把每一个当做一个二进制值，结果取决于它的输出更靠近0还是1。四个神经元足够编码这个问题了，因为2^3=8 &lt; 10 &lt;2^4=16 。<strong>所以为什么我们反而要用10个神经元呢？这样做难道效率不低吗？</strong></p><p><strong>对于这个问题，大家的第一反应就是：10个输出神经元的神经网络比4个的识别效果更好。</strong>那么接下来的问题是：<strong>为什么使用10个输出神经元的神经网络更有效呢。有没有什么启发性的方法能提前告诉我 们用10个输出编码比使用4个输出编码更有好呢？</strong></p><p>假设我们用到的这10个输出编码，<strong>假设它们之中的每一个的作用是识别图片的一部分（这个假设在这个情景中极其重要！但是在这个情景之外就不重要了）</strong>。如果我们识别0的过程如下：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/14.png" alt="要被识别的0" title="Optional title"></p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2/15.png" alt="将0分成4个识别部分" title="Optional title"></p><p><strong>在上面的识别过程中，如果所有隐藏层的这四个神经元被激活那么我们就可以推断出这个数字是0。</strong>当然，这不是推断出0的唯一方式，还能通过很多其他合理的方式得到0(通过上述图像的转换，或者稍微变形)。但至少在这个例子中我们可以推断出输入的数字是0。</p><p>假设神经网络以上述方式运行，则可以绐出一个合理的理由去解释为什么用10个输出而不是4个：<strong>如果我们有4个输出，那么第一个输出神经元将会尽力去判断数字的最高有效位是什么。把数字的最高有效位和数字的形状联系起来并不是一个简单的问题。</strong></p><p>上面只是一个启发性的方法。<strong>没有什么理由表明这个三层的神经网络必须按照上面描述的方式运行，即隐藏层是用来探测数字的组成形状。</strong>可能一个聪明的学习算法将会找到一些合适的权重能让我们仅仅用4个输出神经元就行。但这个启发性的方法是很有效的，我们可以通过这种方法去构建我们想要的神经网路并使它尽可能达到高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;时间长没有深度学习的新</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理：基于SLR(1)分析法的语法制导翻译及中间代码生成</title>
    <link href="http://example.com/2019/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E5%9F%BA%E4%BA%8ESLR-1-%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <id>http://example.com/2019/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E5%9F%BA%E4%BA%8ESLR-1-%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</id>
    <published>2019-05-31T05:07:30.000Z</published>
    <updated>2020-09-10T08:33:16.032Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>此为编译原理课程的最后一个与算法有关的实验博客。</p><p>总的来说还是很不容易的。5个算法，难度依次递增，coding时间、代码量也是依次递增，不过写出它们的快乐也是依次递增的。说起来也是自己给自己增加coding难度，<strong>为了在所有代码中保持贯穿一致的数据结构</strong>，多做了很多的工作。不过写到现在也觉得这些工作是非常值得的，不管是看起来还是用起来都是十分赏心悦目的。</p><p>尤其是这一次，大概是几个实验中bug最少的一个了。当我把用代码生成的DFA和我手写的DFA进行对比，发现<strong>完全一模一样</strong>的时候，那真的是非常开心了！写到现在，对于C++ STL的运用也更加的娴熟，这也是我学习这门课程的意外收获之一。</p><p><strong>本博客会对之前4个博客的内容做综合总结。</strong></p><hr><h1 id="目标任务"><a href="#目标任务" class="headerlink" title="目标任务"></a>目标任务</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>完成以下描述赋值语句 SLR(1)文法语法制导生成中间代码四元式的过程。</p><p>G[E]:<br>A -&gt; V=E<br>E -&gt; E+T∣E-T∣T<br>T -&gt; T*F∣T/F∣F<br>F -&gt; (E)∣i<br>V -&gt; i</p><h2 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h2><p>终结符号i为用户定义的简单变量，即标识符的定义。</p><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><ul><li><p>(1) 构造文法的 SLR(1)分析表，设计语法制导翻译过程，给出每一产生式对应的语义动作;</p></li><li><p>(2) 设计中间代码四元式的结构;</p></li><li><p>(3) 输入串应是词法分析的输出二元式序列，即某赋值语句“专题1”的输出结果，输出为赋值语句的四元式序列中间文件;</p></li><li><p>(4) 设计两个测试用例(尽可能完备，正确和出错)，并给出测试结果;</p></li></ul><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="SLR-1-分析法"><a href="#SLR-1-分析法" class="headerlink" title="SLR(1)分析法"></a>SLR(1)分析法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>由于大多数适用的程序设计语言的文法不能满足LR(O)文法的条件，即使是描述一个实数变量说明的这样一个简单文法也不一定是LR(O)文法。</strong>因此对于LR(O)规范族中有冲突的项目集(状态)用向前查看一个符号的办法进行处理，以解决冲突。这种办法将能满足一些文法的需要，因为只对有冲突的状态才向前查看一个符号，以确定做那种动作，因而称这种分析方法为简单的LR(1)分析法，用SLR(1)表示。</p><p><strong>SLR(1)分析法属于LR分析法中的一种</strong>，是通过使用输入串中下一个记号来指导它的动作，<strong>它大大地提高了LR(0)分析的能力</strong>。</p><p>它通过两种方法做到这一点：</p><ul><li><p>首先，它在一个移进之前先考虑输入记号以确保存在着一个恰当的DFA 。</p></li><li><p>其次，使用构造的非终结符的Follow集合来决定是否应执行一个归约。</p></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>对于给定文法G和一语句，若要进行SLR(1)分析，一般需要进行以下步骤：</p><ul><li><p>(1) 写出已知文法G的扩展文法G’</p></li><li><p>(2) 写出扩展文法G’的初始项目集</p></li><li><p>(3) 根据状态转移构建识别G’活前缀的DFA（项目集编号为I0-IN）</p></li><li><p>(4) 求得文法G的FOLLOW集合</p></li><li><p>(5) 根据步骤(3)和(4)构建SLR(1)分析表</p></li></ul><h2 id="文法扩展"><a href="#文法扩展" class="headerlink" title="文法扩展"></a>文法扩展</h2><p>所谓G的拓展文法G’，即映入一个新的开始符号，并添加一个新的产生式：将新的开始符号作为新产生的左部，将原开始符号作为产生式的右部。</p><p>设新增的开始符号为Z，对于本实验所给文法，拓展文法G’中新增如下产生式：</p><pre><code>Z -&gt; A</code></pre><h2 id="扩展文法G’的LR-0-项目集"><a href="#扩展文法G’的LR-0-项目集" class="headerlink" title="扩展文法G’的LR(0)项目集"></a>扩展文法G’的LR(0)项目集</h2><p>构成识别一个文法活前缀的DFA项目集(状态)的全体，称之为这个文法的LR(0)项目集规范族。</p><p>对于活前缀，定义为：对于任一文法G[S]，若新的开始符号经过任意次推导得到αAω，继续经过一次推导得到αβω，若γ是αβ的前缀，则称γ是G的一个活前缀。</p><p>设分割符为“.”，对上述扩展文法G’，其全部的LR(0)项目为：</p><pre><code>Z=.A  Z=A.A -&gt; .V=E  A -&gt; V.=E  A -&gt; V=.E  A -&gt; V=E.E -&gt; .E+T  E -&gt; E.+T  E -&gt; E+.T  E -&gt; E+T.E -&gt; .E-T  E -&gt; E.-T  E -&gt; E-.T  E -&gt; E-T.E -&gt; .T  E -&gt; T.T -&gt; .T*F  T -&gt; T.*F  T -&gt; T*.F  T -&gt; T*F.T -&gt; .T/F  T -&gt; T./F  T -&gt; T/.F  T -&gt; T/F.T -&gt; .F  T -&gt; F.F -&gt; .(E)  F -&gt; (.E)  F -&gt; (E.)  F -&gt; (E).F -&gt; .i  F -&gt; i.V -&gt; .i  V -&gt; i.</code></pre><h2 id="识别G’活前缀的DFA"><a href="#识别G’活前缀的DFA" class="headerlink" title="识别G’活前缀的DFA"></a>识别G’活前缀的DFA</h2><p>首先引入如下概念：LR(0)项目集的闭包函数CLOSURE和状态转换函数GO：</p><h3 id="LR-0-项目集的闭包函数CLOSURE"><a href="#LR-0-项目集的闭包函数CLOSURE" class="headerlink" title="LR(0)项目集的闭包函数CLOSURE"></a>LR(0)项目集的闭包函数CLOSURE</h3><p>闭包函数CLOSURE(I)的定义如下：　　</p><ul><li>(1) I的项目均在CLOSURE(I)中。　　</li><li>(2) 若A -&gt; α·Bβ属于CLOSURE(I)，则每一形如B -&gt; ·γ的项目也属于CLOSURE(I)。　　</li><li>(3) 重复b)直到不出现新的项目为止。即CLOSURE(I)不再扩大。</li></ul><h3 id="LR-0-项目集的状态转换函数GO"><a href="#LR-0-项目集的状态转换函数GO" class="headerlink" title="LR(0)项目集的状态转换函数GO"></a>LR(0)项目集的状态转换函数GO</h3><p>转换函数GO(I，X)的定义：　　</p><ul><li>GO(I，X)＝CLOSURE(J)</li></ul><p>其中：I为包含某一项目的状态，J＝{任何形如A -&gt; αX·β的项目| A -&gt; α·Xβ属于I}。</p><p>这样就可以使用闭包函数和转换函数构造文法G′的LR(0)项目集规范族。</p><h3 id="LR-0-项目集规范族"><a href="#LR-0-项目集规范族" class="headerlink" title="LR(0)项目集规范族"></a>LR(0)项目集规范族</h3><p>使用闭包函数和转换函数构造文法G′的LR(0)项目集规范族，步骤如下：　　</p><ul><li><p>(1) 置项目【新开始符号 -&gt; ·原开始符号】为初态集的核，然后对核求闭包，得到初态的项目集。</p></li><li><p>(2) 对初态集或其它所构造的项目集应用转换函数GO(I，X)=CLOSURE(J)，求出新状态J的项目集。</p></li><li><p>(3) 重复(2)直到不出现新的项目为止。</p></li></ul><h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><p>至此，我们所要构造的识别文法全部或前缀的DFA为：</p><pre><code>M=&#123;C,V,GO,I0,C&#125;</code></pre><p><strong>其中，C为M的状态集也就是文法的LR(0)项目集规范族；V是M的字母表也就是文法的字汇表；GO为M的映像也就是如上定义的状态转换函数GO。</strong></p><p>对上述扩展文法G’，识别文法全部或前缀的DFA为：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/1.png" alt="图1" title="Optional title"></p><p>其中，蓝色编号为项目集的编号，绿色编号为有向边。</p><p><strong>在本文法的DFA中，共有20个项目集和38条有向边。</strong></p><h2 id="文法G的FOLLOW集合"><a href="#文法G的FOLLOW集合" class="headerlink" title="文法G的FOLLOW集合"></a>文法G的FOLLOW集合</h2><p>在构建SLR分析表的时候，文法G的FOLLOW集合用来构建归约过程。对于文法的FOLLOW集合求取，步骤见《编译原理：LL(1)语法分析》。</p><p>对于上述文法G，其FOLLOW集合为：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/2.png" alt="图2" title="Optional title"></p><h2 id="构建SLR-1-分析表"><a href="#构建SLR-1-分析表" class="headerlink" title="构建SLR(1)分析表"></a>构建SLR(1)分析表</h2><h3 id="LR-0-分析表的构造"><a href="#LR-0-分析表的构造" class="headerlink" title="LR(0)分析表的构造"></a>LR(0)分析表的构造</h3><p>LR(0)分析表的ACTION表项和GOTO表项可按如下方法构造：</p><ul><li><p>(1)若项目A -&gt;α • aβ属于 Ik 且 GO (Ik, a)= Ij, 期望字符a 为终结符，则置ACTION[k, a] =sj (j表示新状态Ij);<br>【如果圆点不在项目k最后且圆点后的期待字符a为终结符，则ACTION[k, a] =sj (j表示新状态Ij)】</p></li><li><p>(2)若项目A -&gt;α • Aβ属于 Ik，且GO (Ik, A)= Ij,期望字符 A为非终结符，则置GOTO(k, A)=j (j表示文法中第j个产生式);<br>【如果圆点不在项目k最后且圆点后的期待字符A为非终结符，则GOTO(k, A)=j (j表示文法中第j个产生式)】</p></li><li><p>(3)若项目A -&gt;α •属于Ik, 那么对任何终结符a, 置ACTION[k, a]=rj；其中，假定A-&gt;α为文法G 的第j个产生式；<br>【如果圆点在项目k最后且k不是S’ -&gt;S，那么对所有终结符a，ACTION[k, a]=rj (j表示文法中第j个产生式)】</p></li><li><p>(4)若项目S’ -&gt;S • 属于Ik, 则置ACTION[k, #]为“acc”;<br>【如果圆点在项目k最后且k是S’ -&gt;S，则ACTION[k, #]为“acc”】</p></li><li><p>(5)分析表中凡不能用上述规则填入信息的空白格均置上“出错标志”.</p></li></ul><h3 id="SLR-1-分析表的构造"><a href="#SLR-1-分析表的构造" class="headerlink" title="SLR(1)分析表的构造"></a>SLR(1)分析表的构造</h3><p>当LR(0)出现多重定义分析动作的时候，对于含有冲突的项目集：</p><pre><code>I(i)=&#123;B-&gt;α • Aβ, A-&gt;α •, C-&gt;α •&#125;</code></pre><p>对于任何输入符号a，可运用如下规则消去冲突：</p><ul><li><p>(1) 当a=b时，置[i,b]=”移进”；</p></li><li><p>(2) 当a属于FOLLOW(A)时，置[i,a]={按产生式A-&gt;α •规约}；</p></li><li><p>(3) 当a属于FOLLOW(C)时，置[i,a]={按产生式C-&gt;α •规约}；</p></li><li><p>(4) 当a不属于上述三种情况之一时，置[i,a]=”ERROR”。</p></li></ul><p><strong>需要注意的是，对于是LR(0)文法的文法来说，其LR(0)分析表和SLR(1)分析表是一样的（因为没有可消去的冲突，其余的构造方法又是一致的）。</strong></p><p>对于上述文法G’，根据DFA和FOLLOW集合构造SLR(1)分析表，如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/3.png" alt="图3" title="Optional title"></p><p>上述结果为本次实验代码生成的SLR分析表和对产生式的编号。<br><del>实际上是我懒得再把表格敲一编到这儿了就直接拿截图代替了233333</del></p><h2 id="根据构造好的SLR-1-分析表进行分析"><a href="#根据构造好的SLR-1-分析表进行分析" class="headerlink" title="根据构造好的SLR(1)分析表进行分析"></a>根据构造好的SLR(1)分析表进行分析</h2><p>SLR(1)分析分析流程同LR分析，流程图如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/4.png" alt="图4" title="Optional title"></p><h2 id="生成中间代码四元式"><a href="#生成中间代码四元式" class="headerlink" title="生成中间代码四元式"></a>生成中间代码四元式</h2><p>在做SLR（1）分析时，在归约动作进行的同时，需要执行语义动作，并生成生成中间代码四元式子。</p><h3 id="四元式结构"><a href="#四元式结构" class="headerlink" title="四元式结构"></a>四元式结构</h3><p>定义四元式结构如下：</p><ul><li>(op, agr1, arg2, result)</li></ul><p>其中，op为二元运算符；result为两运算对象arg1、arg2通过运算符op进行运算所得到的结果变量；arg1和arg2分别为op左边和右边的运算对象，<strong>该对象可以是产生式中的非终结符号，也可以是先前产生的result临时变量</strong>。</p><h3 id="如何产生四元式？"><a href="#如何产生四元式？" class="headerlink" title="如何产生四元式？"></a>如何产生四元式？</h3><p>一般的，语句中有多少个运算符，对应就要产生多少个中间代码四元式。<strong>对于含有运算符的产生式来说，如果发生的归约动作使用了这个产生式，那么就把该产生式的左部和右部按照上述结构进行记录：</strong></p><pre><code>op=产生式右部的运算符arg1=产生式右部的运算符的左边的运算对象arg2=产生式右部的运算符的右边的运算对象result=产生式左部的非终结符号</code></pre><p>如果按照产生式中的进行记录，那么对于所有的四元式来说，无法看出它们之间的关系。对应的做法是按照顺序记录这些四元式，在所有记录都完成之后，<strong>按照从上到下的顺序将任意四元式的运算对象arg1、arg2替换为上面一个四元式的result</strong>。这里需要注意的是，<strong>在记录的时候一定要按照语法分析的顺序进行记录</strong>，否则就无法进行顺序替换：<strong>按语法顺序进行的记录就是该四元式在原语句中的映射顺序记录</strong>。</p><h2 id="文件结构及函数简介"><a href="#文件结构及函数简介" class="headerlink" title="文件结构及函数简介"></a>文件结构及函数简介</h2><p>本专题大部分文件和功能函数与专题1同名，具体的文件结构和功能函数简介见《编译原理：词法分析程序》。</p><p>新增文件SLR.h，内含的函数用SLR分析表的构造及文法的扩充等。</p><p>文件firstAndFollow.h同《编译原理：LL(1)语法分析》所实现的功能一致。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>详细的主函数流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    initAll();</span><br><span class="line">    <span class="comment">//读取lab1中输出的二元组结果文件</span></span><br><span class="line">    readFile_Result();</span><br><span class="line">    <span class="comment">//读取lab1中输出的标识符结果文件</span></span><br><span class="line">    readFile_Identifier();</span><br><span class="line">    <span class="comment">//过滤读取结果，得到纯粹的标识符内容</span></span><br><span class="line">    getPureMorphemeAndSentence();</span><br><span class="line">    <span class="comment">//输出过滤后的语句</span></span><br><span class="line">    printSentenceInfo();</span><br><span class="line">    <span class="comment">//读取文法，求得包含所有的非终结符号的不重复集合</span></span><br><span class="line">    readFile_Formula();</span><br><span class="line">    <span class="comment">//求得包含所有的终结符号的不重复集合</span></span><br><span class="line">    getAllVT();</span><br><span class="line">    <span class="comment">//求得文法的first集合和follow集合以及由此构造分析表，并写入txt文件中</span></span><br><span class="line">    getFirstAndFollow();</span><br><span class="line">    <span class="comment">//文法扩充</span></span><br><span class="line">    grammarExpand();</span><br><span class="line">    <span class="comment">//求识别文法全部活前缀的DFA</span></span><br><span class="line">    DFA();</span><br><span class="line">    <span class="comment">//将所求的DFA写入txt文件中</span></span><br><span class="line">    writeFile_DFA();</span><br><span class="line">    <span class="comment">//构造SLR分析表</span></span><br><span class="line">    getSLRAnalyseTable();</span><br><span class="line">    <span class="comment">//将所求的SLR分析表写入txt文件中</span></span><br><span class="line">    writeFile_SLR1AnalyseTable();</span><br><span class="line">    <span class="comment">//进行分析</span></span><br><span class="line">    <span class="keyword">if</span>(getAnalyseResult())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配成功!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//匹配成功，输出分析栈结果</span></span><br><span class="line">        printAnalyseResultInfo();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//匹配失败，输出错误位置信息</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配失败!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        printError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造识别文法所有活前缀的DFA，首先需要构造好初态I(0)：即把【新开始符号 -&gt; ·原开始符号】加入I(0)中。然后执行循环。循环的内容为：从第0个状态开始先求取状态的闭包，然后读取所有可读取的符号，并把读取过后构造的不重复新状态加入到项目集中，等待接下来的读取。跳出循环的条件为：当项目集的个数不再增大且所有的项目集都经过求取闭包和符号移进。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dfaCounter+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator itBegin;</span><br><span class="line">    itBegin=Sentence.find(newBegin);</span><br><span class="line">    <span class="comment">//0状态的初始化： [新开始符号-&gt;.原开始符号]</span></span><br><span class="line">    dfaForG_prim[<span class="number">0</span>].dfa.insert(<span class="built_in">make_pair</span>(newBegin, fenGe+itBegin-&gt;second));</span><br><span class="line">    <span class="comment">//对0状态求闭包</span></span><br><span class="line">    dfaForG_prim[<span class="number">0</span>].dfa=closure(dfaForG_prim[<span class="number">0</span>].dfa);</span><br><span class="line">    <span class="comment">//从0状态开始循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dfaCounter;i++)&#123;</span><br><span class="line">        <span class="comment">//读取所有可读取的字符，作为新状态，并对新状态求闭包</span></span><br><span class="line">        <span class="comment">//不重复的新状态则加入dfa中，等待之后的读取</span></span><br><span class="line">        getNextSta(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数**void getNextSta(int dfaCount)**用来求当前状态的闭包和对该闭包进行读取移进的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNextSta</span><span class="params">(<span class="keyword">int</span> dfaCount)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将该状态中全部可以读取的字符做成集合</span></span><br><span class="line">    <span class="comment">//可以读取的字符：所有产生式中的紧挨着分割符的下一个字符</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; nextChar;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_1=dfaForG_prim[dfaCount].dfa.begin();it_1!=dfaForG_prim[dfaCount].dfa.end();it_1++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it_1-&gt;second.length()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it_1-&gt;second[i]==fenGe[<span class="number">0</span>])&#123;</span><br><span class="line">                nextChar.insert(it_1-&gt;second[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有可以读取的字符，该状态是终结状态</span></span><br><span class="line">    <span class="keyword">if</span>(nextChar.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有可以读取的字符，按上述所求得的集合中的内容读取</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator it_1=nextChar.begin();it_1!=nextChar.end();it_1++)&#123;</span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_2=dfaForG_prim[dfaCount].dfa.begin();it_2!=dfaForG_prim[dfaCount].dfa.end();it_2++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it_2-&gt;second.length()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(it_2-&gt;second[i]==fenGe[<span class="number">0</span>]&amp;&amp;it_2-&gt;second[i+<span class="number">1</span>]==*it_1)&#123;</span><br><span class="line">                    <span class="built_in">string</span> tempString=it_2-&gt;second;</span><br><span class="line">                    <span class="comment">//分隔符移进（读取）</span></span><br><span class="line">                    <span class="comment">//使用位操作交换第i个位置内容(分隔符)和第i+1个位置的内容</span></span><br><span class="line">                    tempString[i]=tempString[i]^tempString[i+<span class="number">1</span>];</span><br><span class="line">                    tempString[i+<span class="number">1</span>]=tempString[i]^tempString[i+<span class="number">1</span>];</span><br><span class="line">                    tempString[i]=tempString[i]^tempString[i+<span class="number">1</span>];</span><br><span class="line">                    temp.insert(<span class="built_in">make_pair</span>(it_2-&gt;first,tempString));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对移进之后的产生式求取闭包temp</span></span><br><span class="line">        temp=closure(temp);</span><br><span class="line">        <span class="keyword">bool</span> ifRepeat=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//对temp查重</span></span><br><span class="line">        <span class="comment">//如果temp和现在dfa中的任意一个状态重合，则该temp不加入dfa状态中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dfaCounter;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.size()==dfaForG_prim[i].dfa.size())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rComPare1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; rComPare2;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_3=dfaForG_prim[i].dfa.begin(), it_4=temp.begin();it_3!=dfaForG_prim[i].dfa.end();it_3++,it_4++)&#123;</span><br><span class="line">                    <span class="comment">//将所对比的两个状态的左右部全部加入向量中，便于比较</span></span><br><span class="line">                    rComPare1.push_back(it_3-&gt;second);</span><br><span class="line">                    rComPare1.push_back(<span class="string">&quot;&quot;</span>+it_3-&gt;first);</span><br><span class="line">                    rComPare2.push_back(it_4-&gt;second);</span><br><span class="line">                    rComPare2.push_back(<span class="string">&quot;&quot;</span>+it_4-&gt;first);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rComPare1==rComPare2)&#123;</span><br><span class="line">                    <span class="comment">//当前temp有重复</span></span><br><span class="line">                    ifRepeat=<span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//重复的内容有边连到当前状态</span></span><br><span class="line">                    dfaLine[dfaLineCounter].from=dfaCount;</span><br><span class="line">                    dfaLine[dfaLineCounter].read=*it_1;</span><br><span class="line">                    dfaLine[dfaLineCounter].to=i;</span><br><span class="line">                    dfaLineCounter+=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ifRepeat)&#123;</span><br><span class="line">            <span class="comment">//当前temp不重复</span></span><br><span class="line">            <span class="comment">//当前temp有边指向下一个temp</span></span><br><span class="line">            dfaLine[dfaLineCounter].from=dfaCount;</span><br><span class="line">            dfaLine[dfaLineCounter].read=*it_1;</span><br><span class="line">            dfaLine[dfaLineCounter].to=dfaCounter;</span><br><span class="line">            dfaLineCounter+=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当前temp加入dfa中成为一个新状态</span></span><br><span class="line">            dfaForG_prim[dfaCounter].dfa=temp;</span><br><span class="line">            dfaCounter+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数过程中调用了closure函数，用来求取当前状态的闭包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;char,string&gt; closure(multimap&lt;char,string&gt; a)&#123;</span><br><span class="line">    <span class="comment">//int oldSize=a.size();</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">//记录集合的大小</span></span><br><span class="line">        <span class="keyword">int</span> oldSize=a.size();</span><br><span class="line">        <span class="comment">//求取闭包temp</span></span><br><span class="line">        <span class="comment">//紧挨着分割符的下一个字符如果是非终结字符，则把以该非终结字符作为左部的所有产生式加入该状态，并使其右部的第一个位置加入分割符</span></span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; temp=a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_a=a.begin();it_a!=a.end();it_a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;it_a-&gt;second.length()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(it_a-&gt;second[i]==fenGe[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isCaptain(it_a-&gt;second[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_1=Sentence.begin();it_1!=Sentence.end();it_1++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(it_1-&gt;first==it_a-&gt;second[i+<span class="number">1</span>])&#123;</span><br><span class="line">                                <span class="comment">// 左 -&gt; 分割符 + 右</span></span><br><span class="line">                                temp.insert(<span class="built_in">make_pair</span>(it_1-&gt;first, fenGe+it_1-&gt;second));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//temp内部去重</span></span><br><span class="line">        <span class="comment">//去除重复的产生式</span></span><br><span class="line">        <span class="keyword">int</span> tempSize=temp.size();</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_1=temp.begin();it_1!=temp.end();it_1++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt;::iterator it_2=it_1;it_2!=temp.end();it_2++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(it_1!=it_2&amp;&amp;it_1-&gt;first==it_2-&gt;first&amp;&amp;!it_1-&gt;second.compare(it_2-&gt;second))&#123;</span><br><span class="line">                        <span class="comment">//erase擦去重复的产生式</span></span><br><span class="line">                        temp.erase(it_2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tempSize==temp.size())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempSize=temp.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a=temp;</span><br><span class="line">        <span class="comment">//状态不再扩大，证明是闭包，跳出</span></span><br><span class="line">        <span class="keyword">if</span>(oldSize==a.size())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造SLR分析表和进行分析则完全按照上述算法进行，不再赘述。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>依据所给文法写出给出两正确语句，并验证结果：</p><h3 id="var-d-var-a-var-b-var-c"><a href="#var-d-var-a-var-b-var-c" class="headerlink" title="var_d=var_a+var_b*var_c"></a>var_d=var_a+var_b*var_c</h3><p>将此表达式写入专题1中的SourceProgram.txt文件，运行专题1程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/5.png" alt="图5" title="Optional title"></p><p>查看标识符文件Identifier.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/6.png" alt="图6" title="Optional title"></p><p>查看词素二元组文件ResultofLexicalAnalysis.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/7.png" alt="图7" title="Optional title"></p><p>可以看到对于专题1来说，该语句是符合要求的。</p><p>接下来运行本专题的SLR(1)分析及中间代码生成程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/8.png" alt="图8" title="Optional title"></p><p>查看生成的DFA文件DFA.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/9.png" alt="图9" title="Optional title"></p><p>生成的SLR分析表文件SLR1AnalyseTable.txt见【3.6.1 SLR(1)分析表的构造】。</p><h3 id="var-a-var-b-var-c-var-d-var-e-var-f"><a href="#var-a-var-b-var-c-var-d-var-e-var-f" class="headerlink" title="var_a=var_b-(var_c+var_d/var_e)*var_f"></a>var_a=var_b-(var_c+var_d/var_e)*var_f</h3><p>将此表达式写入专题1中的SourceProgram.txt文件，运行专题1程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/10.png" alt="图10" title="Optional title"></p><p>查看标识符文件Identifier.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/11.png" alt="图11" title="Optional title"></p><p>查看词素二元组文件ResultofLexicalAnalysis.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/12.png" alt="图12" title="Optional title"></p><p>可以看到对于专题1来说，该语句是符合要求的。</p><p>接下来运行本专题的SLR(1)分析及中间代码生成程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/13.png" alt="图13" title="Optional title"><br><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/5/14.png" alt="图14" title="Optional title"></p><p>上述测试结果证明了两个程序可按设计本意顺利完成功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，编译原理与算法有关的代码编写及博客写作就告一段落。纵观所有内容，将优缺点及后续需要改进的地方进行总结：</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>使用编程语言统一（c++）、<strong>数据结构统一</strong>、输入内容统一（实验要求）、输出方式统一（包括控制台输出与文件输出）；</p></li><li><p>语法分析的4个程序的代码整体架构统一，具体为：<strong>总控程序+分析依据构造+分析算法</strong>；</p></li><li><p>细节功能封装体现的较为到位；</p></li><li><p>功能操作方便、代码泛用性高：在循环中经常使用的变量或常量均设置了全局变量，对不同规模、不同内容的文法或语句进行测试或者在别的工程中引用当前工程功能的时候，无需再次修改代码，仅需要修改txt文件即可。</p></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li><p>代码不够简洁：主要体现在对数据结构的遍历中（循环嵌套严重、为了方便循环不设置跳出等）；</p></li><li><p>在进行词法分析程序（1）编写的时候没有考虑到后面的内容，导致了很多无用或者费力的代码。</p></li></ul><h2 id="以后要做的事情"><a href="#以后要做的事情" class="headerlink" title="以后要做的事情"></a>以后要做的事情</h2><ul><li><p>程序整合：整合所有功能，精简无用、重复代码；</p></li><li><p>进一步进行功能函数的封装；</p></li><li><p>可视化前端编写。<br><del>有时间有心情我就写</del></p></li></ul><hr><p>最后，庆祝历时两个多月的编译原理的算法相关coding的完成！</p><p>记录时间：2019年4月——2019年5月31日17时37分</p><blockquote><p>最后的最后，我还想说一句，编译原理这些个东西也太难理解太难写了，我终于写完了2333～～<br>接下来的实验6是1和5的整合相当于白给，博客也懒得再写太多了都是些重复的东西，实验7是选做也相当于白给以后再说吧233333～～</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;此为编译原理</summary>
      
    
    
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理：包装生产线装瓶质量检测</title>
    <link href="http://example.com/2019/05/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%8C%85%E8%A3%85%E7%94%9F%E4%BA%A7%E7%BA%BF%E8%A3%85%E7%93%B6%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B/"/>
    <id>http://example.com/2019/05/21/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%8C%85%E8%A3%85%E7%94%9F%E4%BA%A7%E7%BA%BF%E8%A3%85%E7%93%B6%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B/</id>
    <published>2019-05-21T11:51:08.000Z</published>
    <updated>2019-05-22T08:27:06.977Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>包装生产线的质量检测：一家用瓶子装各种工业化学品的装瓶公司听说你成功解决了成像问题，并雇佣你设计一种检测瓶子未装满的方法。当瓶子在传送带上运动，并通过自动装填机和封盖机进行包装时有如下图所示的情景。当液体平面低于瓶颈底部和瓶子肩部的中间点时，认为瓶子未装满。瓶子的横断面上的倾斜部分及侧面定义为瓶子的肩部，瓶子在不断移动。公司有一个图像系统，装备了有效捕捉静止图像的前端闪光照明设备。所以你可以得到非常清晰的图像。基于以上你得到的资料，提出一种检测未完全装满的瓶子的解决方案。清楚地表述你做的所有设想和很可能对你提出的解决方案产生影响的假设。并实现它。</p><hr><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li><p>所选用的编程语言为python3.6；</p></li><li><p>编译环境：<br>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。<br>Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和markdown。用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。</p></li></ul><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/11.png" alt="搭载在Anaconda上的Jupyter Notebook" title="Optional title"></p><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>本问题的核心需求是检测图片中未满足要求的部分并标出。</p><p>首先，<strong>什么部分是“未满足要求”的部分？</strong>根据题意我们可以定义：每一个没有装满的容器会被视为未满足要求的部分。</p><p>接下来的问题是，<strong>“没有装满”的容器指的是什么样的容器？</strong>或者换一个问法：什么样的容器是合格的？对于我们来说，我们可以很轻松的判断出来，没有装满的容器是所给图片中间的那一个，而其余四个容器仅有瓶口部分是没有装满的，这样的容器我们把它视作合格。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/22.png" alt="没有装满（不合格）的容器" title="Optional title"></p><p>根据上面的标注，我们可以找到一个最明显的标志：未合格容器的空白部分明显比合格部分的空白面积大。分析到此，此题的核心需求就变成了：<strong>求出每一个容器未装满部分在图片中的面积，并将高于正常值的容器指出。</strong></p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>根据问题分析和题目标注，需要先针对所给情景作出如下断言和假设：</p><ul><li><p>原题中叙述：“公司有一个图像系统，装备了有效捕捉静止图像的前端闪光照明设备。所以你可以得到非常清晰的图像”，<strong>由此断言：所得图像的质量稳定的，即图像大小和图像内容分布（容器在图片中的相对位置）是不变的；</strong></p></li><li><p>所给的图片中仅有中间的一个容器所装的液体是明显不足的，其他四个容器的液体平面是一样高的，<strong>由此假设：其余四个容器为合格的产品，它们在瓶口处的空余部分是正常的。</strong>这一假设非常重要，<strong>它将帮助我们定义不合格产品的阈值。</strong></p></li></ul><h2 id="图像对象检测"><a href="#图像对象检测" class="headerlink" title="图像对象检测"></a>图像对象检测</h2><p>本问题所属的问题大类为图像对象检测：图像对象检测是利用图像处理与模式识别等领域的理论和方法，从图像中定位感兴趣的目标，需要准确地判断每个目标的具体类别，并给出每个目标的<strong>边界框</strong>。</p><p>对于本情景而言，所给图像为灰度图像，若想从这一角度来探索问题的解决方法，最容易想到的思想就是<strong>二值化</strong>。</p><p>在数字图像处理中，二值图像占有非常重要的地位，<strong>图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓</strong>。本体背景和所检测部位已经分别是黑白两色，非常适合这个思路。</p><p>读取图像<br>首先介绍本程序主要用到的py包： scikit-image（aka skimage）是图像处理和计算机视觉算法的集合。<strong>主要的软件包skimage提供了一些用于在图像数据类型之间转换的实用程序</strong>。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/33.png" alt="导入文件包，读取图像，输出结果" title="Optional title"></p><p>读取图像，输出图像结果，可以看到，<strong>imread函数会将图像按照行列存储为二维数组，且是归一化的灰度图</strong>。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/44.png" alt="输出读取结果及图像大小" title="Optional title"></p><p>输出图像及其大小，验证是否读取正确。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/55.png" alt="图像文件信息" title="Optional title"></p><p>输出的大小为（556，1004），再查看图片文件，发现可以匹配，同时说明该数据结构是按照像素的行列进行读取和存储的。</p><h2 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h2><p>对图像进行二值化：以归一化值域中心0.5为界线，像素值低于0.5的区域变为黑色，否则变为白色。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/66.png" alt="图像二值化" title="Optional title"></p><h2 id="图像无用部分处理"><a href="#图像无用部分处理" class="headerlink" title="图像无用部分处理"></a>图像无用部分处理</h2><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/77.png" alt="二值化后的图像" title="Optional title"></p><p>二值化后的图片如上所示，可以看出，<strong>即使对图片进行了二值化，我们想要关注的部分的轮廓也并不是非常清晰的：蓝色标记才是我们想要关注的部分，但是还有很多其他的没有被处理为背景的部分（红色标记）也出现在图中</strong>，这些部分很可能是容器侧壁的反光造成的。尤其是对于中间未合格的容器来说，它的空余部分下面还有一部分侧壁的空白与之相连，<strong>这样就造成了所要检测的区域和无关区域一同构成了连通域</strong>。</p><p>很容易明晰的一点是：我们说某一个容器所装的液体量不合格，<strong>意思是只要该容器有很小的该装液体的部分被检测到没有装液体</strong>，至于该不合格产品到底少装了多少，我们并不关心。所以我们只要看容器从瓶口部分及其往下面衍生的一部分即可，至于瓶体的下半身完全可以不用检测。</p><p>基于此，我们对该图像的无用区域进行切割和处理：按照4:6的比例分割图像，并把下60%部分舍去，直接作为背景。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/88.png" alt="二值化图像无用部分处理" title="Optional title"></p><h2 id="连通域"><a href="#连通域" class="headerlink" title="连通域"></a>连通域</h2><p>根据上述处理结果，我们就可以很明显的看出合格品和不合格品差别了。接下来，我们需要对图片中的每一块白色部分的面积做统计，这些白色部分在数字图像处理中被统称为“连通域”。</p><p>首先使用skimage.measure的字函数label获取连通域信息。这个函数的作用是：输入二值化后的数字图像矩阵，返回的内容为连通域的个数和带有连通域标记的矩阵。对于每一个连通域，都为他们赋予一个整数值。</p><p>输出的数量为16，则我们可以知道，该图像中共有17个连通域，出去编号为0的黑色背景，共有16个白色的区域，它们的编号为1-16。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/99.png" alt="输出连通域信息：无排序" title="Optional title"></p><p>将各连通域面积进行排序输出：</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1010.png" alt="输出连通域信息：排序后" title="Optional title"></p><p>数据如下：</p><pre><code>[1.0000e+00 3.0000e+00 1.0000e+01 1.3000e+01 2.0000e+01 2.1000e+01 2.5000e+01 3.2000e+01 6.6000e+01 7.1000e+01 1.2900e+02 6.8410e+031.0780e+04 1.3383e+04 1.3391e+04 2.7571e+04]</code></pre><p>再根据我们对于图片内容的观察，我们可以很容易的从数据中推断出一些内容：<strong>最大的数2.7571e+04代表了不合格区域的面积，即中间的容器</strong>，接下来的4个数6.8410e+03、1.0780e+04、1.3383e+04、1.3391e+04代表了四个合格容器，而在这四个数中，<strong>6.8410e+03与另外三个数不在一个数量级上的原因是：它代表了最右边那个不完整的合格容器</strong>。1.0780e+04比6.8410e+03稍大一些，从图中可以看出它代表了最左边那个不完整的合格容器。</p><p><strong>剩下的两个数1.3383e+04、1.3391e+04非常接近，我们便可由此断言：合格容器的空白部分上限就在这两个值附近。在这里，我们定义了判断是否合格的阈值。</strong></p><h2 id="过滤无关连通域"><a href="#过滤无关连通域" class="headerlink" title="过滤无关连通域"></a>过滤无关连通域</h2><p>上面分析了有用的值，剩下的值很明显就是无用的，因为我们在图中仅有上述5个区域需要进行判断，那么其余的连通域就是无关的连通域。我们需要将这些连通域处理为背景。</p><p>在进行上述处理前，需要先得到排序过后的面积和原面积数组的映射关系：</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1111.png" alt="排序映射" title="Optional title"></p><p>接下来，过滤无关连通域：</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1212.png" alt="过滤无关连通域" title="Optional title"></p><h2 id="判断并得到结果"><a href="#判断并得到结果" class="headerlink" title="判断并得到结果"></a>判断并得到结果</h2><p>先来查看过滤后的结果，为不同标记的连通域赋予不同的颜色，背景依旧为黑色：</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1313.png" alt="过滤无关连通域之后的结果" title="Optional title"></p><p>可以看到，需要被判断的5个连通域都被我们用不同的标记给出了。接下来，只需要用我们在上面给出的阈值对每个连通域进行判断即可。</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1414.png" alt="对连通域的面积进行判断" title="Optional title"></p><p>查看判断后的最终结果：</p><p><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1515.png" title="Optional title"><br><img src="/images/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/1616.png" alt="最终结果" title="Optional title"></p><p>可以看到，<strong>正确的部分被彩色填充，错误的部分依旧是白色的</strong>。</p><p>将这个结果和我们在一开始时对于图片的判断进行对比，发现结果完全正确，我们的程序可以达到预期的结果。</p><hr><h1 id="附录：代码"><a href="#附录：代码" class="headerlink" title="附录：代码"></a>附录：代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入文件包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> skimage <span class="keyword">as</span> img</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> skimage.measure <span class="keyword">import</span> label</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取图像</span></span><br><span class="line"><span class="comment">#io.imread返回的存储结构为 &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line">bottle = io.imread(<span class="string">&#x27;bottle.png&#x27;</span>, as_gray=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#输出读取的结果</span></span><br><span class="line">print(bottle)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示所读取的图像信息</span></span><br><span class="line">print(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">print(bottle.shape)</span><br><span class="line">io.imshow(bottle)</span><br><span class="line"></span><br><span class="line"><span class="comment">#图像二值化：以归一化值域中心0.5为界线，像素值低于0.5的区域变为黑色，否则变为白色</span></span><br><span class="line">rows,cols=bottle.shape</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">if</span> (bottle[i,j]&lt;=<span class="number">0.5</span>):</span><br><span class="line">            bottle[i,j]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bottle[i,j]=<span class="number">1</span></span><br><span class="line"><span class="comment">#显示二值化后的图像</span></span><br><span class="line">io.imshow(bottle)</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照4:6的比例分割图像，并把下60%部分舍去，直接作为背景</span></span><br><span class="line">rows,cols=bottle.shape</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(int(rows*<span class="number">0.4</span>),rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">            bottle[i,j]=<span class="number">0</span></span><br><span class="line"><span class="comment">#原图像的最上面有一条无关的白线，去除掉</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,int(rows*<span class="number">0.05</span>)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">            bottle[i,j]=<span class="number">0</span></span><br><span class="line">io.imshow(bottle)</span><br><span class="line"></span><br><span class="line"><span class="comment">#标记连通域</span></span><br><span class="line"><span class="comment">#label返回的存储结构为 &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line">bottle_label=label(bottle,background =<span class="number">0</span>,return_num=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所得到的连通域标记数组</span></span><br><span class="line">print(bottle_label)</span><br><span class="line"><span class="comment">#存储结果</span></span><br><span class="line">np.savetxt(<span class="string">&quot;bottle_label.txt&quot;</span>,bottle_label[<span class="number">0</span>],fmt=<span class="string">&quot;%s&quot;</span>,delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照标记统计各个连通域的面积</span></span><br><span class="line">area=np.zeros(bottle_label[<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">temp=np.zeros(bottle_label[<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        area[int(bottle_label[<span class="number">0</span>][i][j])]+=<span class="number">1</span></span><br><span class="line">        temp[int(bottle_label[<span class="number">0</span>][i][j])]+=<span class="number">1</span></span><br><span class="line">print(area)</span><br><span class="line"></span><br><span class="line"><span class="comment">#按对连通域的面积进行从小到大排序</span></span><br><span class="line">temp=temp[<span class="number">1</span>:]</span><br><span class="line">temp.sort()</span><br><span class="line"><span class="comment">#查看排序后的数组</span></span><br><span class="line">print(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将排序后前的数组顺序映射到排队后的数组</span></span><br><span class="line">area_sort_num=np.zeros(bottle_label[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (bottle_label[<span class="number">1</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range (<span class="number">1</span>,bottle_label[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(int(temp[i])==int(area[j])):</span><br><span class="line">            area_sort_num[i]=j</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment">#查看结果</span></span><br><span class="line">print(area_sort_num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#过滤无关的连通域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#a：过滤阈值b在排序前数组中的位置映射，用来做循环</span></span><br><span class="line">a=<span class="number">-1</span></span><br><span class="line"><span class="comment">#过滤的阈值b：如果连通域面积小于b，则会被视作背景</span></span><br><span class="line">b=(<span class="number">1.2900e+02</span>)+<span class="number">1</span></span><br><span class="line"><span class="comment">#寻找b的值，赋给a</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">    <span class="keyword">if</span>(temp[i]&gt;b):</span><br><span class="line">        a=i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">#过滤掉无关的连通域面积，使之成为背景</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(a):</span><br><span class="line">            <span class="keyword">if</span>(int(bottle_label[<span class="number">0</span>][i][j])==area_sort_num[k]):</span><br><span class="line">                bottle_label[<span class="number">0</span>][i][j]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看过滤后的结果</span></span><br><span class="line"><span class="comment">#为不同标记的连通域赋予不同的颜色，背景依旧为黑色</span></span><br><span class="line">io.imshow(bottle_label[<span class="number">0</span>],cmap=plt.cm.hot)</span><br><span class="line"></span><br><span class="line"><span class="comment">#a：过滤阈值b在排序前数组中的位置映射，用来做循环</span></span><br><span class="line">d=[]</span><br><span class="line"><span class="comment">#过滤的阈值b：如果连通域面积小于b，则会被视作背景</span></span><br><span class="line">c=(<span class="number">1.2900e+02</span>)+<span class="number">1</span></span><br><span class="line"><span class="comment">#寻找b的值，赋给a</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">    <span class="keyword">if</span>(temp[i]&gt;<span class="number">1.3391e+04</span>):</span><br><span class="line">        d.append(i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(a):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(len(d)):</span><br><span class="line">                <span class="keyword">if</span>(int(bottle_label[<span class="number">0</span>][i][j])==area_sort_num[d[k]]):</span><br><span class="line">                    bottle_label[<span class="number">0</span>][i][j]=<span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span>(int(bottle_label[<span class="number">0</span>][i][j])!=<span class="number">0</span>):</span><br><span class="line">                    bottle_label[<span class="number">0</span>][i][j]=<span class="number">1</span></span><br><span class="line">io.imshow(bottle_label[<span class="number">0</span>],cmap=plt.cm.hot)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;包装生产线的质量检测：一家用瓶子装各种</summary>
      
    
    
    
    
    <category term="数字图像处理" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理：算符优先分析</title>
    <link href="http://example.com/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90/</id>
    <published>2019-05-20T12:48:16.000Z</published>
    <updated>2019-05-21T11:51:12.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><blockquote><p>今天是个更博的好日子。</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>至此，编译原理实验已经写到第四个实验了。</p><p>回想起之前在学期刚开始之前，都说这门课的难度非常之高。现在是教学周第十三周，那么也就没几周就<del>又</del>要进行考试了。要说我对这门课程的看法，那就是“痛并快乐着”。</p><p>这门课程的实验，讲实话，是我到目前为止学到的课程的课程实验中最有用的。对我个人而言，只有做了这些实验才明白了到底学了些什么东西。<del>大概上课都在跑神，什么都没听懂233333</del></p><p>而且这些实验的设置对于我这种养成癖好的人来说简直是太有成就感了！第一个实验的结果在之后的实验中都会被用到，这无疑增加了我在进行所有实验时的综合考量：我要把数据结构写成什么样子才能在之后的实验中好用？我要用什么样的方式展示这几次实验之间的关联？这样的话，我每次在写实验的时候，仿佛写的不是一个实验<del>大概是写编译原理这本书233333</del>。这根本就不是一次次无生命的博客写作，而是我倾注了心血的杰作<del>女朋友</del>!</p><p>作为一个大三的、今后上学无望的菜鸟，我一直在思考，我把作业写得这样认真到底为了什么（我自认为我的实验代码和文档博客都写的非常认真，至少在我认识的人里面，我的认真程度排前三大概是没有问题）。毕竟成绩对我来说已经不重要了。我还没有寻到答案，姑且就算现在的认真是这种养成和堆砌的成就感带给我的。</p><p>做人需要认真，认真就要具象。</p><p>做人更要抽象，抽象才会快乐。</p><p><strong>努力认真，8懂就问，能快乐多久就快乐多久。</strong></p><hr><h1 id="目标任务"><a href="#目标任务" class="headerlink" title="目标任务"></a>目标任务</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>完成以下描述赋值语句的 LL(1)文法的 LL(1)分析过程。</p><pre><code>G[E]:E→E+T∣E-T∣T T→T*F∣T/F∣FF→(E)∣i</code></pre><h2 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h2><p>终结符号i为用户定义的简单变量，即标识符的定义。</p><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><ul><li><p>(1)构造该算符优先文法的优先关系矩阵或优先函数;</p></li><li><p>(2)输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果。</p></li><li><p>(3)算符优先分析过程应能发现输入串出错。</p></li><li><p>(4)设计两个测试用例(尽可能完备，正确和出错)，并给出测试结果;</p></li><li><p>(5)考虑编写程序根据算符优先文法构造算符优先关系矩阵，并添加到你的算符优先分析程序中。</p></li></ul><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h2><p>算符优先分析法(Operator Precedence Parse)是仿效四则运算的计算过程而构造的一种语法分析方法。算符优先分析法的关键是比较两个相继出现的终结符的优先级而决定应采取的动作。</p><p><strong>算符优先分析法是一种自下而上的分析方法。</strong></p><p>该分析法的优点是：简单，有效，适合表达式的分析。而它的缺点有：<strong>只适合于算符优先文法</strong>，是一个不大的文法类。</p><h2 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h2><p>其文法的特点是文法的产生式中不含两个相邻的非终结符。其定义如下：</p><p>假定G是不含ε- 产生式的算符文法。对于任何一对终结符a、b，我们说：</p><ul><li><p>（1）a等于b当且仅当文法G中含有形如P→ ···ab···或P→···aQb···的产生式；</p></li><li><p>（2）a小于b当且仅当G中含有形如P→···aR···的产生式，而R(+=&gt;)b···或R(+=&gt;)Qb···；</p></li><li><p>（3）a大于b当且仅当G中含有形如P→···Rb···的产生式，而R(+=&gt;)···a或R(+=&gt;)···aQ；</p></li></ul><p>如果一个算符文法G中的任何终结符对（a,b）最多满足下述三个条件之一：</p><pre><code>a=b,a&lt;b,a&gt;b</code></pre><p>则称G是一个算符优先文法。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>若想进行算符优先分析，首先我们需要对所给的文法做检查：<strong>该文法是否是算符优先文法？</strong></p><p>接下来是一系列的准备工作：</p><p>（1）对该算符优先文法中的所有非终结符号求FristVT集合；</p><p>（2）对该算符优先文法中的所有非终结符号求LastVT集合；</p><p>（3）根据所求得的FristVT集合和LastVT集合，构造该算符优先文法的算符优先关系矩阵。</p><p>一系列准备工作做完之后，就可根据算符优先分析法的流程对语句进行分析。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/1.png" alt="图1" title="Optional title"></p><h2 id="检查是否是算符优先文法"><a href="#检查是否是算符优先文法" class="headerlink" title="检查是否是算符优先文法"></a>检查是否是算符优先文法</h2><p><strong>算符优先分析法的分析范围仅限于算符优先文法</strong>，所以这一步骤是有必要的。</p><p>但是，由于是题目所给的文法，在这里可以又省略过这个步骤。</p><p>实际上，<strong>在进行算符优先关系矩阵的构造时，上述算符优先文法的三条定义都会体现出来</strong>。需要我们检查的只是该文法中是否有ε-产生式：显然，该文法是没有ε-产生式的。</p><h2 id="构造FristVT集合和LastVT集合"><a href="#构造FristVT集合和LastVT集合" class="headerlink" title="构造FristVT集合和LastVT集合"></a>构造FristVT集合和LastVT集合</h2><h3 id="为什么要构造这两个集合？"><a href="#为什么要构造这两个集合？" class="headerlink" title="为什么要构造这两个集合？"></a>为什么要构造这两个集合？</h3><p>在前面对算符之间优先级关系的定义中，有一个现象是要去找一个非终结符的首终结符和尾终结符，为了便于计算机操作，定义如下两个概念：</p><ul><li><p>首终结符集：FIRSTVT(B） = {b | B → b… 或 B → Cb… }</p></li><li><p>尾终结符集：LASTVT(B) = {b| B → …b 或 B → …bC}</p></li></ul><p>所以，对之前关于算符之间的优先级关系有了新的表示：</p><ul><li><p>= 关系： A → …ab… 或 A → …aBb…</p></li><li><p>&lt; 关系： A → …aB…，对于每一个 b ∈ FIRSTVT(B) ， 都有a &lt; b</p></li><li><p>&gt; 关系： A → …Bb…，对于每一个 a ∈ LASTVT(B)，都有 a &gt; b</p></li></ul><h3 id="如何构造这两个集合？"><a href="#如何构造这两个集合？" class="headerlink" title="如何构造这两个集合？"></a>如何构造这两个集合？</h3><p>对于文法中的任意非终结符号B，FIRSTVT(B)直接根据定义递归构造：</p><ul><li><p>（1）若有产生式B→a…或B→Qa…，则 a ∈ FIRSTVT(B)；</p></li><li><p>（2）若有产生式P→Q…，则有 FIRSTVT(Q) ∈ FIRSTVT(B)。</p></li></ul><p>同理，LASTVT(B)直接根据定义递归构造：</p><ul><li><p>（1）若有产生式 B→…a 或 B→…aQ，则 a ∈ LASTVT(B)；</p></li><li><p>（2）若有产生式 B→…Q，则有 LASTVT(Q) ∈ LASTVT(B)。</p></li></ul><p><strong>此处需要递归的原因有二：一是该算法需要执行到非终结符号B的FIRSTVT集合或LASTVT集合不再增大为止；二是对于上述定义，两集合的第二条定义都需要其他的非终结符号的FIRSTVT集合或LASTVT集合来帮助构造目标符号B的FIRSTVT集合或LASTVT集合。</strong></p><p>对于本次所给的文法，执行上面的构造算法，可得如下结果：</p><ul><li>FirstVT[E] = { ( * + - / i }</li><li>FirstVT[F] = { ( i }</li><li>FirstVT[T] = { ( * / i }</li><li>LastVT[E] = { ) * + - / i }</li><li>LastVT[F] = { ) i }</li><li>LastVT[T] = { ) * / i }</li></ul><h2 id="构造算符优先关系矩阵"><a href="#构造算符优先关系矩阵" class="headerlink" title="构造算符优先关系矩阵"></a>构造算符优先关系矩阵</h2><p>算符优先分析法的基本原理是：识别句柄并归约。</p><p>该分析方法的具体做法是：利用&lt;识别句柄尾，利用&gt;识别句柄头，分析栈存放已识别部分，比较栈顶和下一输入符号的关系，如果是句柄尾，则沿栈顶向下寻找句柄头，找到后弹出句柄，归约为非终结符。</p><p>对于所给句子，我们需要时刻查询相邻终结符号的优先关系。此时就需要将各种优先关系存放在一张查询表中，称为算符优先关系矩阵。</p><p>算符优先关系矩阵可通过如下步骤构造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(每条产生式  P -&gt; X1X2X3...Xn) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(X(i) 和 X(i+<span class="number">1</span>) 均为终结符) &#123;</span><br><span class="line">            X(i) = X(i+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= n<span class="number">-2</span> &amp;&amp; X(i) 和X(i+<span class="number">2</span>)均为终结符 &amp;&amp; X(i+<span class="number">1</span>) 为非终结符) &#123;</span><br><span class="line">            X(i) = X(i+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(X(i) 为终结符 &amp;&amp; X(i+<span class="number">1</span>)为非终结符) &#123;</span><br><span class="line">            <span class="keyword">for</span>(FIRSTVT(X(i+<span class="number">1</span>))中的每一个元素a) &#123;</span><br><span class="line">                  Xi &lt; a</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(X(i) 为非终结符 &amp;&amp; X(i+<span class="number">1</span>)为终结符) &#123;</span><br><span class="line">            <span class="keyword">for</span>(LASTVT(X(i))中的每一个元素a) &#123;</span><br><span class="line">                  a &gt; X(i+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前讨论过算符优先文法的检查，这里可以给出一种方法：<strong>如果一个文法G按上述算法构造出的优先矩阵是没有重定义项的，文法G是算符优先文法。</strong></p><p>对于本次所给的文法，执行上面的构造算法，可得如下结果：</p><p>|井|(|)|*|+|-|/|i<br>-|-|-|-|-|-|-|-|-<br>井|A|&lt;||&lt;|&lt;|&lt;|&lt;|&lt;<br>(||&lt;|=|&lt;|&lt;|&lt;|&lt;|&lt;<br>)|&gt;||&gt;|&gt;|&gt;|&gt;|&gt;|<br>*|&gt;|&lt;|&gt;|&gt;|&gt;|&gt;|&gt;|&lt;<br>+|&gt;|&lt;|&gt;|&lt;|&gt;|&gt;|&lt;|&lt;<br>-|&gt;|&lt;|&gt;|&lt;|&gt;|&gt;|&lt;|&lt;<br>/|&gt;|&lt;|&gt;|&gt;|&gt;|&gt;|&gt;|&lt;<br>i|&gt;||&gt;|&gt;|&gt;|&gt;|&gt;|</p><h2 id="根据算符优先关系矩阵进行分析"><a href="#根据算符优先关系矩阵进行分析" class="headerlink" title="根据算符优先关系矩阵进行分析"></a>根据算符优先关系矩阵进行分析</h2><p>构造好算符优先关系矩阵之后，便可进行分析。</p><p>流程如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/2.png" alt="图2" title="Optional title"></p><h2 id="文件结构及函数简介"><a href="#文件结构及函数简介" class="headerlink" title="文件结构及函数简介"></a>文件结构及函数简介</h2><p>本专题大部分文件和功能函数与专题1同名，具体的文件结构和功能函数简介见《编译原理：词法分析程序》。</p><p>新增文件OPGMatrix.h，内含的函数用作预测分析的准备工作，即求算符优先文法的FirstVT集合、LastVT集合和构造算符优先关系矩阵。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>详细的主函数流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    initAll();</span><br><span class="line">    <span class="comment">//读取lab1中输出的二元组结果文件</span></span><br><span class="line">    readFile_Result();</span><br><span class="line">    <span class="comment">//读取lab1中输出的标识符结果文件</span></span><br><span class="line">    readFile_Identifier();</span><br><span class="line">    <span class="comment">//过滤读取结果，得到纯粹的标识符内容</span></span><br><span class="line">    getPureMorphemeAndSentence();</span><br><span class="line">    <span class="comment">//输出过滤后的语句</span></span><br><span class="line">    printSentenceInfo();</span><br><span class="line">    <span class="comment">//读取文法，求得包含所有的非终结符号的不重复集合</span></span><br><span class="line">    readFile_Formula();</span><br><span class="line">    <span class="comment">//求得包含所有的终结符号的不重复集合</span></span><br><span class="line">    getAllVT();</span><br><span class="line">    <span class="comment">//求得文法的FirstVT集合和LastVT集合以及由此构造分析表，并写入txt文件中</span></span><br><span class="line">    getFirstVT();</span><br><span class="line">    getLastVT();</span><br><span class="line">    <span class="comment">//求得算符优先矩阵，并写入txt文件中</span></span><br><span class="line">    getOPGMatrix();</span><br><span class="line">    writeFile_OPGMatrix();</span><br><span class="line">    <span class="comment">//进行分析</span></span><br><span class="line">    <span class="keyword">if</span>(getAnalyseResult())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配成功!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//匹配成功，输出分析栈结果</span></span><br><span class="line">        printAnalyseResultInfo();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//匹配失败，输出错误位置信息</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配失败!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        printError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数getFirstVT()用来求得文法的FirstVT集合。根据FirstVT的构造定义，第一条规则的构造是非常容易理解的，简言之，<strong>只要将处在产生式第一个位置的终结符号和处在产生式第二个位置的终结符号（此处第一个位置必须是非终结符号）填入目标非终结符号的FirstVT集合中即可。该规则仅需对所有产生式进行一次遍历即可完成。</strong></p><p>而对于第二条规则，则需要借助上一步所求得的所有非终结符号的部分FirstVT集。设置一标志位，进行<strong>无限循环</strong>：如果在一次循环中，所有的非终结符号中的一个或多个的FirstVT集有扩充，该标志位就被设置为false，代表着还需要进行下一轮的构造。构造停止的标志是：经过上一轮的构造，该文法中的任意非终结符号的FirstVT集均没有再进行扩充。</p><p><strong>上述写法避免了递归调用函数，但缺点需要针对两条规则分别设置条件进行循环，且在进行第二条规则的构造之前，必须将第一条规则的内容构造完整且保证正确。</strong></p><p>getLastVT()函数同理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFirstVT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将处在产生式第一个位置的终结符号和处在产生式第二个位置的终结符号（此处第一个位置必须是非终结符号）填入目标非终结符号的FirstVT集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator iterVN=VN.begin();iterVN!=VN.end();iterVN++)&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; firstVT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;::iterator iterF=Sentence.begin();iterF!=Sentence.end();iterF++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iterF-&gt;first==*iterVN)&#123;</span><br><span class="line">                <span class="comment">//产生式右部的第一个符号是终结符号</span></span><br><span class="line">                <span class="keyword">char</span> ch=iterF-&gt;second[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(!isCaptain(ch))&#123;</span><br><span class="line">                    firstVT.insert(ch);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//产生式右部的第一个符号是非终结符号</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//产生式长度大于2是才做此判断</span></span><br><span class="line">                    <span class="keyword">if</span>(iterF-&gt;second.length()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//产生式右部的第二个符号是非终结符号</span></span><br><span class="line">                        ch=iterF-&gt;second[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(!isCaptain(ch))&#123;</span><br><span class="line">                            firstVT.insert(ch);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将初步构造好的FirstVT集合填入容器中</span></span><br><span class="line">        FirstVTSet.insert(<span class="built_in">make_pair</span>(*iterVN, firstVT));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对第二条规则进行无限循环的构造</span></span><br><span class="line">    <span class="comment">//跳出条件是：经过上一轮的构造，该文法中的任意非终结符号的FirstVT集均没有再进行扩充</span></span><br><span class="line">    <span class="keyword">bool</span> ifFindAll=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!ifFindAll)&#123;</span><br><span class="line">        ifFindAll=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;::iterator iterF=Sentence.begin();iterF!=Sentence.end();iterF++)&#123;</span><br><span class="line">            <span class="comment">//产生式右部的第一个符号是非终结符号</span></span><br><span class="line">            <span class="keyword">if</span>(isCaptain(iterF-&gt;second[<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt;::iterator iterFVTS1=FirstVTSet.begin();iterFVTS1!=FirstVTSet.end();iterFVTS1++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(iterFVTS1-&gt;first==iterF-&gt;first)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt;::iterator iterFVTS2=FirstVTSet.begin();iterFVTS2!=FirstVTSet.end();iterFVTS2++)&#123;</span><br><span class="line">                            <span class="keyword">int</span> len=iterFVTS1-&gt;second.size();</span><br><span class="line">                            <span class="keyword">if</span>(iterFVTS2-&gt;first==iterF-&gt;second[<span class="number">0</span>])&#123;</span><br><span class="line">                                <span class="comment">//B-&gt;A...，将A的FirstVT集合合并到B的FirstVT集合</span></span><br><span class="line">                                iterFVTS1-&gt;second.insert(iterFVTS2-&gt;second.begin(),iterFVTS2-&gt;second.end());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果任意非终结符号的FirstVT集合有扩充，更改循环标志位</span></span><br><span class="line">                            <span class="comment">//false代表需要进行下一轮的构造</span></span><br><span class="line">                            <span class="keyword">if</span>(len!=iterFVTS1-&gt;second.size())&#123;</span><br><span class="line">                                ifFindAll=<span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造算符优先关系矩阵时，按照定义的四个入口进行构造即可。需要注意的是，要对新添规则进行构造：</p><pre><code>E&#39; -&gt; 井E井</code></pre><p>同时也要在终结符号集合中手动添加井。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOPGMatrix</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化OPG优先关系矩阵，填上表头</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;VN.size()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;VT.size()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            opgMatrix[i][j]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator iVT=VT.begin(); iVT!=VT.end(); ++iVT) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch=*iVT;</span><br><span class="line">        opgMatrix[i][<span class="number">0</span>]=ch;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator jVT=VT.begin(); jVT!=VT.end(); ++jVT) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch=*jVT;</span><br><span class="line">        opgMatrix[<span class="number">0</span>][j]=ch;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//四个入口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt;::iterator iter=Sentence.begin();iter!=Sentence.end();iter++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;iter-&gt;second.length()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isCaptain(iter-&gt;second[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isCaptain(iter-&gt;second[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="comment">//入口1</span></span><br><span class="line">                    <span class="comment">//X(i) 和 X(i+1) 均为终结符)</span></span><br><span class="line">                    <span class="comment">//X(i) = X(i+1)</span></span><br><span class="line">                    OPGMatrixInsert(iter-&gt;second[i],iter-&gt;second[i+<span class="number">1</span>],<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;iter-&gt;second.length()<span class="number">-2</span>&amp;&amp;!isCaptain(iter-&gt;second[i+<span class="number">2</span>]))&#123;</span><br><span class="line">                        <span class="comment">//入口2</span></span><br><span class="line">                        <span class="comment">//i &lt;= n-2 &amp;&amp; X(i) 和X(i+2)均为终结符 &amp;&amp; X(i+1) 为非终结符</span></span><br><span class="line">                        <span class="comment">//X(i) = X(i+2)</span></span><br><span class="line">                        OPGMatrixInsert(iter-&gt;second[i],iter-&gt;second[i+<span class="number">2</span>],<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt;::iterator iter_aA=FirstVTSet.begin();iter_aA!=FirstVTSet.end();iter_aA++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(iter-&gt;second[i+<span class="number">1</span>]==iter_aA-&gt;first)&#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator ins=iter_aA-&gt;second.begin();ins!=iter_aA-&gt;second.end();ins++)&#123;</span><br><span class="line">                                    <span class="comment">//入口3</span></span><br><span class="line">                                    <span class="comment">//X(i) 为终结符 &amp;&amp; X(i+1)为非终结符</span></span><br><span class="line">                                    <span class="comment">//Xi &lt; a</span></span><br><span class="line">                                    OPGMatrixInsert(iter-&gt;second[i],*ins,<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isCaptain(iter-&gt;second[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt;::iterator iter_Aa=LastVTSet.begin();iter_Aa!=LastVTSet.end();iter_Aa++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(iter-&gt;second[i]==iter_Aa-&gt;first)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator ins=iter_Aa-&gt;second.begin();ins!=iter_Aa-&gt;second.end();ins++)&#123;</span><br><span class="line">                                <span class="comment">//入口4</span></span><br><span class="line">                                <span class="comment">//X(i) 为非终结符 &amp;&amp; X(i+1)为终结符</span></span><br><span class="line">                                <span class="comment">//a &gt; X(i+1)</span></span><br><span class="line">                                OPGMatrixInsert(*ins,iter-&gt;second[i+<span class="number">1</span>],<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单独对#做处理:E&#x27;-&gt;#E#</span></span><br><span class="line">    <span class="comment">// # &lt; FirstVT(E)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt;::iterator iter_aA=FirstVTSet.begin();iter_aA!=FirstVTSet.end();iter_aA++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Begin==iter_aA-&gt;first)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator ins=iter_aA-&gt;second.begin();ins!=iter_aA-&gt;second.end();ins++)&#123;</span><br><span class="line">                OPGMatrixInsert(<span class="string">&#x27;#&#x27;</span>,*ins,<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LastVT(E) &gt; #</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt;::iterator iter_Aa=LastVTSet.begin();iter_Aa!=LastVTSet.end();iter_Aa++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Begin==iter_Aa-&gt;first)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;::iterator ins=iter_Aa-&gt;second.begin();ins!=iter_Aa-&gt;second.end();ins++)&#123;</span><br><span class="line">                OPGMatrixInsert(*ins,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//#和#的关系为ACC</span></span><br><span class="line">    OPGMatrixInsert(<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，算符优先分析算法<strong>完全按照上面的流程图</strong>进行构造。不再赘述。 </p><h2 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h2><p>首先依据所给文法写出一正确的语句：</p><pre><code>var_a+var_b*(var_c-var_d)/(var_e-(var_f-var_g+var_h))+var_i</code></pre><p>将此表达式写入专题1中的SourceProgram.txt文件，运行专题1程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/3.png" alt="图3" title="Optional title"></p><p>查看标识符文件Identifier.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/4.png" alt="图4" title="Optional title"></p><p>查看词素二元组文件ResultofLexicalAnalysis.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/5.png" alt="图5" title="Optional title"></p><p>可以看到对于专题1来说，上述语句是符合要求的。</p><p>接下来运行本专题的算符优先分析程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/6.png" alt="图6" title="Optional title"><br><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/7.png" alt="图7" title="Optional title"></p><p>查看生成的算符优先文法矩阵文件OPGMatrix.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/8.png" alt="图8" title="Optional title"></p><p>上述测试结果证明了两个程序可按设计本意顺利完成各项功能。</p><p>接下来，修改我们所给出的正确的语句，使它变得”错误”。当然这里所说的错误指的是在本专题的情景下是错误的。<strong>这些语句无论如何修改，都必须符合专题1的情景。</strong></p><ul><li>var_a <strong>=</strong> var_b*(var_c-var_d)/(var_e-(var_f-var_g+var_h))+var_i</li></ul><p>标示出来的是我们添加的错误。</p><p>对如上情形进行测试：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/9.png" alt="图9" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4/10.png" alt="图10" title="Optional title"></p><p>根据上述结果可以看出，本程序可以实现所给算符优先文法的分析，并能指出具体错误的位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;今天是个更博的好日子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理：LL(1)语法分析</title>
    <link href="http://example.com/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9ALL(1)%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2019/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9ALL(1)%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2019-05-20T09:58:07.000Z</published>
    <updated>2020-09-10T08:27:49.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><hr><h1 id="目标任务"><a href="#目标任务" class="headerlink" title="目标任务"></a>目标任务</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>完成以下描述赋值语句的 LL(1)文法的 LL(1)分析过程。</p><p>G[A]: S-&gt;V=E<br>E-&gt;TE’<br>E’-&gt;ATE’|ε<br>T-&gt;FT’<br>T’-&gt;MFT’|ε<br>F-&gt; (E)|i<br>A-&gt;+|-<br>M-&gt;*|/<br>V-&gt;i</p><h2 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h2><p>终结符号i为用户定义的简单变量，即标识符的定义。</p><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><ul><li><p>(1)输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果。输出为输入串是否为该文法定义的算术表达式的判断结果;</p></li><li><p>(2)LL(1)分析过程应能发现输入串出错;</p></li><li><p>(3)设计两个测试用例(尽可能完备，正确和出错)，并给出测试结果;</p></li><li><p>(4)考虑根据LL(1)文法编写程序构造LL(1)分析表，并添加到你的LL(1)分析程序中。</p></li></ul><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="LL-1-分析"><a href="#LL-1-分析" class="headerlink" title="LL(1)分析"></a>LL(1)分析</h2><p>专题2中要求我们实现递归下降语法分析。在实践过程中，可以发现：这种带回溯的自顶向下的分析方法实际上是一种穷举的不断试探的过程，分析效率极低。</p><p>实际上，递归下降分析在实际的编译程序中极少使用。</p><p>相较于递归下降分析，LL(1)分析法又称预测分析法，是一种不带回溯的非递归自顶向下分析方法。LL(1)的含义是：第一个L表明自顶向下分析是从左向右扫描输入串，第2个L表明分析过程中将使用最左推导，1表明只需向右看一个符号便可决定如何推导，即选择哪个产生式(规则)进行推导。</p><p>该方法的显著特点是使用<strong>显式栈</strong>，该算法在本质上就是<strong>用栈来显式地实现非递归版本的递归下降分析</strong>，或者说非递归版本的树的遍历的一个过程。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>递归下降分析器的构造方法同样非常简单，就是为每一个非终结符寻找到FIRST集合和FOLLOW集合，并由这两个集合构造LL(1)分析表，最后根据分析表进行对指定的句子打印出分析栈的分析过程。</p><p>需要注意的是，在进行递归下降分析之前需要对不是LL(1)的文法进行处理。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/1.png" alt="图1" title="Optional title"></p><h2 id="左递归的消除"><a href="#左递归的消除" class="headerlink" title="左递归的消除"></a>左递归的消除</h2><p>由于所给的文法为标准的LL（1）文法，这一步可省略。</p><h2 id="FIRST集合"><a href="#FIRST集合" class="headerlink" title="FIRST集合"></a>FIRST集合</h2><p>FIRST(A)集合是非终结符号A的所有可能推导出的开头终结符或ε组成的集合。称FIRST(A)为A的开始符号集或首符号集。</p><p>对于大部分文法而言，存在一个产生式存在多个候选式的情况，而选择哪一个候选式是不确定的，所以这就产生了回溯。回溯需要消耗大量的计算、存储空间，所以我们需要消除回溯。而消除回溯的其中一种方法叫作“预测”，即根据栈顶非终结符去预测后面的候选式，那预测方法就是求第一个非终结符，来判断是否和读头匹配，以达到预测的效果。</p><p>计算FIRST集合需要经过以下步骤：</p><ul><li><p>（1）若X ∈ VT，则FIRST(X) = {X}；<br>【终结符自己就是自己的FIRST集合】</p></li><li><p>（2）若X ∈ VN，且有产生式X -&gt; a……， a ∈ VT，则a ∈ FIRST(X)；<br>【非终结符，选第一个终结符加入】</p></li><li><p>（3）若X ∈ VN，X -&gt; ε，则 ε ∈ FIRST(X)；<br>【能直接推出ε，ε加入FIRST】</p></li><li><p>（4）若X,Y1,Y2,……,Yn ∈ VN，而有产生式X -&gt; Y1,Y2,……,Yn。当Y1,Y2,……,Y(i-1)直接推出ε时，则FIRST(Y1) - ε, FIRST(Y2) - ε, …… , FIRST(Y(i-1) - ε) ,FIRST(Yi) 都包含在FIRST(X)中；<br>【位于中间的ε是不可加入进去】</p></li><li><p>（5）当（4）中所有Yi 都推出 ε时，则最后的FIRST(X) = FIRST(Y1) ∪ FIRST(Y2) ∪ …… ∪ FIRST(Yn) ∪ {ε}；</p></li></ul><p>反复运用（2）-（5）步骤，直到每个符号的FIRST集合不再增大为止。</p><p>对本专题所给的文法求FIRST集合的过程如下：<br>【1】First(S) = First(V) = First(i) = {i}<br>【2】First(E) = First(T) = First(F) = First(() + First(i) = {(,i}<br>【3】First(R) = First(A) + First(ε) = First(+) + First(-) + First(ε) = {+,-,井}<br>【4】First(T) = First(F) = First(() + First(i) = {(,i}<br>【5】First(Y) = First(M) + First(ε) = First(*) + First( + First(ε) = First(*) + ) + First(ε) = {*,/,井}<br>【6】First(F) = First(() + First(i) = {(,i}<br>【7】First(A) = First(+) + First(-) = {+,-}<br>【8】First(M) = First(*) + First( = First(*) + ) = {*,/}<br>【9】First(V) = First(i) = {i}</p><p>注：为了方便代码的编写，对文法做如下字符的替换（之后所有用到如下规则的地方都做此替换，不再赘述）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E’ -&gt; R</span><br><span class="line">T’ -&gt; Y</span><br></pre></td></tr></table></figure><h2 id="FOLLOW集合"><a href="#FOLLOW集合" class="headerlink" title="FOLLOW集合"></a>FOLLOW集合</h2><p>FOLLOW(A)集合是所有紧跟A之后的终结符或#所组成的集合（#是句尾的标志），称FOLLOW(A)是A的随符集。</p><p>当某一非终结符的产生式中含有空产生式时，它的非空产生式右部的开始符号集两两不相交，并与在推导过程中紧跟该非终结符右部可能出现的终结符集也不相交，则仍可构造确定的自顶向下分析。因此，引入了文法符号的后跟符号集合FOLLOW。</p><p>计算FOLLOW集合需要经过以下步骤：</p><p>（1）对S，将井加入 FOLLOW(S)，然后再按后面的处理；</p><p>（2）若B -&gt; aAb是G的产生式，则将FIRST(β)-ε加入FOLLOW(A)；</p><p>（3）若B -&gt; aA是G的产生式，或B -&gt; aAb是G的产生式（b 多次推导后得到ε ），则将FOLLOW(B) 加入到FOLLOW(A) 。<br>【将B用aA替换之后，B后面紧跟的字符就是A后面紧跟的字符】</p><p>反复使用（2）-（3）步骤，直到FOLLOW集合不再增大为止</p><p>对本专题所给的文法求FIRST集合的过程如下：<br>【1】Follow(S): S-&gt;S = {井}<br>【2】Follow(E): S-&gt;V=E、S-&gt;(E) = {井,)}<br>【3】Follow(R): S-&gt;TR、S-&gt;(E)-&gt;(R) = {井,)}<br>【4】Follow(T): S-&gt;TR-&gt;T+、S-&gt;TR-&gt;T-、S-&gt;TR-&gt;Tε、S-&gt;(E)-&gt;(T) = {+,-,井,)}<br>【5】Follow(Y): S-&gt;TR-&gt;FYR-&gt;Y+、S-&gt;TR-&gt;FYR-&gt;Y-、S-&gt;FY、S-&gt;(E)-&gt;(Y) = {+,-,井,)}<br>【6】Follow(F): S-&gt;FY-&gt;F*、S-&gt;FY-&gt;F/、S-&gt;FY-&gt;Fε、S-&gt;TR-&gt;F+、S-&gt;TR-&gt;F-、S-&gt;(E)-&gt;(F) = {*,/,井,+,-,)}<br>【7】Follow(A): S-&gt;ATR-&gt;A(R、S-&gt;ATR-&gt;AiR = {(,i}<br>【8】Follow(M): S-&gt;MFY-&gt;M(Y、S-&gt;MFY-&gt;MiY = {(,i}<br>【9】Follow(V): S-&gt;V=E = {=}</p><h2 id="根据FIRST集合和FOLLOW集合构造LL-1-分析表"><a href="#根据FIRST集合和FOLLOW集合构造LL-1-分析表" class="headerlink" title="根据FIRST集合和FOLLOW集合构造LL(1)分析表"></a>根据FIRST集合和FOLLOW集合构造LL(1)分析表</h2><p>设M[A][a]是一个二维数组，其中行A表示的是栈顶符号，a表示的读头下的符号（A为非终结符，a为终结符），它们存放的是当前状态下所使用的候选式（或存放出错标志，指出A不该面临a的输入），称该数组M为文法的LL(1)分析表。</p><p>为了消除回溯，我们进行了FIRST集合和FOLLOW集合的求解。它们两个组合，达到了预测候选式的目的。为了使计算机比较好处理，把它们的预测结果统计成一张二维表。</p><p>构造LL(1)分析表需要经过如下步骤：</p><ul><li><p>（1）对任意终结符号a ∈First(A)，将 A -&gt; a 填入M[A,a]；</p></li><li><p>（2）如果存在ε ∈First(A)，则对任意终结符号a ∈Follow(A)，将 A -&gt; a 填入M[A,a]；</p></li><li><p>（3）将所有没有定义的M[A,b]设置为出错。</p></li></ul><p>对本专题所给的文法构造LL(1)分析表如下：</p><table><thead><tr><th align="center"></th><th align="center">#</th><th align="center">(</th><th align="center">)</th><th align="center">*</th><th align="center">+</th><th align="center">-</th><th align="center">/</th><th align="center">=</th><th align="center">i</th></tr></thead><tbody><tr><td align="center">A</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">-</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">E</td><td align="center"></td><td align="center">TR</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">TR</td></tr><tr><td align="center">F</td><td align="center"></td><td align="center">(E)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">i</td></tr><tr><td align="center">M</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">*</td><td align="center"></td><td align="center"></td><td align="center">/</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">R</td><td align="center">ε</td><td align="center"></td><td align="center">ε</td><td align="center"></td><td align="center">ATR</td><td align="center">ATR</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">S</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">V=E</td></tr><tr><td align="center">T</td><td align="center"></td><td align="center">FY</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">FY</td></tr><tr><td align="center">V</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Y</td><td align="center">ε</td><td align="center"></td><td align="center">ε</td><td align="center">MFY</td><td align="center">ε</td><td align="center">ε</td><td align="center">MFY</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>该分析表中未填入内容的位置则表示该位置的非终结符号无法预测后跟该位置的终结符号。如果匹配到这样的位置，则证明表达式出错。</p><h2 id="根据LL-1-分析表进行预测分析"><a href="#根据LL-1-分析表进行预测分析" class="headerlink" title="根据LL(1)分析表进行预测分析"></a>根据LL(1)分析表进行预测分析</h2><p>构造好分析表之后，便可根据分析表进行预测分析。</p><p>流程如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/2.png" alt="图2" title="Optional title"></p><h2 id="文件结构及函数简介"><a href="#文件结构及函数简介" class="headerlink" title="文件结构及函数简介"></a>文件结构及函数简介</h2><p>本专题大部分文件和功能函数与专题1同名，具体的文件结构和功能函数简介见《编译原理：词法分析程序》。</p><p>新增文件FirstAndFollow.h，内含的函数用作预测分析的准备工作，即求文法的First集合、求文法的Follow集合和构造分析表。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>详细的主函数流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    initAll();</span><br><span class="line">    <span class="comment">//读取lab1中输出的二元组结果文件</span></span><br><span class="line">    readFile_Result();</span><br><span class="line">    <span class="comment">//读取lab1中输出的标识符结果文件</span></span><br><span class="line">    readFile_Identifier();</span><br><span class="line">    <span class="comment">//过滤读取结果，得到纯粹的标识符内容</span></span><br><span class="line">    getPureMorphemeAndSentence();</span><br><span class="line">    <span class="comment">//输出过滤后的语句</span></span><br><span class="line">    printSentenceInfo();</span><br><span class="line">    <span class="comment">//读取经过处理的LL(1)文法，求得包含所有的非终结符号的不重复集合</span></span><br><span class="line">    readFile_Formula();</span><br><span class="line">    <span class="comment">//求得文法的first集合和follow集合以及由此构造分析表，并写入txt文件中</span></span><br><span class="line">    getFirstAndFollow();</span><br><span class="line">    <span class="comment">//求得包含所有的终结符号的不重复集合</span></span><br><span class="line">    getAllVT();</span><br><span class="line">    <span class="comment">//根据first集合和follow集合求得该文法的LL(1)分析表</span></span><br><span class="line">    getAnalyseTable();</span><br><span class="line">    <span class="comment">//进行预测分析</span></span><br><span class="line">    <span class="keyword">if</span>(getAnalyseResult())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配成功!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//匹配成功，输出分析栈结果</span></span><br><span class="line">        printAnalyseResultInfo();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//匹配失败，输出错误位置信息</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配失败!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        printError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本专题要求的输入是专题1输出的词素结果二元组和标识符信息，读取函数介绍见《编译原理：递归下降分析》。</p><p>本次分析需要操作各种符号进行匹配比对，所以使用最多的操作就是查找和字符比较。为此，设置以下结构来存储该过程中的数据。使用C++ STL的原因是如map等的结构自带排序，且键值对的存储方式对于遍历操作十分友好；再如string，自带字符串比较函数compare，对于匹配操作也很友好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生式</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; Sentence;</span><br><span class="line"><span class="comment">//产生式反向</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="keyword">char</span>&gt; ReverseSentence;</span><br><span class="line"><span class="comment">//非终结符集合</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; VN;</span><br><span class="line"><span class="comment">//终结符集合</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; VT;</span><br><span class="line"><span class="comment">//读取产生式的等号左部内容，一般都是单字符，所以用char</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; Left;</span><br><span class="line"><span class="comment">//读取产生式的等号右部内容，长度不定，使用string</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Right;</span><br><span class="line"><span class="comment">//非终结符能否推出空</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; VtToEmpty;</span><br><span class="line"><span class="comment">//求First和Follow集合是否成功的标志</span></span><br><span class="line"><span class="keyword">bool</span> IfFirstOrFollowSuccess;</span><br><span class="line"><span class="comment">//First集合，char对应的是每个非终结符号，set&lt;char&gt;对应每个非终结符号的每个First集合中的内容</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt; FirstSet;</span><br><span class="line"><span class="comment">//Follow集合，解释同上</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt; FollowSet;</span><br><span class="line"><span class="comment">//文法的开始符号</span></span><br><span class="line"><span class="keyword">char</span> Begin;</span><br><span class="line"><span class="comment">//LL(1)分析表</span></span><br><span class="line"><span class="built_in">string</span> AnalyseTable[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="comment">//分析过程四元组</span></span><br><span class="line"><span class="built_in">string</span> AnalyseProcess[<span class="number">100</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//分析步骤计数</span></span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line"><span class="comment">//分析栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; AnalyseStack;</span><br></pre></td></tr></table></figure><p>对于first集合和follow集合，根据上面介绍的方法进行循环求解即可。需要注意的是要设置跳出的条件：当某一轮循环之后的集合大小与内容和上一轮循环无变化，则表明寻找完成，需要跳出。</p><p>根据first集合和follow集合构造分析表时需要注意的是，对于非终结符号X直接推导为单个终结符号a的情况，有两种处理情况：当该非终结符号仅有一种推导出单终结符号的情况，M[X,a]可写作{a}；当该非终结符号有多于一种的推导出单终结符号的情况（设所有情况为a1……ai），可按照每个终结符号的具体情况去设置，即<strong>M[X,ai]={ai}**，这种做法与第一种情况相同，或者使用另一个符号b去替代所有情况，即</strong>M[X,ai]={b}，这种做法需要将该非终结符号能产生的在所给语句中的所有非终结符号替换为b**。本专题中仅出现了第一种情况，故按照第一种情况去处理即可。</p><p>预测分析程序的流程见上面的流程图，具体代码及注释如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getAnalyseResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//#入栈</span></span><br><span class="line">    AnalyseStack.push(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">    <span class="comment">//开始符号入栈</span></span><br><span class="line">    <span class="built_in">string</span> temp=&amp;Begin;</span><br><span class="line">    AnalyseStack.push(temp);</span><br><span class="line">    <span class="comment">//存储当前语句匹配位置的非终结符号，同a</span></span><br><span class="line">    <span class="built_in">string</span> pFormula=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//存储当前栈顶</span></span><br><span class="line">    <span class="built_in">string</span> X=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">//写入分析过程</span></span><br><span class="line">        AnalyseProcess[step][<span class="number">0</span>]=to_string(step+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> stackSize=AnalyseStack.size();</span><br><span class="line">        <span class="built_in">string</span> stackTemp[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stackSize;i++)&#123;</span><br><span class="line">            stackTemp[i]=AnalyseStack.top();</span><br><span class="line">            AnalyseStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=stackSize<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            AnalyseStack.push(stackTemp[i]);</span><br><span class="line">            AnalyseProcess[step][<span class="number">1</span>]+=stackTemp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//X记录当前栈顶</span></span><br><span class="line">        X=AnalyseStack.top();</span><br><span class="line">        <span class="comment">//pFormula记录语句当前匹配位置的内容</span></span><br><span class="line">        <span class="keyword">if</span>(matchIdentifier())&#123;</span><br><span class="line">            pFormula=<span class="string">&quot;i&quot;</span>;</span><br><span class="line">            pMorpheme-=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pFormula=morpheme[pMorpheme];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入分析过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=pMorpheme;k&lt;morphemeCounter;k++)&#123;</span><br><span class="line">            AnalyseProcess[step][<span class="number">2</span>]+=morpheme[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//X是终结符号？</span></span><br><span class="line">        <span class="keyword">if</span>(matchVT(X))&#123;</span><br><span class="line">            <span class="comment">//X=pFormula</span></span><br><span class="line">            <span class="comment">//X==#？</span></span><br><span class="line">            <span class="keyword">if</span>(!X.compare(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//X=#</span></span><br><span class="line">                <span class="comment">//X==pFormula？</span></span><br><span class="line">                <span class="keyword">if</span>(!X.compare(pFormula))&#123;</span><br><span class="line">                    <span class="comment">//X=pFormula</span></span><br><span class="line">                    <span class="comment">//写入分析过程</span></span><br><span class="line">                    AnalyseProcess[step][<span class="number">3</span>]+=<span class="string">&quot;Success&quot;</span>;</span><br><span class="line">                    step+=<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//分析成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//X!=pFormula</span></span><br><span class="line">                    <span class="comment">//分析失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//X==pFormula？</span></span><br><span class="line">            <span class="keyword">if</span>(!X.compare(pFormula))&#123;</span><br><span class="line">                <span class="comment">//X=pFormula,当前符号匹配成功，记录步数</span></span><br><span class="line">                step+=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//栈顶符号出栈</span></span><br><span class="line">                AnalyseStack.pop();</span><br><span class="line">                <span class="comment">//当前匹配语句指针后移</span></span><br><span class="line">                pMorpheme+=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//继续分析</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//分析失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//M[X,a]有产生式？</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ifHasFormula(X, pFormula))&#123;</span><br><span class="line">            <span class="comment">//M[X,a]有产生式，查询并取出内容</span></span><br><span class="line">            <span class="built_in">string</span> f=getFormula(X, pFormula);</span><br><span class="line">            <span class="comment">//栈顶符号出栈</span></span><br><span class="line">            AnalyseStack.pop();</span><br><span class="line">            <span class="comment">//写入分析过程</span></span><br><span class="line">            AnalyseProcess[step][<span class="number">3</span>]+=X+<span class="string">&quot;-&gt;&quot;</span>+f;</span><br><span class="line">            <span class="comment">//将M[X,a]的内容反序入栈</span></span><br><span class="line">            <span class="keyword">if</span>(!f.compare(<span class="string">&quot;ε&quot;</span>))&#123;</span><br><span class="line">                step+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=f.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">char</span> ff=f[i];</span><br><span class="line">                <span class="built_in">string</span> fff=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                fff+=ff;</span><br><span class="line">                AnalyseStack.push(fff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录步数</span></span><br><span class="line">            step+=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//继续分析</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//分析失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h2><p>首先依据所给文法写出一正确的语句：</p><pre><code>var_a=((var_b+var_c*var_d)/(var_e-var_f/var_g))/var_i</code></pre><p>将此表达式写入专题1中的SourceProgram.txt文件，运行专题1程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/3.png" alt="图3" title="Optional title"></p><p>查看标识符文件Identifier.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/4.png" alt="图4" title="Optional title"></p><p>查看词素二元组文件ResultofLexicalAnalysis.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/5.png" alt="图5" title="Optional title"></p><p>可以看到对于专题1来说，上述语句是符合要求的。</p><p>接下来运行本专题的LL(1)程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/6.png" alt="图6" title="Optional title"><br><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/7.png" alt="图7" title="Optional title"></p><p>上述测试结果证明了两个程序可按设计本意顺利完成各项功能。</p><p>对于本专题来说，还有一个重要的功能是FIRST集合和FOLLOW集合的求解以及分析表的构造。对于此功能，文法输入文件为Formula.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/8.png" alt="图8" title="Optional title"></p><p>该文法输入文件的格式是：产生式的左右部以单空格区分；每一行仅含有一个单产生式；每一个字符代表一个终结符号或非终结符号，无双字符符号；将所有的大写字母看作是非终结符号，除此之外的所有符号看作终结符号；以“$”标志文件结束。</p><p>所求得的FIRST集合和FOLLOW集合输出到FirstAndFollow.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/9.png" alt="图9" title="Optional title"></p><p>构造好的分析表输出到AnalyseTable.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/10.png" alt="图10" title="Optional title"></p><p>综上，该程序的输入有二：一是专题1所输出的二元组文件，另一是经过手工处理的LL(1)文法内容文件。而输出有三：一是控制台输出分析结果：成功匹配则输出分析过程，失败匹配则输出出错位置；另一是输出所求得的FIRST集合和FOLLOW集合；再一是输出所构造的分析表。</p><p>接下来，修改我们所给出的正确的语句，使它变得”错误”。当然这里所说的错误指的是在本专题的情景下是错误的。这些语句无论如何修改，都必须符合专题1的情景。</p><ul><li><p>(1)var_a+var_error=((var_b+var_c*var_d)/(var_e-var_f/var_g))/var_i</p></li><li><p>(2)var_a==((var_b+var_c*var_d)/(var_e-var_f/var_g))/var_i</p></li><li><p>(3)var_a=((var_b+var_c*var_d)=(var_e-var_f/var_g))/var_i</p></li></ul><p>标示出来的是我们添加的错误。</p><p>分别对如上情形进行测试：</p><ul><li>（1）:</li></ul><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/11.png" alt="图11" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/12.png" alt="图12" title="Optional title"></p><ul><li>（2）:</li></ul><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/13.png" alt="图13" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/14.png" alt="图14" title="Optional title"></p><ul><li>（3）:</li></ul><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/15.png" alt="图15" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3/16.png" alt="图16" title="Optional title"></p><p>根据上述结果可以看出，本程序可以实现所给LL（1）文法的LL(1)语法分析，并能指出具体错误的位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;目标任务&quot;&gt;&lt;a href=&quot;#目标任务&quot; class=&quot;headerlink&quot; title=&quot;目标任务&quot;&gt;&lt;/a&gt;目标任务&lt;/h1&gt;&lt;h2 id=&quot;要</summary>
      
    
    
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统四：页面置换算法</title>
    <link href="http://example.com/2019/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2019/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</id>
    <published>2019-05-17T07:22:51.000Z</published>
    <updated>2019-05-24T09:34:54.896Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！<br>代码、文章及图片挂载地址：<a href="https://github.com/MoyangSensei/OS">https://github.com/MoyangSensei/OS</a></p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>最佳置换算法、先进先出置换算法、最近最久未使用置换算法、改进型CLOCK置换算法、页面缓冲置换算法</p><h2 id="符合局部访问特性的随机生成算法"><a href="#符合局部访问特性的随机生成算法" class="headerlink" title="符合局部访问特性的随机生成算法"></a>符合局部访问特性的随机生成算法</h2><p>（1）确定虚拟内存的尺寸N，工作集的起始位置p，工作集中包含的页数e，工作集移动率m（每处理m个页面访问则将起始位置p +1），以及一个范围在0和1之间的值t；</p><p>（2）生成m个取值范围在p和p + e间的随机数，并记录到页面访问序列串中；</p><p>（3）生成一个随机数r，0 ≤ r ≤ 1；</p><p>（4）如果r &lt; t，则为p生成一个新值，否则p = (p + 1) mod N；</p><p>（5）如果想继续加大页面访问序列串的长度，请返回第2步，否则结束。</p><h2 id="性能评测"><a href="#性能评测" class="headerlink" title="性能评测"></a>性能评测</h2><p>（1）测试不同的页面访问序列及不同的虚拟内存尺寸，并从缺页率、算法开销等方面对各个算法进行比较。</p><p>（2）给出在给定页面访问序列的情况下，发生页面置换次数的平均值</p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="页面置换算法-1"><a href="#页面置换算法-1" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><h2 id="前提及定义"><a href="#前提及定义" class="headerlink" title="前提及定义"></a>前提及定义</h2><p>由于在不同的操作系统和不同的情况下，页面置换算法的实现方式和效率是有一定出入的，因此先要对该过程的前提做规定和解释，以及对一些特定的变量作出说明。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li><p>对于给定的页面序列，程序或功能将严格按照这个顺序进行访问，不会出现提前访问、越界访问情况；</p></li><li><p>对于给定的页面序列，每个页面的大小一定不会超过虚拟内存的大小；</p></li><li><p>对于PBA算法，需要另外给定空闲物理块数量，该数量不可超过工作物理块数量；</p></li><li><p>对于所有算法的页面填充过程，将新到来的页面填充到空白的工作物理块中，同样算作缺页。</p></li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>对于各算法都通用的变量，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024</span></span><br><span class="line"><span class="comment">//页面序列总长度、工作集的起始位置p、物理块个数</span></span><br><span class="line"><span class="keyword">int</span> pageNum=<span class="number">0</span>,pageStart=<span class="number">0</span>,blockNum=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//物理块状态数组</span></span><br><span class="line"><span class="keyword">int</span> **blockSta;</span><br><span class="line"><span class="comment">//页面序列数组</span></span><br><span class="line"><span class="keyword">int</span> *page;</span><br><span class="line"><span class="comment">//页面序列指针</span></span><br><span class="line"><span class="keyword">int</span> pPage;</span><br><span class="line"><span class="comment">//缺页中断数组</span></span><br><span class="line"><span class="keyword">char</span> *interrupt;</span><br><span class="line"><span class="comment">//缺页数量</span></span><br><span class="line"><span class="keyword">int</span> lakePage;</span><br><span class="line"><span class="comment">//虚拟内存N</span></span><br><span class="line"><span class="keyword">int</span> memory;</span><br><span class="line"><span class="comment">//工作集中包含的页数e</span></span><br><span class="line"><span class="keyword">int</span> everyWorkSet;</span><br><span class="line"><span class="comment">//工作集移动率m</span></span><br><span class="line"><span class="keyword">int</span> moveRate;</span><br></pre></td></tr></table></figure></li><li><p>对于最近最久未使用置换算法（LRU）来说，需要维护一个特定的栈，该栈的功能是：当前栈顶的页面就是最长时间没有被调用过的页面。<br>该模拟栈以数组实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自写栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAX];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li><li><p>栈的功能以函数形式定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数组中是否已有x，若有返回其下标值，没有则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(x==a[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈法插入(第一个元素出，后面元素前移，新元素从尾部入)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> m=a[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">        a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于改进型CLOCK算法来说，需要维护使用位、修改位以及生成随机的修改序列。<br>使用位、修改位定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用位</span></span><br><span class="line"><span class="keyword">bool</span> *useBit;</span><br><span class="line"><span class="comment">//修改位</span></span><br><span class="line"><span class="keyword">bool</span> *modifiedBit;</span><br><span class="line"><span class="comment">//修改页面序列</span></span><br><span class="line"><span class="keyword">bool</span> *modifiedPage;</span><br></pre></td></tr></table></figure></li><li><p>函数getRandomModifiedPage用来生成随机的修改页面序列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRandomModifiedPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//设置修改页面数量占页面总数量的比重</span></span><br><span class="line">    <span class="comment">//此处默认为0.3</span></span><br><span class="line">    <span class="keyword">double</span> modifiedRate=<span class="number">0.3</span>;</span><br><span class="line">    <span class="keyword">int</span> modifiedPageNum=<span class="built_in">ceil</span>(pageNum*modifiedRate);</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    a=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*modifiedPageNum);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//随机编号为0到pageNum-1的页面序列编号中生成modifiedPageNum个修改页面</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t==modifiedPageNum)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> RandNum = (rand()%(pageNum<span class="number">-0</span>))+<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == RandNum)</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag != <span class="number">1</span>)&#123;</span><br><span class="line">            a[t] = RandNum;</span><br><span class="line">            modifiedPage[a[t]]=<span class="literal">true</span>;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于页面缓冲置换算法（LRU）来说，需要维护空闲物理块。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空闲物理块数量</span></span><br><span class="line"><span class="keyword">int</span> freeBlock;</span><br><span class="line"><span class="comment">//空闲物理块状态数组</span></span><br><span class="line"><span class="keyword">int</span> **freeBlockSta;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>最佳置换算法（OPT）是一种<em>理想情况</em>下的页面置换算法，但实际上是<strong>不可能实现</strong>的。</p><p>该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到10、100或者1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数进行标记。</p><p>最佳页面置换算法只是简单地规定：标记最大的页应该被置换。这个算法唯一的一个问题就是它无法实现。当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。对于我们的实验而言，由于我们给定了将要访问的页面的顺序序列，就相当于正确“预言”了接下来将要访问的页面，才能将这个算法实现出来。</p><p>虽然这个算法在实际情况不可能实现，但是<strong>最佳页面置换算法可以用于对可实现算法的性能进行衡量比较</strong>。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/1.png" alt="最佳页面置换算法流程" title="Optional title"></p><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void OPT()**用来实现最佳置换算法的流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的缺页补全，替换块指针不动（填充完后又回到第一个位置）</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            <span class="comment">//nearPage：记录最近要被调用的位置</span></span><br><span class="line">            <span class="keyword">int</span> *nearPage;</span><br><span class="line">            <span class="comment">//ifFindNearPage：记录从该页面的下一个页面起到序列结束，是否有当前页面的调用</span></span><br><span class="line">            <span class="keyword">bool</span> *ifFindNearPage;</span><br><span class="line">            nearPage=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(blockNum*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">            ifFindNearPage=(<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(blockNum*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">            <span class="comment">//向着页面序列结束的方向寻找当前物理块每一个内容最近要被调用的位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                nearPage[j]=<span class="number">-1</span>;</span><br><span class="line">                ifFindNearPage[j]=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;pageNum;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(blockSta[j][i]==page[k])&#123;</span><br><span class="line">                        nearPage[j]=k;</span><br><span class="line">                        <span class="comment">//找到调用：记录调用位置</span></span><br><span class="line">                        ifFindNearPage[j]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//直到序列结束都未找到调用：调用位置设为序列长度+1</span></span><br><span class="line">                <span class="keyword">if</span>(!ifFindNearPage[j])&#123;</span><br><span class="line">                    nearPage[j]=pageNum+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到最远调用的物理块</span></span><br><span class="line">            <span class="keyword">int</span> farPageNum=<span class="number">0</span>,farPage=nearPage[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(farPage&lt;nearPage[j])&#123;</span><br><span class="line">                    farPage=nearPage[j];</span><br><span class="line">                    farPageNum=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换最远调用物理块中的内容为当前页面</span></span><br><span class="line">            blockSta[farPageNum][i]=page[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="物理块的填充"><a href="#物理块的填充" class="headerlink" title="物理块的填充"></a>物理块的填充</h2><p>对于上述算法来说，在第8行调用了一个名为fillFront()的函数，该函数的功能是将物理块从<strong>全部空白填充至刚好所有物理块中都有不一样的内容</strong>。</p><p>实际上，这个过程是非常容易想到的，即一旦遇到新的页面后，将它填充到空白物理块中即可。但是这里需要注意的是：<strong>对于一个拥有n个模拟物理块的页面置换流程来说，如果前n个页面都是两两不相同的页面，那么该过程刚好可以把这n个不相同的页面全部填充进去，从第n+1个页面开始进行淘汰和替换动作</strong>。</p><p>但由于我们模拟的页面序列是有局部性的，即如果不指定工作集中包含的页数e远大于工作集移动率m，这种情况几乎是很少发生的。有可能出现这样的状况：</p><table><thead><tr><th align="center">参数</th><th align="center"></th><th align="center"></th><th align="center">过程</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">页面序列</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">…</td></tr><tr><td align="center">物理块[1]</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">…</td></tr><tr><td align="center">物理块[2]</td><td align="center">-</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">…</td></tr><tr><td align="center">物理块[3]</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">3</td><td align="center">…</td></tr></tbody></table><p>上面的例子告诉我们，如果前n个页面中出现了重复，那么将这n个模拟物理块从全部空白填充至全部非空白所需要的“步数”就不是n了。且<strong>不论是什么样的页面置换算法，只有在将空白物理块全部利用之后才会去考虑淘汰和替换的问题</strong>。因此，按照这个思路考虑，我们的所有页面置换算法分为两个步骤进行：</p><p>（1）先使用一个函数来帮我们将物理块从全部空白填充至刚好所有物理块中都有不一样的内容；</p><p>（2）只对剩余的页面序列考虑淘汰和替换问题。</p><p>函数**void fillFront()**用来实现物理块填充的流程。简言之，该函数的作用是避免在此过程中的重复元素多占用物理块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillFront</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b[blockNum];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;a&lt;blockNum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            blockSta[<span class="number">0</span>][<span class="number">0</span>]=page[pPage];</span><br><span class="line">            b[a]=page[pPage];</span><br><span class="line">            a+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                blockSta[j][pPage]=blockSta[j][pPage<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> ifFindCommon=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(page[pPage]==b[j])&#123;</span><br><span class="line">                    ifFindCommon=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!ifFindCommon)&#123;</span><br><span class="line">                blockSta[a][pPage]=page[pPage];</span><br><span class="line">                b[a]=page[pPage];</span><br><span class="line">                a+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pPage+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该函数适用于FIFO、OPT、改进型CLOCK以及PBA</strong>，之后不再赘述。</p><p><strong>该函数不适用于LRU</strong>：虽然是同样的填充方法，但是LRU要从头开始维护一个特殊的栈，代表物理块中的页面是否在最近被调用过。重复页面会使得该页面在特殊的栈的“位置”变得“靠前”，而其他算法并不考虑已检索的重复页面对于整个算法流程的影响（OPT考虑的是未检索过的重复页面）。</p><p>此函数仅仅是为了方便代码的编写以及理解整个流程，模拟算法可用之。在实际情况下一定是在分配的物理块区域内按照顺序进行检索的。</p><h2 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>先进先出置换算法是实现最为简单的置换算法，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。</p><p>其基本思想是：优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。</p><p>但FIFO算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。且FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由Belady于1969年发现，故称为Belady异常。</p><p><strong>只有FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。</strong></p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/2.png" alt="先进先出置换算法流程" title="Optional title"></p><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void FIFO()**用来实现最佳置换算法的流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的缺页补全</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置替换块指针</span></span><br><span class="line">    <span class="keyword">int</span> pReplaceBlock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            <span class="comment">//将替换指针所指向的物理块进行替换</span></span><br><span class="line">            blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">            <span class="comment">//将替换指针后移</span></span><br><span class="line">            pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>在之前的FIFO算法中，依据的是各个页面调入内存的时间，这并不能反映页面的真实使用情况。</p><p>而最近最久未使用置换算法（Latest Recently Used）是根据页面调入内存之后的使用情况。由于无法预测页面未来的情况，所以只能利用“最近的过去”来作为预测未来的方法，LRU选择的是最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面从上次被访问以来所经历的时间t，当需要淘汰一个页面的时候，选择现有页面中t的值最大的页面进行淘汰。</p><p>LRU是一种优秀的页面置换算法，但是需要硬件的支持，为了了解一个进程在内存中各个页面各有多少时间未被进程访问，以及如何快速地知道哪一个页面是最近最久未使用的页面，需要寄存器或栈来支持。</p><p>（1）寄存器：为了记录某进程在内存中各页的使用情况，需要为每个在内存中的页面设置一个移位寄存器，可表示为：R=R(n-1)R(n-2)…R2R1R0,当进程访问某物理块时，要将相应寄存器的R(n-1)位置成1。此时，定时信号将每隔一定时间（例如100ms）将寄存器右移一位。如果我们把n位寄存器的数看做是一个整数，那么具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。当发生缺页时，首先将它置换出去。</p><p>（2）栈：可以利用一种特殊的栈来保存当前使用的各个页面的页面号，每当进程访问某页面的时候，便将该页面的页面号从栈中移除，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，栈底则是最近最久未访问页面的页面号，当需要置换页面的时候，将栈底对应的页面置换出来。</p><h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/3.png" alt="最近最久未使用置换算法流程" title="Optional title"></p><h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void LRU()**用来实现最佳置换算法的流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自写栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAX];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//初始化自写栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        <span class="built_in">stack</span>[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从页面序列的第一个开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//读数后top自动+1</span></span><br><span class="line">        top++;</span><br><span class="line">        <span class="comment">//栈中无元素：直接插入元素</span></span><br><span class="line">        <span class="keyword">if</span>(top==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">stack</span>[top]=page[i];</span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中元素个数小于物理块个数：不重复则直接插入、重复则更新元素在栈中位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(top&lt;blockNum)&#123;</span><br><span class="line">            <span class="comment">//栈中不存在待插入元素：新元素从尾部插入</span></span><br><span class="line">            <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,blockNum,page[i])==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">stack</span>[top]=page[i];</span><br><span class="line">                lakePage+=<span class="number">1</span>;</span><br><span class="line">                interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈中存在待插入元素：重复元素的位置置后，表示最近使用过</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                move(<span class="built_in">stack</span>,top,judge(<span class="built_in">stack</span>,blockNum,page[i]));</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中元素个数大于物理块个数：重复则更新元素在栈中位置、不重复就淘汰并替换元素</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//栈中不存在待插入元素：新元素栈法插入（淘汰替换旧元素）</span></span><br><span class="line">            <span class="comment">//栈法插入：第一个元素出，后面元素前移，新元素从尾部入</span></span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,blockNum,page[i])==<span class="number">-1</span>)&#123;</span><br><span class="line">                insert(<span class="built_in">stack</span>,blockNum,page[i]);</span><br><span class="line">                lakePage+=<span class="number">1</span>;</span><br><span class="line">                interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈中存在待插入元素：重复元素的位置置后，表示最近使用过</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                move(<span class="built_in">stack</span>,blockNum,judge(<span class="built_in">stack</span>,blockNum,page[i]));</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新物理块的变化情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>[j]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                blockSta[j][i]=<span class="built_in">stack</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进型Clock置换算法"><a href="#改进型Clock置换算法" class="headerlink" title="改进型Clock置换算法"></a>改进型Clock置换算法</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p><p>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p><ul><li><p>最近未被访问，也未被修改(u=0, m=0)。</p></li><li><p>最近被访问，但未被修改(u=1, m=0)。</p></li><li><p>最近未被访问，但被修改(u=0, m=1)。</p></li><li><p>最近被访问，被修改(u=1, m=1)。</p></li></ul><p>在改进型CLOCK算法中，<strong>系统总是倾向于替换最近未被访问且未被修改的页面</strong>，倘若不存在这样的页面，那么系统就回去寻找最近被访问但为不修改的页面。倘若无法在为修改页面中找到符合上述两条条件的页面，那么系统就会将所有物理块均视作未访问，再去进行上述查询过程。<strong>如此这般，一定可以找到一个符合条件的页面，来进行当前页面的淘汰和替换。</strong></p><h3 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/4.png" alt="改进型CLOCK置换算法流程" title="Optional title"></p><h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void CLOCK_better()**用来实现最佳置换算法的流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLOCK_better</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机生成修改页序列</span></span><br><span class="line">    getRandomModifiedPage();</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//设置替换块指针</span></span><br><span class="line">    <span class="keyword">int</span> pReplaceBlock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的使用位和修改位、缺页补全，替换块指针不动（填充完后又回到第一个位置）</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="comment">//所有的useBit全部为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//产生缺页</span></span><br><span class="line">            lakePage+=<span class="number">1</span>;</span><br><span class="line">            interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">            <span class="keyword">bool</span> ifFindReplaceBlock=<span class="literal">false</span>;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第一次寻找：find(0,0)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;!modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第二次寻找：find(0,1)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//将集合中所有页面的使用位设置成0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                useBit[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第三次寻找（使用位已修改）：find(0,0)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;!modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                useBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line">            <span class="comment">//第四次寻找（使用位已修改）：find(0,1)</span></span><br><span class="line">            <span class="comment">//如果进行到此处，一定可以找到结果，否则证明代码逻辑出现错误</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[pReplaceBlock]&amp;&amp;modifiedPage[pReplaceBlock])&#123;</span><br><span class="line">                    ifFindReplaceBlock=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ifFindReplaceBlock)&#123;</span><br><span class="line">                blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                <span class="keyword">if</span>(modifiedPage[i])&#123;</span><br><span class="line">                    modifiedBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                useBit[pReplaceBlock]=<span class="literal">true</span>;</span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面缓冲算法（PBA）"><a href="#页面缓冲算法（PBA）" class="headerlink" title="页面缓冲算法（PBA）"></a>页面缓冲算法（PBA）</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>页面缓冲算法是目前Linux系统较为常见的一种页面置换算法。</p><p>当需要置换页面时，采用FIFO从所有以分配页面中选择最先进入的页面淘汰。该算法规定将一个被淘汰的页放入两个链表中的一个，即如果页面未被修改，就将它直接放入空闲链表中；否则，便放入已经修改页面的链表中的一个。须注意的是，这时页面在内存中并不做物理上的移动，而只是将页表中的表项移到上述两个链表之一中。</p><h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/5.png" alt="页面缓冲算法流程" title="Optional title"></p><h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><p>函数**void PBA()**用来实现最佳置换算法的流程。</p><p>该函数实现的PBA算法不是标准概念的实现，区别在于没有模拟修改页面物理块和对空闲物理块的数量进行动态分配，只是模拟了固定数量的空闲物理块的情况。</p><p>按照这样的思想去实现，可以推测，这样进行的流程结果，与FIFO是完全一致的（工作物理块的变化情况）。<strong>如果在把空闲物理块调用至工作物理块的步骤也算作缺页的前提下（这一点非常重要）</strong>，连缺页率的计算结果也会和同情况下的FIFO一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PBA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//缺页数量初始化</span></span><br><span class="line">    lakePage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//页面序列指针初始化</span></span><br><span class="line">    pPage=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缺页中断记录初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        interrupt[i]=<span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充满</span></span><br><span class="line">    fillFront();</span><br><span class="line">    <span class="comment">//设置替换块指针：此处的更替指针的原理与FIFO是相同的</span></span><br><span class="line">    <span class="keyword">int</span> pReplaceBlock=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用位初始化（此处用作缺页数列的填充）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;blockNum;i++)&#123;</span><br><span class="line">        useBit[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将物理块填充过程中的缺页补全，替换块指针不动（填充完后又回到第一个位置）</span></span><br><span class="line">    <span class="comment">//从第1页到第pPage页共产生blockNum个缺页中断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pPage;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][pPage<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!useBit[j])&#123;</span><br><span class="line">                    useBit[j]=<span class="literal">true</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从能填充满物理块的那一个页面的下一个页面起开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pPage;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock;j++)&#123;</span><br><span class="line">            freeBlockSta[j][i]=freeBlockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找所有的物理块内是否存储了当前所查找的页面i</span></span><br><span class="line">        <span class="keyword">bool</span> findPage = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;blockNum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(page[i]==blockSta[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                findPage=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前一个页面所对应的物理块状态复制到当前页面所对应的物理块状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blockNum;j++)&#123;</span><br><span class="line">            blockSta[j][i]=blockSta[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内已存在相同页面</span></span><br><span class="line">        <span class="keyword">if</span>(findPage)&#123;</span><br><span class="line">            <span class="comment">//上一页面的物理块状态就是当前页面的物理块状态</span></span><br><span class="line">            <span class="comment">//上一页面的物理块状态已复制，直接进行下一页面即可</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//物理块内不存在相同页面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//是否在缓冲物理块内</span></span><br><span class="line">            <span class="keyword">int</span> inFreeBLockLocation=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(page[i]==freeBlockSta[j][i])&#123;</span><br><span class="line">                    inFreeBLockLocation=j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在缓冲物理块内</span></span><br><span class="line">            <span class="keyword">if</span>(inFreeBLockLocation!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//产生缺页</span></span><br><span class="line">                lakePage+=<span class="number">1</span>;</span><br><span class="line">                interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                <span class="comment">//将两块的内容交换</span></span><br><span class="line">                <span class="keyword">int</span> temp=blockSta[pReplaceBlock][i];</span><br><span class="line">                blockSta[pReplaceBlock][i]=freeBlockSta[inFreeBLockLocation][i];</span><br><span class="line">                freeBlockSta[inFreeBLockLocation][i]=temp;</span><br><span class="line">                <span class="comment">//将替换指针后移</span></span><br><span class="line">                pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                <span class="comment">//将这一块的内容放到最后</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=inFreeBLockLocation;j&lt;freeBlock<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    freeBlockSta[j][i]=freeBlockSta[j+<span class="number">1</span>][i];</span><br><span class="line">                &#125;</span><br><span class="line">                freeBlockSta[freeBlock<span class="number">-1</span>][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> spaceFreeBlock=<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(freeBlockSta[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">                        spaceFreeBlock=j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//有空白的缓冲物理块：</span></span><br><span class="line">                <span class="comment">//当前物理块填入空白物理块</span></span><br><span class="line">                <span class="comment">//当前页面填入当前物理块</span></span><br><span class="line">                <span class="keyword">if</span>(spaceFreeBlock!=<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//产生缺页</span></span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    <span class="comment">//将替换指针所指向的物理块进行替换</span></span><br><span class="line">                    freeBlockSta[spaceFreeBlock][i]=blockSta[pReplaceBlock][i];</span><br><span class="line">                    blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                    <span class="comment">//将替换指针后移</span></span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不存在空白的缓冲物理块</span></span><br><span class="line">                <span class="comment">//将空闲物理块的最后一个位置的内容替换成当前的页面，缺页操作同上</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//产生缺页</span></span><br><span class="line">                    lakePage+=<span class="number">1</span>;</span><br><span class="line">                    interrupt[i]=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line">                    <span class="comment">//temp保留当前物理块内容</span></span><br><span class="line">                    <span class="comment">//当前工作物理块填入当前页面作为新内容</span></span><br><span class="line">                    <span class="keyword">int</span> temp=blockSta[pReplaceBlock][i];</span><br><span class="line">                    blockSta[pReplaceBlock][i]=page[i];</span><br><span class="line">                    <span class="comment">//抛弃空闲物理块第一块的内容，temp放入最后一块的内容</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;freeBlock<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                        freeBlockSta[j][i]=freeBlockSta[j+<span class="number">1</span>][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    freeBlockSta[freeBlock<span class="number">-1</span>][i]=temp;</span><br><span class="line">                    <span class="comment">//将替换指针后移</span></span><br><span class="line">                    pReplaceBlock=(pReplaceBlock+<span class="number">1</span>)%blockNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页面序列随机算法"><a href="#页面序列随机算法" class="headerlink" title="页面序列随机算法"></a>页面序列随机算法</h2><p>显而易见的是，<strong>用来测试上述页面置换算法的页面序列不可以用全随机的方式生成。不加限制的随机序列必然不符合局部性原理</strong>。如果页面序列不符合局部性，势必会使得缺页率大大增加。</p><p>实现题目中所给的页面序列随机算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符合局部访问特性的随机生成算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRandomPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">double</span> t=rand()%<span class="number">10</span>/<span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)(pageNum/moveRate);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i*moveRate;j&lt;(i+<span class="number">1</span>)*moveRate;j++)&#123;</span><br><span class="line">            page[j]=(pageStart+rand()%everyWorkSet)%memory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> r=rand()%<span class="number">10</span>/<span class="number">10.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;t)&#123;</span><br><span class="line">            pageStart=rand()%memory;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pageStart=(pageStart+<span class="number">1</span>)%memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列的最后几个内容的长度不足以构成工作集移动的一步，单另填充，规则不变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)(pageNum/moveRate)*moveRate;i&lt;pageNum;i++)&#123;</span><br><span class="line">        page[i]=(pageStart+rand()%everyWorkSet)%memory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;生成的随机序列为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pageNum;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;page[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及对比分析"><a href="#运行结果及对比分析" class="headerlink" title="运行结果及对比分析"></a>运行结果及对比分析</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入内容分为两部分，第一部分要输入页面序列长度、页面起始位置、物理块数、每个工作集包含的页面数、工作集移动率，共五个参数；第二部分针对PBA算法输入缓冲物理块数量，限制是该数量需要小于工作物理块数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键入信息</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入页面序列长度、页面起始位置、物理块数、每个工作集包含的页面数、工作集移动率:&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;pageNum&gt;&gt;pageStart&gt;&gt;blockNum&gt;&gt;everyWorkSet&gt;&gt;moveRate;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;PBA算法中的缓冲物理块数量(需小于工作物理块数):&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;freeBlock;</span><br><span class="line">        <span class="keyword">if</span>(freeBlock&lt;blockNum)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;缓冲物理块数量有误，请重新输入:&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在接下来的测试中，输入固定如下：</p><pre><code>输入页面序列长度、页面起始位置、物理块数、每个工作集包含的页面数、工作集移动率:32 1 3 5 10PBA算法中的缓冲物理块数量(需小于工作物理块数):2</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>使用上面的输入，对于不同的随机序列，运行结果如下：</p><ul><li><p>第一次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/6.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/7.png" title="Optional title"></p></li><li><p>第二次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/8.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/9.png" title="Optional title"></p></li><li><p>第三次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/10.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/11.png" title="Optional title"></p></li><li><p>第四次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/12.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/13.png" title="Optional title"></p></li><li><p>第五次运行：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/14.png" title="Optional title"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab4/15.png" title="Optional title"></p></li></ul><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><ul><li><p>统计上述测试的缺页率：</p><table><thead><tr><th align="center">算法</th><th align="center">第一次运行</th><th align="center">第二次运行</th><th align="center">第三次运行</th><th align="center">第四次运行</th><th align="center">第五次运行</th></tr></thead><tbody><tr><td align="center">OPT</td><td align="center">0.40625</td><td align="center">0.40625</td><td align="center">0.4375</td><td align="center">0.375</td><td align="center">0.40625</td></tr><tr><td align="center">FIFO</td><td align="center">0.4375</td><td align="center">0.5625</td><td align="center">0.59375</td><td align="center">0.5</td><td align="center">0.625</td></tr><tr><td align="center">LRU</td><td align="center">0.59375</td><td align="center">0.5</td><td align="center">0.5625</td><td align="center">0.4375</td><td align="center">0.59375</td></tr><tr><td align="center">改进型CLOCK算法</td><td align="center">0.71875</td><td align="center">0.78125</td><td align="center">0.71875</td><td align="center">0.6875</td><td align="center">0.65625</td></tr><tr><td align="center">PBA</td><td align="center">0.4375</td><td align="center">0.5625</td><td align="center">0.59375</td><td align="center">0.5</td><td align="center">0.625</td></tr></tbody></table></li><li><p>针对不同的算法，5次运行的缺页率均值如下：</p><table><thead><tr><th align="center">OPT</th><th align="center">FIFO</th><th align="center">LRU</th><th align="center">改进型CLOCK算法</th><th align="center">PBA</th></tr></thead></table></li></ul><p>0.40625|0.54375|0.5375|0.712|0.54375</p><p>首先，<strong>OPT的缺页率是所有算法中最低的</strong>，这同样符合该算法的定义和其命名“最佳”。</p><p><strong>LRU算法的性能接近于OPT</strong>。但是从实现角度来说，其实现比较困难，且开销大：需要额外维护物理块中页面的调用顺序。</p><p>FIFO算法实现简单，<strong>但其机制决定了它的实际性能应该是最差的</strong>。PBA算法的缺页率和FIFO相同，这是由于模拟度不够且做了一些假设前提而导致的。<strong>它们的区别并不体现在缺页率上</strong>。</p><p><strong>那么PBA和FIFO的区别何在？在于PBA将缺页内容放在缓冲块（空闲物理块）里，而不存入内存里，不需要去内存调用对应的块，从系统资源的角度来说，节省了系统开销。这一点在我们的模拟中是无法体现的。</strong></p><p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<strong>但在上述测试中，改进型CLOCK算法的性能是最差的。</strong>由于该算法引入了修改页序列，所以导致了这一情况。<strong>可以推测，如果页面序列里没有修改页，即这些算法的流程是完全一致的，那么改进型CLOCK算法的性能会接近LRU，而FIFO的性能会变成最差。</strong></p><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091?fr=aladdin">百度百科-页面置换算法：https://baike.baidu.com/item/页面置换算法/7626091?fr=aladdin</a></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626051?fr=aladdin">百度百科-最佳页面置换算法：https://baike.baidu.com/item/最佳页面置换算法/7626051?fr=aladdin</a></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/3286551">百度百科-先进先出页面置换算法：https://baike.baidu.com/item/先进先出页面置换算法/3286551</a></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/3334556?fr=aladdin">百度百科-局部性原理：https://baike.baidu.com/item/局部性原理/3334556?fr=aladdin</a></p></blockquote><blockquote><p><a href="https://hjzgg.github.io/resume/">操作系统页面置换算法(opt,lru,fifo,clock)实现：https://hjzgg.github.io/resume/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;br&gt;代码、文章及图片挂载地址：&lt;a href=&quot;https://github.com/MoyangSensei/OS&quot;&gt;https://github.com/MoyangSensei/OS&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>编译原理：递归下降分析</title>
    <link href="http://example.com/2019/04/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2019/04/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90/</id>
    <published>2019-04-21T14:37:50.000Z</published>
    <updated>2019-05-20T12:43:36.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><blockquote><p>2019-05-20更新专题设计内容。</p></blockquote><h1 id="目标任务"><a href="#目标任务" class="headerlink" title="目标任务"></a>目标任务</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>完成以下描述赋值语句的 LL(1)文法的递归下降分析程序</p><p>G[A]: S→V=E<br>E→TE’<br>E’→ATE’|ε<br>T→FT’<br>T’→MFT’|ε<br>F→ (E)|i<br>A→+|-<br>M→*|/<br>V→i</p><h2 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h2><p>终结符号i为用户定义的简单变量，即标识符的定义。</p><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><ul><li><p>(1)输入串应是词法分析的输出二元式序列，即某算术表达式“专题1”的输出结果，输出为输入串是否为该文法定义的算术表达式的判断结果;</p></li><li><p>(2)递归下降分析程序应能发现简单的语法错误;</p></li><li><p>(3)设计两个测试用例(尽可能完备，正确和出错)，并给出测试结果;</p></li><li><p>(4)选做:如有可能，考虑如何用文法描述C语言的if语句，使整个文法仍然为LL(1)文法，并使得你的递归下降程序可以分析赋值语句和if语句。</p></li></ul><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="递归下降分析"><a href="#递归下降分析" class="headerlink" title="递归下降分析"></a>递归下降分析</h2><p>在不含左递归和每个非终结符的所有的首符集都两两不想交的条件下。我们就可以构造一个不带回溯的的自上而下的分析程序。该程序是由一组递归过程组成的。每个过程对应文法的一个非终结符。这种语法分析的方法称为文法递归下降分析法。</p><p>当一个文法满足LL(1)条件时，我们就可以为它构造一个不带回溯的自上而下分析程序，这个分析程序是由一组递归过程组成的，每个过程对应文法的一个非终结符，这样的一个分析程序称为递归下降分析器。</p><p>相比于词法分析器，构造语法分析器的方法有很多，而递归下降的方法是较为常见和简单的一种。</p><p>递归下降分析对于文法是有一定要求的：文法必须为LL（1）文法。而LL（1）文法的要求是：一为文法不含有左递归，另一为文法不含有回溯。如果存在上述情况，需要先对文法进行处理，在消除这两种情况之后方可对文法进行递归下降分析。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>递归下降分析器的构造方法非常简单，就是为每一个非终结符写一个递归函数，函数中对该终结符可能转换成的所有情况的第一个token进行判断，做出对应的处理。</p><p>需要注意的是，在进行递归下降分析之前需要对不是LL（1）的文法进行处理。</p><p>为了方便程序的编写，可先将文法转换为流程图。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/8.png" alt="图1" title="Optional title"></p><h2 id="左递归和回溯的消除"><a href="#左递归和回溯的消除" class="headerlink" title="左递归和回溯的消除"></a>左递归和回溯的消除</h2><p>由于所给的文法为标准的LL（1）文法，这一步可省略。</p><h2 id="将文法转换为流程图"><a href="#将文法转换为流程图" class="headerlink" title="将文法转换为流程图"></a>将文法转换为流程图</h2><p>对于所给的9条产生式，做如下流程图的转换：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/9.png" alt="图2" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/10.png" alt="图3" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/11.png" alt="图4" title="Optional title"></p><p>上述函数中，“match“是对单个特定终结符号的匹配，”match EOI“代表匹配“ε”。</p><h2 id="文件结构及函数简介"><a href="#文件结构及函数简介" class="headerlink" title="文件结构及函数简介"></a>文件结构及函数简介</h2><p>本专题大部分文件和功能函数与上一专题同名，具体的文件结构和功能函数简介见《编译原理：词法分析程序》。</p><p>算法函数命名同产生式的左部，且全部为bool类型。</p><p>例如，对于产生式S→V=E，对应的函数为bool S()。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>详细的主函数流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    initAll();</span><br><span class="line">    <span class="comment">//读取lab1中输出的二元组结果文件</span></span><br><span class="line">    readFile_Result();</span><br><span class="line">    <span class="comment">//读取lab1中输出的标识符结果文件</span></span><br><span class="line">    readFile_Identifier();</span><br><span class="line">    <span class="comment">//过滤读取结果，得到纯粹的标识符内容</span></span><br><span class="line">    getPureMorpheme();</span><br><span class="line">    <span class="comment">//输出过滤后的结果</span></span><br><span class="line">    printMorphemeInfo();</span><br><span class="line">    <span class="comment">//递归下降分析，得到结果</span></span><br><span class="line">    <span class="keyword">if</span>(judge())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配成功!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;匹配失败!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//输出错误位置和信息</span></span><br><span class="line">        printError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于本专题要求的输入是上一个专题输出的词素结果二元组和标识符信息，则需要从上一专题的输出文件中读取信息，并将信息过滤为我们需要的词素，以此作语法分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取标识符文件，用来识别&#x27;i&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile_Identifier</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">//FileName_Write_Result[]=&quot;/study/专业课作业/大三下编译原理/lab_1/ResultofLexicalAnalysis.txt&quot;;</span></span><br><span class="line">    fp=fopen(FileName_Write_Identifier,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;SYSTEM ERROR(readFile_Identifier)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">100</span>]=<span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="comment">//读取文件中的所有内容</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))&#123;</span><br><span class="line">        <span class="comment">//读取一整行内容</span></span><br><span class="line">        fgets(temp,<span class="number">1000</span>,fp);</span><br><span class="line">        <span class="comment">//存入标识符容器中，类型为string</span></span><br><span class="line">        identifier[i]=temp;</span><br><span class="line">        <span class="comment">//去除每一行尾部的&#x27;\0&#x27;</span></span><br><span class="line">        identifier[i].pop_back();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新标识符个数标志</span></span><br><span class="line">    idCounter=i;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在lab1中输入表达式，得到结果，并在此读取词素二元组文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile_Result</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">//FileName_Write_Identifier[]=&quot;/study/专业课作业/大三下编译原理/lab_1/Identifier.txt&quot;;</span></span><br><span class="line">    fp=fopen(FileName_Write_Result,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;SYSTEM ERROR(readFile_Result)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">100</span>]=<span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="comment">//读取文件中的所有内容</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))&#123;</span><br><span class="line">        <span class="comment">//读取一整行内容</span></span><br><span class="line">        fgets(temp,<span class="number">1000</span>,fp);</span><br><span class="line">        <span class="comment">//存入词素容器中，类型为string</span></span><br><span class="line">        morpheme[i]=temp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新词素个数标志</span></span><br><span class="line">    morphemeCounter=i;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取完词素二元组文件之后，需要对读取的内容进行过滤， 使得容器中只含词素本身，具体做法为去除从左括号（含）开始到词素本身以及词素之后的右括号。</p><p>在上述准备工作做完后，调用判断函数judge()进行判断即可。judge()函数的功能就是调用文法开始符号所对应的S()函数。</p><p>对于S()这样的算法函数，具体的做法是使用条件判断语句对应流程图做好判断即可。</p><p>以S()函数为例，递归下降分析程序对于产生式判断的基本流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//S -&gt; V = E</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">S</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// V</span></span><br><span class="line">    <span class="keyword">if</span>(V())&#123;</span><br><span class="line">        <span class="comment">// =</span></span><br><span class="line">        <span class="keyword">if</span>(!morpheme[pMorpheme].compare(<span class="string">&quot;=&quot;</span>))&#123;</span><br><span class="line">            pMorpheme+=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// E</span></span><br><span class="line">            <span class="keyword">if</span>(E())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h2><p>首先依据所给文法写出一正确的语句：</p><pre><code>var_a=(var_b+var_c*var_d)/(var_e-var_f)-var_g</code></pre><p>将此表达式写入专题1中的SourceProgram.txt文件：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/12.png" alt="图5" title="Optional title"></p><p>运行专题1程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/13.png" alt="图6" title="Optional title"></p><p>查看标识符文件Identifier.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/14.png" alt="图7" title="Optional title"></p><p>查看词素二元组文件ResultofLexicalAnalysis.txt：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/15.png" alt="图8" title="Optional title"></p><p>可以看到对于专题1来说，上述语句是符合要求的。</p><p>接下来运行本专题的递归下降判断程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/16.png" alt="图9" title="Optional title"></p><p>上述测试证明了两个程序可按设计本意顺利完成各项功能。</p><p>接下来，修改我们所给出的正确的语句，使它变得”错误”。当然这里所说的错误指的是在本专题的情景下是错误的。这些语句无论如何修改，都必须符合专题1的情景。</p><ul><li><p>(1)var_a+var_error=(var_b+var_c*var_d)/(var_e-var_f)-var_g</p></li><li><p>(2)var_a=(var_b+233*var_d)/(var_e-var_f)-var_g</p></li><li><p>(3)var_a=(var_b+ var_c*var_d)/(var_e^var_f)-var_g</p></li></ul><p>标示出来的是我们添加的错误。</p><p>分别对如上情形进行测试：</p><ul><li>（1）:</li></ul><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/17.png" alt="图10" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/18.png" alt="图11" title="Optional title"></p><ul><li>（2）:</li></ul><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/19.png" alt="图12" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/20.png" alt="图13" title="Optional title"></p><ul><li>（3）:</li></ul><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/21.png" alt="图14" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/22.png" alt="图15" title="Optional title"></p><p>根据上述结果可以看出，本程序可以实现所给LL（1）文法的递归下降分析，并能指出具体错误的位置。</p><hr><h1 id="原例题"><a href="#原例题" class="headerlink" title="原例题"></a>原例题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>某将如下文法 G[&lt;程序&gt;]，改写为 LL(1)文法，画出递归下降分析程序框图。</p><p>&lt;程序&gt;→begin &lt;语句&gt; end<br>&lt;语句&gt;→&lt;赋值语句&gt;│&lt;条件语句&gt;<br>&lt;赋值语句&gt;→&lt;变量&gt;:=&lt;表达式&gt;<br>&lt;条件语句&gt;→if &lt;表达式&gt; then &lt;语句&gt;<br>&lt;表达式&gt;→&lt;表达式&gt;+&lt;变量&gt;│&lt;变量&gt;<br>&lt;变量&gt;→i</p><h2 id="递归下降分析实现原理"><a href="#递归下降分析实现原理" class="headerlink" title="递归下降分析实现原理"></a>递归下降分析实现原理</h2><p>若要使用递归下降分析，首先得将文法变为LL(1)文法。</p><p>将文法变为LL(1)文法需要两个步骤：检查是否有左递归并消除、检查是否有回溯并消除。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="文法处理"><a href="#文法处理" class="headerlink" title="文法处理"></a>文法处理</h3><h4 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h4><p>经过检查发现，该文法中含有如下左递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;表达式&gt;→&lt;表达式&gt;+&lt;变量&gt;│&lt;变量&gt; </span><br></pre></td></tr></table></figure><p>消除左递归步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;表达式&gt; → &lt;表达式&gt; + &lt;变量&gt; │ &lt;变量&gt; </span><br><span class="line">&lt;表达式&gt; → &lt;变量&gt; &#123; + &lt;变量&gt; &#125;</span><br><span class="line">&#x2F;&#x2F;令 &#123; + &lt;变量&gt; &#125; &#x3D; &lt;表达式&gt;&#39;</span><br><span class="line">&lt;表达式&gt; → &lt;变量&gt; &lt;表达式&gt;&#39;</span><br><span class="line">&lt;表达式&gt;&#39; → + &lt;变量&gt; &lt;表达式&gt;&#39; | ξ</span><br></pre></td></tr></table></figure><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>经过检查发现，该文法无回溯，可省略此步骤。</p><h3 id="按照处理后的文法画出流程图"><a href="#按照处理后的文法画出流程图" class="headerlink" title="按照处理后的文法画出流程图"></a>按照处理后的文法画出流程图</h3><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/1.png" alt="流程图" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/2.png" alt="流程图" title="Optional title"></p><h3 id="按照流程图编写代码"><a href="#按照流程图编写代码" class="headerlink" title="按照流程图编写代码"></a>按照流程图编写代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wordCounter=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pWordCounter=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yj</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;i&quot;</span>))&#123;</span><br><span class="line">        pWordCounter+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bds_prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">        pWordCounter+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(bl())&#123;</span><br><span class="line">            <span class="keyword">if</span>(bds_prime())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;end&quot;</span>))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bl())&#123;</span><br><span class="line">        <span class="keyword">if</span>(bds_prime())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tjyj</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;if&quot;</span>))&#123;</span><br><span class="line">        pWordCounter+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(bds())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;then&quot;</span>))&#123;</span><br><span class="line">                pWordCounter+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(yj())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fzyj</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bl())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;:&quot;</span>))&#123;</span><br><span class="line">            pWordCounter+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;=&quot;</span>))&#123;</span><br><span class="line">                pWordCounter+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(bds())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yj</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fzyj())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tjyj())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cx</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;begin&quot;</span>))&#123;</span><br><span class="line">        pWordCounter+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(yj())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[pWordCounter].compare(<span class="string">&quot;end&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[wordCounter++];</span><br><span class="line">        <span class="keyword">if</span>(!a[wordCounter<span class="number">-1</span>].compare(<span class="string">&quot;end&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cx())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Success!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Error!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试用例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;begin i : &#x3D; i + i end</span><br><span class="line">&#x2F;&#x2F;begin if i then i : &#x3D; i + i end</span><br><span class="line">&#x2F;&#x2F;begin if i then if i then i : &#x3D; i + i end</span><br><span class="line">&#x2F;&#x2F;begin end</span><br><span class="line">&#x2F;&#x2F;begin a : &#x3D; i + j end</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/3.png" alt="begin i : = i + i end" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/4.png" alt="begin if i then i : = i + i end" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/5.png" alt="begin if i then if i then i : = i + i end" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/6.png" alt="begin end" title="Optional title"></p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2/7.png" alt="begin a : = i + j end" title="Optional title"></p><p>可证明该程序可实现要求功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2019-05-20更新专题设计内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目标任务&quot;&gt;&lt;a href=&quot;#目标任务&quot; class</summary>
      
    
    
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理：词法分析程序</title>
    <link href="http://example.com/2019/04/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2019/04/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-04-07T13:33:19.000Z</published>
    <updated>2019-05-20T12:42:50.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><blockquote><p>2019-05-20更新专题设计内容。</p></blockquote><h1 id="目标任务"><a href="#目标任务" class="headerlink" title="目标任务"></a>目标任务</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>以下为正则文法所描述的 C 语言子集单词符号的示例，请补充单词符号: ++，–， &gt;&gt;, &lt;&lt;, += , -= ,*=, /= ，&amp;&amp;(逻辑与)，||(逻辑或)，!(逻辑非)等等，给出补充后描述C语言子集单词符号的正则文法，设计并实现其词法分析程序。</p><p>&lt;标识符&gt;-&gt; 字母— &lt;标识符&gt;字母— &lt;标识符&gt;数字<br>&lt;无符号整数&gt;-&gt; 数字— &lt;无符号整数&gt;数字<br>&lt;单字符分界符&gt;-&gt; + – —* —;—, —(-) —{—}<br>&lt;双字符分界符&gt;-&gt; &lt;大于&gt;=—&lt;小于&gt;=—&lt;小于&gt;&gt;—&lt;感叹号&gt;=—&lt;等于&gt;=—&lt;斜竖&gt;*<br>&lt;小于&gt;-&gt; &lt;<br>&lt;等于&gt;-&gt; =<br>&lt;大于&gt;-&gt; &gt;<br>&lt;斜竖&gt;-&gt; /<br>&lt;感叹号&gt;-&gt; !</p><p>该语言的保留字 :void、int、float、double、if、else、for、do、while 等等(也可补充)。</p><h2 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h2><ul><li><p>(1)可将该语言设计成大小写不敏感，也可设计成大小写敏感，用户定 义的标识符最长不超过 32 个字符;</p></li><li><p>(2)字母为 a-z A-Z，数字为 0-9;</p></li><li><p>(3)可以对上述文法 进行扩充和改造;</p></li><li><p>(4)“/*……*/”和“//”(一行内)为程序的注释部分。</p></li></ul><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><ul><li><p>(1)给出各单词符号的类别编码;</p></li><li><p>(2)词法分析程序应能发现输入串中的错误;</p></li><li><p>(3)词法分析作为单独一遍编写，词法分析结果为二元式序列组成的中间文件;</p></li><li><p>(4) 设计两个测试用例(尽可能完备)，并给出测试结果。</p></li></ul><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>词法分析是编译程序进行编译时第一个要进行的任务，主要是对源程序进行编译预处理（去除注释、无用的回车换行找到包含的文件等）之后，对整个源程序进行分解，分解成一个个单词，这些单词大致可五类，分别是标识符、保留字、常数、运算符、界符。以便为下面的语法分析和语义分析做准备。</p><p>词法分析面向的对象是单个的字符，目的是把它们组成有效的单词（字符串）。另外，由于词法分析器在编译器中负责读取源程序，因此除了识别词素之外，它还会完成一些其他任务，比如过滤掉源程序中的注释和空白，将编译器生成的错误消息与源程序的位置关联起来等。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>根据对词法分析器的解释可知，一个词法分析器需要实现以下基本功能：</p><ul><li><p>（1）识别词素：将字符所组成的词正确分割且加以分类；</p></li><li><p>（2）错误指示：将编译器生成的错误消息与源程序的位置关联起来。</p></li></ul><p>而词法分析过程中有一些不必要的过程，这些过程虽然不是词法分析的核心思想，但是合理运用有助于更好的完成这一任务：</p><ul><li><p>（1）过滤源程序中的无用字符（注释和空白等）；</p></li><li><p>（2）词法分析一旦遇到错误不一定要直接停止，而是跳过错误部分继续后面的分析（一处错误并不一定导致其后的内容错误）。</p></li></ul><p>以结构化程序思想看待上述设计思想，就可以用这样的流程来实现词法分析器程序：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/5.png" alt="图1" title="Optional title"></p><p>对于目标内容中的每一个字符都进行上述处理，然后按照处理顺序将词素识别出来，加以区分；将无法识别的词素认定为错误，定出位置即可。</p><p>明晰了程序流程之后，接下来的问题是：如何识别词素？换言之，什么样的词素在我们看来才是“正确”的？由于我们编写的是C语言字符集的词法分析程序，那么首先可以确定的是：符合c语言词法规则的词是我们需要加以识别的。</p><p>而C语言的词法规则是极其复杂的，即使我们所写的是简化版字符集，一样也有很多内容需要我们去完善，直接编写势必会使代码复杂度增加，且没有统一的代码规则规定我们的判断条件。</p><p>在学习过编译原理的文法之后，我们都知道，只有满足字符集文法规则的终结字符才可以被识别成为正确。</p><p>所以词法分析程序的更深层目标应该是完善我们要编写的字符集的规则，并把它转化成文法规则，以计算机代码表示。这样，针对特定字符时，我们的查找就有了方向。</p><h2 id="代码流程描述"><a href="#代码流程描述" class="headerlink" title="代码流程描述"></a>代码流程描述</h2><p>函数调用流程如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/6.png" alt="图2" title="Optional title"></p><p>文件结构及函数简介如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/7.png" alt="图3" title="Optional title"></p><h2 id="字符集及其规则描述"><a href="#字符集及其规则描述" class="headerlink" title="字符集及其规则描述"></a>字符集及其规则描述</h2><p>首先给出扩充后的字符集及其编码：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/8.png" alt="图3" title="Optional title"></p><p>可将上述字符分为三类：标识符（保留字）及数字、单字符、双字符。对于不可衍生出双字符的单字符而言，只要检测到的单字符存在于上述定义表中即可匹配成功。而部分单字符的衍生字符和标识符（保留字）及数字的长度往往不止一个字符，那么就要对它们的词法规则作出规定，这样的规定既要符号现实的c语言词法规则，也要能被我们的代码结构（条件判断语句）所识别。</p><p>规则如下：</p><p>&lt;标识符&gt;→字母|&lt;标识符&gt;字母|&lt;标识符&gt;数字<br>&lt;无符号整数&gt;→数字|数字&lt;无符号整数&gt;<br>&lt;等号&gt;→==|=<br>&lt;叹号&gt;→!=|!<br>&lt;大于号&gt;→&gt;&gt;|&gt;=|&gt;<br>&lt;小于号&gt;→&lt;&lt;|&lt;=|&lt;<br>&lt;并&gt;→&amp;&amp;|&amp;<br>&lt;或&gt;→|| | |</p><p>与其他规则不同的是，需要对不符合上述规则的进行错误指出，因为仅有上述字符在进行组合是会出现“组合错误”，比如“&amp;|”，再比如“&gt;&lt;”等。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>代码中有几个重要的部分：文件读取后的过滤函数、判断字符的4个函数和指出错误的函数。</p><p>首先是过滤函数。在预处理阶段要进行源程序字符串的无用字符过滤，这里的无用字符指的是：各种各样的格式字符（\n，\t等）以及注释。对于格式字符，设置条件判断语句，遇到后直接跳过录入即可。这里需要注意的是，空格不可去除，因为有部分空格是作为词法的分割而不是格式的部分，去除会导致词法错误；对于注释而言，c语言的词法中有两种注释：//……和/*……*/，针对第一种，只要遇到，就跳过从注释符到下一个最近的换行符之间的所有内容；对于第二种，遇到/*后，就跳过从该符号到下一个最近的*/之间的所有内容。具体及注释内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤内容中的注释和无用内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filterResource</span><span class="params">(<span class="keyword">char</span> formerAllCode[], <span class="keyword">int</span> pAllCode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tempALlCode[<span class="number">100000</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pAllCode; i++)&#123;</span><br><span class="line">        <span class="comment">//去除单行注释 //......</span></span><br><span class="line">        <span class="keyword">if</span> (formerAllCode[i]==<span class="string">&#x27;/&#x27;</span>&amp;&amp;formerAllCode[i+<span class="number">1</span>]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (formerAllCode[i] != <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去除多行注释 /*......*/</span></span><br><span class="line">        <span class="keyword">if</span> (formerAllCode[i] == <span class="string">&#x27;/&#x27;</span>&amp;&amp;formerAllCode[i + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (formerAllCode[i] != <span class="string">&#x27;*&#x27;</span> || formerAllCode[i + <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (formerAllCode[i] == <span class="string">&#x27;$&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果在文件结束的时候都没有匹配到*/，说明注释符号有误</span></span><br><span class="line">                    <span class="comment">//程序直接结束，提示用户检查文件内容</span></span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;FUNC ERROR(filterResource)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去除无用格式字符</span></span><br><span class="line">        <span class="comment">//空格不可去除，有部分空格是作为词法的分割而不是格式的部分，去除会导致词法错误</span></span><br><span class="line">        <span class="keyword">if</span> (formerAllCode[i] != <span class="string">&#x27;\n&#x27;</span>&amp;&amp;formerAllCode[i] != <span class="string">&#x27;\t&#x27;</span>&amp;&amp;formerAllCode[i] != <span class="string">&#x27;\v&#x27;</span>&amp;&amp;formerAllCode[i] != <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//至此，剩下的内容为合法内容</span></span><br><span class="line">            tempALlCode[count++] = formerAllCode[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempALlCode[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(formerAllCode, tempALlCode);</span><br><span class="line">    LoadAfterFilterInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是判断字符是否正确的4个扫描函数。其中Sacnner函数按顺序调用其他的三个函数，判断顺序依次是：是否是标识符（保留字）和常数、是否是单字符、是否是双字符。</p><p>对于标识符（保留字）和常数的判断，需要注意的问题是如果一个字串被识别为标识符，它的第一位就不可以是数字，这种情况就是错误的：char a[123a456]。此处需要对这样的情况加以区分，因为如果不加以区分的话会有两种结果：一是将123a456看作一个标识符，另一是将123和456看作两个常数，a看作一个标识符。而对于我们来说，这两种看法在实际的c语言编程中都是错误的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识符（保留字）和常数判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanner_CharOrDigt</span><span class="params">(<span class="keyword">int</span> &amp;count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsChar(SourceProgram[pAllCode]))&#123;</span><br><span class="line">        <span class="comment">//首字符为字母</span></span><br><span class="line">        symbols[count++] = SourceProgram[pAllCode];</span><br><span class="line">        pAllCode+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (IsChar(SourceProgram[pAllCode]) || IsDigit(SourceProgram[pAllCode]))&#123;</span><br><span class="line">            <span class="comment">//后跟字母或数字</span></span><br><span class="line">            symbols[count++] = SourceProgram[pAllCode];</span><br><span class="line">            pAllCode+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        symbols[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//判断是否是保留字</span></span><br><span class="line">        <span class="keyword">if</span> ((symbolsNumber=getSymbolNumber(typeTable, symbols)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            symbolsNumber = <span class="number">100</span>;</span><br><span class="line">            ifSuccess=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsDigit(SourceProgram[pAllCode]))&#123;</span><br><span class="line">        <span class="comment">//首字符为数字</span></span><br><span class="line">        <span class="keyword">while</span> (IsDigit(SourceProgram[pAllCode]))&#123;</span><br><span class="line">            <span class="comment">//后跟数字</span></span><br><span class="line">            symbols[count++] = SourceProgram[pAllCode];</span><br><span class="line">            pAllCode+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        symbols[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!IsChar(SourceProgram[pAllCode]))&#123;</span><br><span class="line">            symbolsNumber = <span class="number">99</span>;</span><br><span class="line">            ifSuccess=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果在首字符为数字的情况下发现后有字母，整个标识符都会被判断是错误的</span></span><br><span class="line">            <span class="comment">//组合错误</span></span><br><span class="line">            combinationError(symbols);</span><br><span class="line">            <span class="comment">//跳过该行</span></span><br><span class="line">            JumpErrorLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单字符的判断很简单，仅需要一个条件语句即可。</p><p>对于双字符的判断要运用到超前分析，如果不是双字符但符合单字符的情况，就要将数组指针前移。</p><p>本程序将词法的错误分为两类：一是未知字符错误：出现了系统中没有定义的字符，最简单的例子就是在代码中输出提示信息含有中文字符，因为所有的中文字符是没有在上面的字符集里的，所以会报此错误；另一是组合错误，即字符之间的组合出现错误，上面的123a456就是一种组合错误，常见的组合错误还有&amp;|等。需要注意的是，并不是所有的字符组合都是有错误的，比如+-和-+，它们在判断的时候应该属于两个单字符，但是+和-都可以作为双字符的第一个字符。对于大多数的这种情况来说，应该是语法分析需要完成的内容，在本程序里，之需要对这种情况做单字符判断即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出未定义字符错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefinedError</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;ErrorCounter&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ErrorCounter+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;错误种类:未定义字符错误&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;错误语句-&gt;  &quot;</span>&lt;&lt;CodeOfEveryLine[pLineCounter]&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;错误位置-&gt;  &quot;</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出组合错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combinationError</span><span class="params">(<span class="keyword">char</span> *symbols)</span></span>&#123;</span><br><span class="line">    symbols[<span class="number">1</span>]=SourceProgram[pAllCode];</span><br><span class="line">    symbols[<span class="number">2</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    ifErrorLine=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;ErrorCounter&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ErrorCounter+=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;错误种类:组合错误&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;错误语句-&gt;  &quot;</span>&lt;&lt;CodeOfEveryLine[pLineCounter]&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;错误位置-&gt;  &quot;</span>&lt;&lt;symbols&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h2><p>以两个错误信息输出函数为测试代码，将代码放入SourceProgram.txt中：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/9.png" alt="图4" title="Optional title"></p><p>运行程序，发现该代码段无错误：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/10.png" alt="图5" title="Optional title"></p><p>查看ResultofLexicalAnalysis.txt文件（二元组）：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/11.png" alt="图6" title="Optional title"></p><p>修改代码，人为的添加几处错误：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/12.png" alt="图7" title="Optional title"></p><p>代码运行结果如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/13.png" alt="图8" title="Optional title"></p><p>上述测试证明了该程序可按设计本意顺利完成各项功能：对于添加的三处错误，第一处是组合错误，后两处是未定义字符错误（/346是UTF-8字符集，用三个字节表示一个汉字）。</p><hr><h1 id="原例题"><a href="#原例题" class="headerlink" title="原例题"></a>原例题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>某操作系统下合法的文件名规则为:device:name.extention,其中第 一部分(device:)和第三部分(.extention)可缺省，若 device、name 和 extention，编程序完成文件名的识别。</li><li>编写程序完成以下“无符号数”的识别和计算：G[&lt;无符号数&gt;]: 右线性正则文法</li></ul><p>&lt;无符号数&gt; → d &lt;余留无符号数&gt; ∣. &lt;小数部分&gt; ∣d </p><p>&lt;余留无符号数&gt; → d &lt;余留无符号数&gt; ∣. &lt;十进小数&gt; ∣ E &lt;指数部分&gt; ∣ . ∣ d </p><p>&lt;十进小数&gt; → E&lt;指数部分&gt; ∣d &lt;十进小数&gt; ∣ d</p><p>&lt;小数部分&gt; → d &lt;十进小数&gt; ∣ d</p><p>&lt;指数部分&gt; → d &lt;余留指数部分&gt; ∣+ &lt;整指数&gt; ∣ - &lt;整指数&gt; ∣ d </p><p>&lt;整指数&gt; → d &lt;余留整指数&gt; ∣ d</p><p>&lt;余留整指数&gt; → d &lt;余留整指数&gt; ∣ d 其中 d:代表数字 0-9</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>词法分析是编译程序进行编译时第一个要进行的任务，主要是对源程序进行编译预处理（去除注释、无用的回车换行找到包含的文件等）之后，对整个源程序进行分解，分解成一个个单词，这些单词有且只有五类，分别是标识符、保留字、常数、运算符、界符。以便为下面的语法分析和语义分析做准备。可以说词法分析面向的对象是单个的字符，目的是把它们组成有效的单词（字符串）；而语法的分析则是利用词法分析的结果作为输入来分析是否符合语法规则并且进行语法制导下的语义分析，最后产生四元组(中间代码)，进行优化（可有可无）之后最终生成目标代码。</p><p>对于我们来说，词法分析程序的逻辑是十分简单的：<strong>通过循环的方式按顺序逐个识别输入的字符，如果某一个字符没有错误，那就进入下一个字符的识别，一旦发现有错就直接跳出，报错即可。</strong></p><p>在此思想下，我们需要考虑的问题是：<strong>我们怎么“识别”当前字符到底是对的还是错的</strong>？</p><p>在学习过编译原理的文法之后，我们都知道，<strong>只有满足文法规则的终结字符才可以被识别</strong>（右线性正则文法）。那么我们又怎么把抽象的文法规则具像化到代码中去？</p><p>状态转换图可以帮我们解决这个问题。我们都知道，状态转换图可以更加高效的表示文法。文法或许不好用计算机代码直接解释，但是自动机所化成的状态转换图就可以利用我们在数据结构中所学习的<strong>图论</strong>的知识来转化，仅需要很简单的结构体就可以完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储状态转换图中点-&gt;边-&gt;点的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, next;</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">&#125;edge[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>有了存储结构之后，我们就要使用循环的方式对输入进来的字符串进行检查。从入口状态开始检查第一个终结字符，直到检查完成即可。每往下进行一个字符，对应着状态转换图中状态的转换；每个字符的转换都必须符合提前设置好的状态转换图。<strong>如果从当前字符无法转换到下一个字符且当前字符不是最后一个字符或者检查完成的最后一个状态不是终结状态，就判定整个字符串匹配失败</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请键入字符串(&quot;</span>&lt;&lt;end_sentence&lt;&lt;<span class="string">&quot;退出):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n[&quot;</span>&lt;&lt;round++&lt;&lt;<span class="string">&quot;]: &quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; print_sentence;</span><br><span class="line">        <span class="keyword">if</span>(print_sentence == end_sentence)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;退出&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前状态标号</span></span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>; </span><br><span class="line">        <span class="comment">//标记是否是合法的串</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; print_sentence.length() &amp;&amp; flag; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> value = print_sentence[i];</span><br><span class="line">            <span class="keyword">if</span> (judge_VT(value))</span><br><span class="line">                value = vt_represent;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = node[now]; j != <span class="number">-1</span>; j = edge[j].next)</span><br><span class="line">                <span class="keyword">if</span> (edge[j].value == value)&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    now = edge[j].to;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isFinal[now])&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;正确&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;错误&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述过程中，我们需要函数来帮我们识别除了特殊符号外的终结符。识别过后的终结符直接更换为更一般的符号代替，简化代码流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//识别0-9</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge_VT</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//识别所有字母</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge_VT</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;Z&#x27;</span>) || (x &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;z&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><p>此思想下所需要的状态转换图<strong>没有必要是最简化的</strong>，由于输入的长度一定是有限的，转换图中拥有回路亦可得出答案。</p><p>例题1的状态转换图如下所示：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/1.png" alt="例题1的状态转换图" title="Optional title"></p><p>转换为代码中的变量如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> node[<span class="number">6</span>];<span class="comment">//状态节点，0~5</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">bool</span> isFinal[<span class="number">6</span>]; <span class="comment">//判断一个状态是不是终态</span></span><br><span class="line"><span class="keyword">int</span> counter=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> vn_left[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> vt[]=&#123;vt_represent,vt_represent,<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,vt_represent,vt_represent,<span class="string">&#x27;.&#x27;</span>,vt_represent,vt_represent,&#125;;</span><br><span class="line"><span class="keyword">int</span> vn_right[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFinal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isFinal[<span class="number">1</span>] = isFinal[<span class="number">4</span>] = isFinal[<span class="number">5</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题2的状态转换图如下所示：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/2.png" alt="例题2的状态转换图" title="Optional title"></p><p>转换为代码中的变量如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> node[<span class="number">8</span>];<span class="comment">//状态节点，0~5</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">bool</span> isFinal[<span class="number">8</span>]; <span class="comment">//判断一个状态是不是终态</span></span><br><span class="line"><span class="keyword">int</span> counter=<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> vn_left[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> vt[]=&#123;vt_represent,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, vt_represent,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,vt_represent,vt_represent,vt_represent,<span class="string">&#x27;e&#x27;</span>,vt_represent,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,vt_represent,vt_represent,vt_represent,vt_represent&#125;;</span><br><span class="line"><span class="keyword">int</span> vn_right[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFinal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isFinal[<span class="number">1</span>] = isFinal[<span class="number">3</span>] = isFinal[<span class="number">6</span>] = isFinal[<span class="number">7</span>] = <span class="literal">true</span>;<span class="comment">//标记终态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>除了上述的部分代码不一样外，这两道例题的思想是一样的，它们公用下面的程序。执行不同的程序就将另外一个程序的变量注释（注释中以标出），直接编译运行即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共变量,用作提示信息和输入等</span></span><br><span class="line"><span class="keyword">int</span> round;</span><br><span class="line"><span class="built_in">string</span> print_sentence;</span><br><span class="line"><span class="built_in">string</span> end_sentence;</span><br><span class="line"><span class="keyword">char</span> vt_represent=<span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, next;</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">&#125;edge[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////第九题的变量及函数</span></span><br><span class="line"><span class="comment">//int node[6];//状态节点，0~5</span></span><br><span class="line"><span class="comment">//int cnt;</span></span><br><span class="line"><span class="comment">//bool isFinal[6]; //判断一个状态是不是终态</span></span><br><span class="line"><span class="comment">//int counter=9;</span></span><br><span class="line"><span class="comment">//int vn_left[]=&#123;0,1,1,1,2,3,4,4,5&#125;;</span></span><br><span class="line"><span class="comment">//char vt[]=&#123;vt_represent,vt_represent,&#x27;:&#x27;,&#x27;.&#x27;,vt_represent,vt_represent,&#x27;.&#x27;,vt_represent,vt_represent,&#125;;</span></span><br><span class="line"><span class="comment">//int vn_right[]=&#123;1,1,2,3,4,5,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">//bool judge_VT(char x)&#123;</span></span><br><span class="line"><span class="comment">//    return ((x &gt;= &#x27;A&#x27; &amp;&amp; x &lt;= &#x27;Z&#x27;) || (x &gt;= &#x27;a&#x27; &amp;&amp; x &lt;= &#x27;z&#x27;));</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//void setFinal()&#123;</span></span><br><span class="line"><span class="comment">//    isFinal[1] = isFinal[4] = isFinal[5] = true;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////第十题的变量及函数</span></span><br><span class="line"><span class="keyword">int</span> node[<span class="number">8</span>];<span class="comment">//状态节点，0~5</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">bool</span> isFinal[<span class="number">8</span>]; <span class="comment">//判断一个状态是不是终态</span></span><br><span class="line"><span class="keyword">int</span> counter=<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> vn_left[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> vt[]=&#123;vt_represent,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;e&#x27;</span>, vt_represent,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,vt_represent,vt_represent,vt_represent,<span class="string">&#x27;e&#x27;</span>,vt_represent,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,vt_represent,vt_represent,vt_represent,vt_represent&#125;;</span><br><span class="line"><span class="keyword">int</span> vn_right[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge_VT</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFinal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isFinal[<span class="number">1</span>] = isFinal[<span class="number">3</span>] = isFinal[<span class="number">6</span>] = isFinal[<span class="number">7</span>] = <span class="literal">true</span>;<span class="comment">//标记终态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////公共函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入边的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">char</span> value)</span></span>&#123;</span><br><span class="line">    edge[cnt].from = from;</span><br><span class="line">    edge[cnt].to = to;</span><br><span class="line">    edge[cnt].value = value;</span><br><span class="line">    edge[cnt].next = node[from];</span><br><span class="line">    node[from] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数，用来构造自动机的状态转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    end_sentence=<span class="string">&quot;end&quot;</span>;</span><br><span class="line">    round=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">-1</span>, <span class="keyword">sizeof</span>(node));</span><br><span class="line">    <span class="built_in">memset</span>(isFinal, <span class="literal">false</span>, <span class="keyword">sizeof</span>(isFinal));</span><br><span class="line">    setFinal();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;counter;i++)&#123;</span><br><span class="line">        insert(vn_left[i], vn_right[i], vt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请键入字符串(&quot;</span>&lt;&lt;end_sentence&lt;&lt;<span class="string">&quot;退出):\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n[&quot;</span>&lt;&lt;round++&lt;&lt;<span class="string">&quot;]: &quot;</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; print_sentence;</span><br><span class="line">        <span class="keyword">if</span>(print_sentence == end_sentence)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;退出&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>; <span class="comment">//now 当前状态</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>; <span class="comment">//标记是否是合法的串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; print_sentence.length() &amp;&amp; flag; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> value = print_sentence[i];</span><br><span class="line">            <span class="keyword">if</span> (judge_VT(value))</span><br><span class="line">                value = vt_represent;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = node[now]; j != <span class="number">-1</span>; j = edge[j].next)</span><br><span class="line">                <span class="keyword">if</span> (edge[j].value == value)&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    now = edge[j].to;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isFinal[now])&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;正确&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;错误&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    judge();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>例题1的运行结果：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/3.png" alt="例题1的运行结果" title="Optional title"></p><p>例题2的运行结果：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1/4.png" alt="例题2的运行结果" title="Optional title"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2019-05-20更新专题设计内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目标任务&quot;&gt;&lt;a href=&quot;#目标任务&quot; class</summary>
      
    
    
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔记（1）:来去之路</title>
    <link href="http://example.com/2019/04/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%E6%9D%A5%E5%8E%BB%E4%B9%8B%E8%B7%AF/"/>
    <id>http://example.com/2019/04/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%E6%9D%A5%E5%8E%BB%E4%B9%8B%E8%B7%AF/</id>
    <published>2019-04-07T09:02:29.000Z</published>
    <updated>2020-09-09T12:17:06.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>作为一名科班出身、将来极有可能从事计算机行业的人，“追赶潮流”是我们必须要拥有的品质。倘若我们追赶不上计算机及其领域思想的更新换代，那么就相当于被淘汰掉了。对于深度学习这个概念来说更是如此，自它和它的父、子概念面世以来，就受到了世人的追捧，以至于到现在已经变得有些“泡沫“起来。“但凡是一个会写代码的人都会用深度学习方法”，这种话已经实现了大半了，诸多的开源平台已经把这门学科的门槛拉到了极低的地步。与我个人而言，现在的学习时机算不上是最早的，但却是最好的。所以将深度学习做一个系列的学习笔记，不定时记录自己的学习过程。</p><hr><h1 id="什么是深度学习？"><a href="#什么是深度学习？" class="headerlink" title="什么是深度学习？"></a>什么是深度学习？</h1><blockquote><p>深度学习（Deep Learning）的概念源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。</p><p>深度学习的概念由Hinton等人于2006年提出。基于深度置信网络(DBN)提出非监督贪心逐层训练算法，为解决深层结构相关的优化难题带来希望，随后提出多层自动编码器深层结构。此外Lecun等人提出的卷积神经网络是第一个真正多层结构学习算法，它利用空间相对关系减少参数数目以提高训练性能。</p><p>深度学习是机器学习中一种基于对数据进行表征学习的方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。</p></blockquote><p>上述概念来源于百度百科，这样的表述对于接触过这个领域的人来说是易懂的。我们从中可以得到深度学习一个关键的来源：<strong>人工神经网络</strong>。这对于上过机器学习课程的我来说并不是陌生词汇，同时产生的疑惑却是：这不是机器学习里面的算法吗？深度学习和机器学习之间有什么关系呢？</p><hr><h1 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h1><blockquote><p>机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p><p>它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。</p></blockquote><p>上述概念还是来源于百度百科，这样的表述还是简单易懂的。我们从中可以得到深度学习一个关键的来源：<strong>人工智能</strong>。说到这里，大多数人肯定就脱口而出了：<strong>那不就是AI么！</strong>说起这个AI来，实际上我也上过同名的课程，只不过仅仅学习了一些经典的算法，考试内容也多是关于算法，概念性的东西当时也没有在乎。所以我们可以接着往下探索了。</p><hr><h1 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h1><blockquote><p>人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p><p>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。</p><p>人工智能是一门极富挑战性的科学，从事这项工作的人必须懂得计算机知识，心理学和哲学。人工智能是包括十分广泛的科学，它由不同的领域组成，如机器学习，计算机视觉等等，总的说来，人工智能研究的一个主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。但不同的时代、不同的人对这种“复杂工作”的理解是不同的。2017年12月，人工智能入选“2017年度中国媒体十大流行语”。</p></blockquote><p>上述概念你们自己猜一猜来源于哪儿。探索到这里，已经非常清晰明了了。简言之，这是以计算机科学为基础的一门学科，其目的是让计算机使用人的思考方式替代人们思考复杂工作。</p><p>至此，我们开始向上回溯。</p><hr><h1 id="AL、ML和DL"><a href="#AL、ML和DL" class="headerlink" title="AL、ML和DL"></a>AL、ML和DL</h1><p>具象的展示这三者的关系如下：</p><p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/1/1.png" alt="AL、ML和DL" title="Optional title"></p><p>这几者的包含关系是层次递进的。这样的递进不仅仅是概念上的递进，而且是时间上的递进。</p><p>那么，人工智能是最早出现的，也是最大、最外侧的同心圆；其次是机器学习，稍晚一点；最内侧，是深度学习，当今人工智能大爆炸的核心驱动。五十年代，人工智能曾一度被极为看好。之后，人工智能的一些较小的子集发展了起来。先是机器学习，然后是深度学习。深度学习又是机器学习的子集。</p><p>这门学科的发展流程几经波折，却又自然而然：</p><ul><li>1956年，几个计算机科学家相聚在达特茅斯会议（Dartmouth Conferences），提出了“人工智能”的概念。而我们目前能实现的，一般被称为“弱人工智能”（Narrow AI）。弱人工智能是能够与人一样，甚至比人更好地执行特定任务的技术。例如，Pinterest上的图像分类；或者Facebook的人脸识别。这些是弱人工智能在实践中的例子。<strong>这些技术实现的是人类智能的一些具体的局部</strong>。</li><li>自被公认为是人工智能的核心以后，机器学习成为了人工智能研究最热门的分支，它的发展过程大体上可分为4个时期。第一阶段是在20世纪50年代中叶到60年代中叶，属于热烈时期。第二阶段是在20世纪60年代中叶至70年代中叶，被称为机器学习的冷静时期。第三阶段是从20世纪70年代中叶至80年代中叶，称为复兴时期。机器学习的最新阶段始于1986年。至今，机器学习的发展已经渐趋完善了。传统算法包括决策树学习、推导逻辑规划、聚类、强化学习和贝叶斯网络等等。众所周知，我们还没有实现强人工智能。早期机器学习方法甚至都无法实现弱人工智能。<strong>机器学习最成功的应用领域是计算机视觉</strong>。</li><li>随着时间的推进，学习<strong>算法</strong>的发展改变了一切。人工神经网络（Artificial Neural Networks）是早期机器学习中的一个重要的算法，历经数十年风风雨雨。神经网络的原理是受我们大脑的生理结构——互相交叉相连的神经元启发。但与大脑中一个神经元可以连接一定距离内的任意神经元不同，人工神经网络具有离散的层、连接和数据传播的方向。当人们发觉了这个模型能够在这样的分解下以任意的形态构建出解释问题的模型时，深度学习的思想被单独提了出来，发展至今。</li></ul><p>深度学习造成了前所未有的巨大的影响，这个相信接触过的人都能够或多或少地感受过。至于我们所熟知的机器学习和深度学习，它们之间的差异说简单也简单，但也并不是能用一两句话就能够说清楚的。我将在之后的笔记中再做详细介绍。</p><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/9180">百度百科-人工智能：https://baike.baidu.com/item/人工智能/9180</a></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">百度百科-机器学习：https://baike.baidu.com/item/机器学习</a></p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/3729729">百度百科-深度学习：https://baike.baidu.com/item/深度学习/3729729</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/ccnucb/article/details/79722714">AI、机器学习和深度学习之间的区别是什么？：https://blog.csdn.net/ccnucb/article/details/79722714</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;作为一名科班出身、将来</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统三：同步问题</title>
    <link href="http://example.com/2019/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2019/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</id>
    <published>2019-04-06T13:16:05.000Z</published>
    <updated>2019-04-07T11:48:06.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！<br>代码、文章及图片挂载地址：<a href="https://github.com/MoyangSensei/OS">https://github.com/MoyangSensei/OS</a></p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li><p>1 通过fork的方式，产生4个进程P1,P2,P3,P4，每个进程打印输出自己的名字，例如P1输出“I am the process P1”。要求P1最先执行，P2、P3互斥执行，P4最后执行。通过多次测试验证实现是否正确。</p></li><li><p>2 火车票余票数ticketCount 初始值为1000，有一个售票线程，一个退票线程，各循环执行多次。添加同步机制，使得结果始终正确。要求多次测试添加同步机制前后的实验效果。(说明：为了更容易产生并发错误，可以在适当的位置增加一些pthread_yield()，放弃CPU，并强制线程频繁切换，例如售票线程的关键代码：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//售票线程的关键代码：</span></span><br><span class="line">temp=ticketCount;</span><br><span class="line">pthread_yield();</span><br><span class="line">temp=temp<span class="number">-1</span>;</span><br><span class="line">pthread_yield();</span><br><span class="line">ticketCount=temp;</span><br><span class="line"><span class="comment">//退票线程的关键代码：</span></span><br><span class="line">temp=ticketCount;</span><br><span class="line">pthread_yield();</span><br><span class="line">temp=temp+<span class="number">1</span>;</span><br><span class="line">pthread_yield();</span><br><span class="line">ticketCount=temp;</span><br></pre></td></tr></table></figure><ul><li><p>3 一个生产者一个消费者线程同步。设置一个线程共享的缓冲区， char buf[10]。一个线程不断从键盘输入字符到buf,一个线程不断的把buf的内容输出到显示器。要求输出的和输入的字符和顺序完全一致。（在输出线程中，每次输出睡眠一秒钟，然后以不同的速度输入测试输出是否正确）。要求多次测试添加同步机制前后的实验效果。</p></li><li><p>4 （选做题2）进程通信问题。阅读并运行共享内存、管道、消息队列三种机制的代码<br><a href="https://www.cnblogs.com/Jimmy1988/p/7699351.html">消息队列：https://www.cnblogs.com/Jimmy1988/p/7699351.html</a><br><a href="https://www.cnblogs.com/Jimmy1988/p/7553069.html">管道：https://www.cnblogs.com/Jimmy1988/p/7553069.html</a><br><a href="https://www.cnblogs.com/Jimmy1988/p/7706980.html">共享内存：https://www.cnblogs.com/Jimmy1988/p/7706980.html</a><br>a）通过实验测试，验证共享内存的代码中，receiver能否正确读出sender发送的字符串？如果把其中互斥的代码删除，观察实验结果有何不同？如果在发送和接收进程中打印输出共享内存地址，他们是否相同，为什么？<br>b) 有名管道和无名管道通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？<br>c) 消息通信系统调用是否已经实现了同步机制？通过实验验证，发送者和接收者如何同步的。比如，在什么情况下，发送者会阻塞，什么情况下，接收者会阻塞？</p></li><li><p>5 阅读Pintos操作系统，找到并阅读进程上下文切换的代码，说明实现的保存和恢复的上下文内容以及进程切换的工作流程。</p></li></ul><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><ul><li>（1）根据题意，四个进程的输出顺序仅有两种：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;3-&gt;4</span><br><span class="line">1-&gt;3-&gt;2-&gt;4</span><br></pre></td></tr></table></figure><p>p1最先输出信息，p4最后输出信息，由于p2和p3在整个过程中处于相同的输出顺序，即位于p1和p4中间输出，那么便可将它们看作一个进程，称作p23。</p><p>执行过程中，p1无条件最先执行，无需控制。p23需要等待来自p1的信号，当p1执行完毕后，p23才可以执行。那么此处需要一个信号量来控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem1 &#x3D; sem_open(&quot;1&quot;, O_CREAT, 0666, 0);</span><br></pre></td></tr></table></figure><p>同理，p4要等待p23执行完之后再执行，此处需要另一个信号量来控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem4 &#x3D; sem_open(&quot;4&quot;, O_CREAT, 0666, 0);</span><br></pre></td></tr></table></figure><p>最后，在p23内部，p2和p3执行过程中需要满足互斥的条件，此处还需要一个信号量来控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem2 &#x3D; sem_open(&quot;2&quot;, O_CREAT, 0666, 0);</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span>* sem1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sem_t</span>* sem4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">sem_t</span>* sem2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> p,p_father;</span><br><span class="line">    sem1 = sem_open(<span class="string">&quot;1&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    sem4 = sem_open(<span class="string">&quot;4&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    sem2 = sem_open(<span class="string">&quot;2&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    p_father = getpid();</span><br><span class="line">    p = fork();</span><br><span class="line">    p = fork();</span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getpid() != p_father)&#123;</span><br><span class="line">            p=fork();</span><br><span class="line">            <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">                sem_wait(sem1);</span><br><span class="line">                sem_wait(sem4);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I am the process 4\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I am the process 1\n&quot;</span>);</span><br><span class="line">                sem_post(sem2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(getppid()!=p_father)&#123;</span><br><span class="line">            sem_wait(sem2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am the process 3\n&quot;</span>);</span><br><span class="line">            sem_post(sem2);</span><br><span class="line">            sem_post(sem4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sem_wait(sem2);</span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I am the process 2\n&quot;</span>);</span><br><span class="line">            sem_post(sem2);</span><br><span class="line">            sem_post(sem1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_close(sem1);</span><br><span class="line">    sem_close(sem4);</span><br><span class="line">    sem_close(sem2);</span><br><span class="line">    sem_unlink(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    sem_unlink(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    sem_unlink(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（2）通过多次实验，发现运行结果仅出现上述两种结果中的一种。即1-&gt;2-&gt;3-&gt;4。此现象的原因由于代码顺序的缘故，p2一定比p3先进入，且本程序仅仅只是控制台输出一行话，几乎不存在p3由于运行的速度快而“反超”p2。<br>若想要出现第二种结果，则可以p2进程执行的代码中加入了sleep(1)，代码见上方注释。<br>两种运行结果测试如下：<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/1.png" alt="图1.1" title="Optional title"></li></ul><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><ul><li>（1）根据题意编写代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex ;</span><br><span class="line"><span class="keyword">int</span> ticket_counter;</span><br><span class="line"><span class="keyword">int</span> producer_counter;</span><br><span class="line"><span class="keyword">int</span> consumer_counter;</span><br><span class="line"><span class="keyword">int</span> all_pro;<span class="keyword">int</span> all_con;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">( <span class="keyword">int</span> i )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;this is producer&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(--i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        pthread_mutex_lock( &amp;mutex );</span><br><span class="line">        <span class="comment">//sched_yield();</span></span><br><span class="line">        ticket_counter++;</span><br><span class="line">        sched_yield();</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_unlock( &amp;mutex );</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">( <span class="keyword">int</span> j )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(j--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        pthread_mutex_lock( &amp;mutex );</span><br><span class="line">        <span class="comment">//sched_yield();</span></span><br><span class="line">        ticket_counter--;</span><br><span class="line">        sched_yield();</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_unlock( &amp;mutex );</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_and_join_Pthread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    all_con=<span class="number">0</span>;all_pro=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> *pro, *con;</span><br><span class="line">    pro=(<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*producer_counter);</span><br><span class="line">    con=(<span class="keyword">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*consumer_counter);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]个线程分别产生的票数为: &quot;</span>,producer_counter);</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;producer_counter;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand() % <span class="number">51</span> + <span class="number">1</span>;</span><br><span class="line">        all_pro+=a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a);</span><br><span class="line">        pthread_create( &amp;pro[i], <span class="literal">NULL</span>, producer, a );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]个线程分别售出的票数为: &quot;</span>,consumer_counter);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;consumer_counter;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = rand() % <span class="number">51</span> + <span class="number">1</span>;</span><br><span class="line">        all_con+=a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a);</span><br><span class="line">        pthread_create( &amp;con[i], <span class="literal">NULL</span>, consumer, a );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;producer_counter;i++)&#123;</span><br><span class="line">        pthread_join( pro[i], <span class="literal">NULL</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;producer_counter;i++)&#123;</span><br><span class="line">        pthread_join( con[i], <span class="literal">NULL</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入产生车票线程数/销售车票线程数/开始时总票数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;producer_counter,&amp;consumer_counter,&amp;ticket_counter);</span><br><span class="line"><span class="comment">//    ticket_counter=10000;</span></span><br><span class="line"><span class="comment">//    producer_counter=12;</span></span><br><span class="line"><span class="comment">//    consumer_counter=2;</span></span><br><span class="line">    <span class="keyword">int</span> temp=ticket_counter;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    create_and_join_Pthread();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;完成该过程后应有余票[%d],其中售出[%d],生产[%d].\n&quot;</span>,temp-all_con+all_pro,all_con,all_pro);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n实际还有余票为[%d]\n&quot;</span>,ticket_counter+producer_counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，运行需要输入三项信息：产生车票线程数/销售车票线程数/开始时总票数。使用唯一一个信号量mutex来控制所有线程。create_and_join_Pthread()函数用来根据输入的信息添加相应数量的消费线程和生产线程。每个生产线程所生产的数目由随机函数生成，为1-50之间的随机数。<em>这样做的目的是方便模拟不同线程数量的情况</em>。</p><ul><li>（2）当添加*sched_yield()*时，多次运行程序，得到结果如下。发现错误概率很小，即使是填入了非常大的数据，也不一定会出错，但是错误是一定存在的：</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/2.1.png" alt="图2.1" title="Optional title"></p><p>将上述代码注释之后，结果如下，它们都是完全正确的：</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/2.2.png" alt="图2.2" title="Optional title"></p><p>填入极大数据测试，发现结果也是正确的：</p><blockquote><p>Linux虚拟机无法容纳如下所示的线程量，更换测试环境到mac os下的编译器Xcode。<br>对于unix系统来说，是由贝尔实验室开发的多用户、多任务操作系统。<br>Linux是一类unix操作系统的统称，严格来说，Linux系统只有内核叫“Linux”，而Linux也只是表示其内核，但因为习惯使然，人们习惯了用linux称呼这类系统。一般也可以认为，Linux是一套自由使用和自由传播的类unix系统。<br>mac os是苹果公司个人电脑的专用系统，是基于unix内核的图形化操作系统，它可以使用Linux系统下的绝大部分指令和操作。<br>该测试环境不会影响运行结果，之后有可能还会使用此测试环境。</p></blockquote><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/2.3.png" alt="图2.3" title="Optional title"></p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/2.4.png" alt="图2.4" title="Optional title"></p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><blockquote><p>生产者、消费者问题可以从线程同步和进程同步两个方面考虑。倘若使用进程同步的思想，使用sem_wait和sam_pose函数控制两个信号量使得生产和消费互斥即可，当然同样需要考虑队满和队空的阻塞、唤醒机制。</p></blockquote><ul><li><p>（1）根据题意，本题目为一个消费者线程和一个生产者线程进行互斥的问题。可以使用条件变量。<br>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立“而挂起；另一个线程使“条件成立”（给出条件成立信号）。<br>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起，具体用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex)</span><br><span class="line">    <span class="keyword">while</span>或<span class="keyword">if</span>(线程执行的条件是否成立)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    <span class="comment">//线程执行</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure></li><li><p>（2）根据上述分析，编写代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> items = <span class="number">0</span>, spaces = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex ;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count1 = PTHREAD_COND_INITIALIZER;  <span class="comment">// 缓冲区不满</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> count2 = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;this is producer&quot;);</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;       </span><br><span class="line">            pthread_mutex_lock( &amp;mutex );  </span><br><span class="line">            <span class="keyword">while</span>( items==<span class="number">10</span> ) &#123;</span><br><span class="line">                pthread_cond_wait( &amp;count1, &amp;mutex );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf(&quot;this is real producer&quot;);</span></span><br><span class="line">            <span class="keyword">char</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;temp);</span><br><span class="line">            buf[in]=temp;</span><br><span class="line">            in = ( in + <span class="number">1</span> ) % <span class="number">10</span>;</span><br><span class="line">            items++;spaces--;</span><br><span class="line">            pthread_cond_signal( &amp;count2 );</span><br><span class="line">            pthread_mutex_unlock( &amp;mutex );</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">( <span class="keyword">void</span> *arg )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">            <span class="comment">//printf(&quot;this is consumer&quot;);</span></span><br><span class="line">            pthread_mutex_lock( &amp;mutex );</span><br><span class="line">            <span class="keyword">while</span>( spaces==<span class="number">10</span> ) &#123;</span><br><span class="line">                pthread_cond_wait( &amp;count2, &amp;mutex );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf(&quot;this is real consumer&quot;);</span></span><br><span class="line">            <span class="comment">//sleep(3);</span></span><br><span class="line">            print=buf[out];</span><br><span class="line">            out = ( out + <span class="number">1</span> ) % <span class="number">10</span>;</span><br><span class="line">            items--;spaces++;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;consumer : %c \n&quot;</span>, print);</span><br><span class="line">            pthread_cond_signal( &amp;count1 );</span><br><span class="line">            pthread_mutex_unlock( &amp;mutex );</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> pro, con;</span><br><span class="line">    pthread_create( &amp;pro, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span> );</span><br><span class="line">    pthread_create( &amp;con, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span> );</span><br><span class="line">    pthread_join( pro, <span class="literal">NULL</span> );</span><br><span class="line">    pthread_join( con, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>（3）运行该程序。可在输出途中输入，证明互斥变量是生效的。</p></li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/3.png" alt="图3.1" title="Optional title"></p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><ul><li>（1）分别在两个终端内运行Sender和Receiver，结果如下：</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.1.1.png" alt="图4.1" title="Optional title"></p><p>阅读代码，发现进行互斥操作的部分如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6. Operation procedure</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;      <span class="comment">//first sem(index=0)</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;           <span class="comment">//Increase 1,make sem=1</span></span><br></pre></td></tr></table></figure><p>将两份代码中的此部分全部注释，再次运行，发现接收端无法正常接受到内容（不输出提示信息），发送端可以正常发送，并且可以正常结束掉进程（输入end），结果如下：</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.1.2.png" alt="图4.2" title="Optional title"></p><p>由于是在两个终端下运行，且是<strong>先运行了发送端</strong>，根据上面的结果可以推断，如果先运行的是接收端，那么发送端的提示信息同样无法显示。总的来说，注释掉互斥部分后，代码无法正常运行。</p><p>在原来的基础上添加代码，使得代码可以输出共享内存的标示号<strong>shm_id</strong>。再次运行程序，发现两程序的共享内存标示号是一致的，这意味着它们所使用的共享内存的地址空间是一致的。<br>那么，由此可以推断<strong>共享内存的解释为：允许两个或多个进程共享一个给定的存储区。</strong></p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.1.3.png" alt="图4.3" title="Optional title"></p><ul><li>（2）运行无名管道程序，如下所示：</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.2.1.png" alt="图4.4" title="Optional title"></p><p>无名管道通行作为Linux进程通信中的一种，是UNXI系统IPC中最古老的一种。对于无名管道来说，他有如下特点：</p><ul><li>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。 </li><li>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间），实现依赖父子进程文件共享。 </li><li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 </li><li>它是阻塞读写的。</li></ul><p>对于Linux管道文件来说，可以使用两种读写方式：阻塞读写与非阻塞读写。所谓<strong>阻塞读写</strong>，是<strong>无论是先读还是先写都要等到另一个操作才能离开阻塞</strong>。也就是：如果先读，陷入阻塞，等待写操作；如果先写，陷入阻塞，等待读操作。对应的有非阻塞读写，它们无须等待另一个操作的，直接执行read()或者write()能读就读，能写就写，不能就返回-1。</p><p>分别在两个终端上运行有名管道程序的读和写端，如下所示：</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.2.2.png" alt="图4.5" title="Optional title"></p><p>对于该程序来说，运行过程中，<strong>先运行写端后运行读端，当在运行写端输入内容并输入回车键之后，读端读出管道文件中的数据，并在同一时刻与写端一起结束</strong>，这种运行方式下，可以完成给定的要求。但是，如果把两端的运行顺序更换，变成<strong>先运行读端后运行写端</strong>，那么可以清楚的发现，<strong>给定功能会失效</strong>，对于写端来说，甚至不会输出提示信息。由此我们可以推断，有名管道的也是阻塞读写的，当读端占据了管道后，写端无法进入，该流程就无法达到原有的效果。换言之，<strong>该程序正确运行顺序为先运行写端，再运行读端，最后在写端内写入数据并输入回车</strong>，否则程序会因为<strong>初始的管道中无数据且先进入的读端阻塞了写端导致失效</strong>。</p><ul><li>（3）分别在两个终端上运行消息队列程序的读和写端，如下所示：</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.3.1.png" alt="图4.6" title="Optional title"></p><p>对于消息队列而言，它的机制非常类似于第三题中的输入和输出程序。可以推断，<strong>消息队列也是阻塞读写的</strong>。而且它还必须拥有<strong>队空阻塞读和队满阻塞写</strong>的机制，才可以真正的实现完整的传输机制。针对这样的推断进行实验，发现是正确的。</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab3/4.3.2.png" alt="图4.7" title="Optional title"></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>查阅资料，发现规定进程上下文切换的代码位于/threads/switch.h和/threads/switch.S中。对于该门课程原本的实验来说，这一部分的内容包含在实验一：thread里面。实验原理是通过bochs加载pintos操作系统，该操作系统会根据pintos的实现打印运行结果，通过比较标准输出文档和实际输出，来判断pintos实现是否符合要求。</p><p>如果想要了解该系统的上下文切换，我们就不得不去了解timer_sleep函数（/devices/timer.c）。系统原本是使用busy wait实现的，即线程不停地循环，直到时间片耗尽。timer_sleep的实现方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sleeps for approximately TICKS timer ticks.  Interrupts must</span></span><br><span class="line"><span class="comment">   be turned on. */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">timer_sleep (<span class="keyword">int64_t</span> ticks)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> start = timer_ticks ();</span><br><span class="line">  ASSERT (intr_get_level () == INTR_ON);</span><br><span class="line">  <span class="keyword">while</span> (timer_elapsed (start) &lt; ticks)</span><br><span class="line">    thread_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于timer_ticks函数来说，有intr_level通过intr_disable返回了一内容。继续向下寻找，可以明显发现，intr_level代表能否被中断，而intr_disable做了两件事情：调用intr_get_level()、直接执行汇编代码，调用汇编指令来保证这个线程不能被中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the current interrupt status. */</span></span><br><span class="line"><span class="keyword">enum</span> intr_level</span><br><span class="line">intr_get_level (<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Push the flags register on the processor stack, then pop the</span></span><br><span class="line"><span class="comment">     value off the stack into `flags&#x27;.  See [IA32-v2b] &quot;PUSHF&quot;</span></span><br><span class="line"><span class="comment">     and &quot;POP&quot; and [IA32-v3a] 5.8.1 &quot;Masking Maskable Hardware</span></span><br><span class="line"><span class="comment">     Interrupts&quot;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;pushfl; popl %0&quot;</span> : <span class="string">&quot;=g&quot;</span> (flags))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flags &amp; FLAG_IF ? INTR_ON : INTR_OFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数一样是调用了汇编指令，把标志寄存器的东西放到处理器棧上，然后把值pop到flags（代表标志寄存器IF位）上，通过判断flags来返回当前终端状态(intr_level)。</p><p>至此，函数嵌套了这么多层，整理逻辑：</p><ol><li><p>intr_get_level返回了intr_level的值</p></li><li><p>intr_disable获取了当前的中断状态， 然后将当前中断状态改为不能被中断， 然后返回执行之前的中断状态。</p></li></ol><p>有以上结论我们可以知道： timer_ticks的intr_get_level做了如下的事情： 禁止当前行为被中断， 保存禁止被中断前的中断状态（用old_level储存）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the current interrupt status. */</span></span><br><span class="line"><span class="comment">/* Enables or disables interrupts as specified by LEVEL and</span></span><br><span class="line"><span class="comment">   returns the previous interrupt status. */</span></span><br><span class="line"><span class="keyword">enum</span> intr_level</span><br><span class="line">intr_set_level (<span class="keyword">enum</span> intr_level level) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> level == INTR_ON ? intr_enable () : intr_disable ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于timer_ticks剩下的内容来说，就是用t获取了一个全局变量ticks, 然后返回， 其中调用了set_level函数。set_level的实现机制，根据上述内容容易得出： 如果之前是允许中断的（INTR_ON）则enable否则就disable。intr_enable的实现和之前基本一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enables interrupts and returns the previous interrupt status. */</span></span><br><span class="line"><span class="keyword">enum</span> intr_level</span><br><span class="line">intr_enable (<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_get_level ();</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable interrupts by setting the interrupt flag.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     See [IA32-v2b] &quot;STI&quot; and [IA32-v3a] 5.8.1 &quot;Masking Maskable</span></span><br><span class="line"><span class="comment">     Hardware Interrupts&quot;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;sti&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> old_level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接返回了是否外中断的标志in_external_intr，就是说ASSERT断言这个中断不是外中断（IO等， 也称为硬中断）而是操作系统正常线程切换流程里的内中断（也称为软中断）。至此，我们可以分析出Pintos系统保持原子性的语句，即使用如下的语句包裹：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enables interrupts and returns the previous interrupt status. */</span></span><br><span class="line"><span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line">...</span><br><span class="line">intr_set_level (old_level);</span><br></pre></td></tr></table></figure><p>对于ticks来说，从pintos被启动开始，ticks就一直在计时，代表着操作系统执行单位时间的前进计量。现在回过来看timer_sleep这个函数，start获取了起始时间，然后断言必须可以被中断，不然会一直死循环下去。</p><p>然后就是如下循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enables interrupts and returns the previous interrupt status. */</span></span><br><span class="line"><span class="keyword">while</span> (timer_elapsed (start) &lt; ticks)</span><br><span class="line">thread_yield();</span><br></pre></td></tr></table></figure><p>注意这个ticks是函数的形参不是全局变量，然后看一下这两个函数：对于timer_elapsed来说，它返回了当前时间距离then的时间间隔，那么这个循环实质就是在ticks的时间内不断执行thread_yield。最后来看thread_yield：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Yields the CPU.  The current thread is not put to sleep and</span></span><br><span class="line"><span class="comment">   may be scheduled again immediately at the scheduler&#x27;s whim. */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">thread_yield (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">thread_current</span> ();</span></span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">if</span> (cur != idle_thread)</span><br><span class="line">    list_push_back (&amp;ready_list, &amp;cur-&gt;elem);</span><br><span class="line">  cur-&gt;status = THREAD_READY;</span><br><span class="line">  schedule ();</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread_current很明显是返回当前线程起始指针位置。第9行断言是个软中断，第11行至第16包裹起来的就是我们之前分析的线程机制保证的一个原子性操作。对于第12行到15行，如何当前线程不是空闲的线程就调用list_push_back把当前线程的元素扔到就绪队列里面， 并把线程改成THREAD_READY状态。</p><p>15行调用schedule:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Schedules a new process.  At entry, interrupts must be off and</span></span><br><span class="line"><span class="comment">   the running process&#x27;s state must have been changed from</span></span><br><span class="line"><span class="comment">   running to some other state.  This function finds another</span></span><br><span class="line"><span class="comment">   thread to run and switches to it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   It&#x27;s not safe to call printf() until thread_schedule_tail()</span></span><br><span class="line"><span class="comment">   has completed. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">schedule (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">cur</span> = <span class="title">running_thread</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">next</span> = <span class="title">next_thread_to_run</span> ();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  ASSERT (intr_get_level () == INTR_OFF);</span><br><span class="line">  ASSERT (cur-&gt;status != THREAD_RUNNING);</span><br><span class="line">  ASSERT (is_thread (next));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur != next)</span><br><span class="line">    prev = switch_threads (cur, next);</span><br><span class="line">  thread_schedule_tail (prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，首先获取当前线程cur和调用next_thread_to_run获取下一个要run的线程，如果就绪队列空闲直接返回一个空闲线程指针， 否则拿就绪队列第一个线程出来返回。如果当前线程和下一个要跑的线程不是同一个的话调用switch_threads返回给prev。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Switches from CUR, which must be the running thread, to NEXT,</span></span><br><span class="line"><span class="comment">    which must also be running switch_threads(), returning CUR in</span></span><br><span class="line"><span class="comment">    NEXT&#x27;s context. */</span></span><br><span class="line"><span class="function">struct thread *<span class="title">switch_threads</span> <span class="params">(struct thread *cur, struct thread *next)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>这个函数实现是用汇编语言实现的在threads/switch.S里</strong>。分析一下这个汇编代码： 先4个寄存器压栈保存寄存器状态（保护作用）， 这4个寄存器是switch_threads_frame的成员，然后全局变量thread_stack_ofs记录线程和栈之间的间隙，我们都知道线程切换有个保存现场的过程，先把当前的线程指针放到eax中，并把线程指针保存在相对基地址偏移量为edx的地址中，切换到下一个线程的线程棧指针，保存在ecx中，再把这个线程相对基地址偏移量edx地址（上一次保存现场的时候存放的）放到esp当中继续执行。这里ecx，eax起容器的作用，edx指向当前现场保存的地址偏移量。简单来说就是保存当前线程状态，恢复新线程之前保存的线程状态。然后再把4个寄存器拿出来，这个是硬件设计要求的，必须保护switch_threads_frame里面的寄存器才可以destroy掉eax， edx， ecx。然后注意到现在eax(函数返回值是eax)就是被切换的线程栈指针。我们由此得到一个结论，schedule先把当前线程丢到就绪队列，然后把线程切换如果下一个线程和当前线程不一样的话。</p><p>至此，schedule的重点部分分析完成。逻辑继续向上回溯：</p><p>thread_schedule_tail其实就是获取当前线程，分配恢复之前执行的状态和现场，如果当前线程死了就清空资源。 </p><p>schedule其实就是拿下一个线程切换过来继续run。</p><p>thread_yield其实就是把当前线程扔到就绪队列里，然后重新schedule，注意这里如果ready队列为空的话当前线程会继续在cpu执行。</p><p>最后回溯到我们最顶层的函数逻辑：timer_sleep就是在ticks时间内，如果线程处于running状态就不断把他扔到就绪队列不让他执行。</p><p>我们对原来的timer_sleep的实现方式有了十分清楚的理解了，我们也很清楚的看到了它的缺点：此时的线程不断在cpu就绪队列和running队列之间来回（包括整个线程的上下文切换也是其中的一个部分），占用了cpu资源。</p><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="https://www.cnblogs.com/Jimmy1988/p/7699351.html">消息队列：https://www.cnblogs.com/Jimmy1988/p/7699351.html</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/Jimmy1988/p/7553069.html">管道：https://www.cnblogs.com/Jimmy1988/p/7553069.html</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/Jimmy1988/p/7706980.html">共享内存：https://www.cnblogs.com/Jimmy1988/p/7706980.html</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/secondtonone1/p/5580203.html">pthread_cond_wait学习笔记：https://www.cnblogs.com/secondtonone1/p/5580203.html</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/laiy/p/pintos_project1_thread.html">Pintos-斯坦福大学操作系统Project详解-Project1：https://www.cnblogs.com/laiy/p/pintos_project1_thread.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;br&gt;代码、文章及图片挂载地址：&lt;a href=&quot;https://github.com/MoyangSensei/OS&quot;&gt;https://github.com/MoyangSensei/OS&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统二：进程控制</title>
    <link href="http://example.com/2019/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2019/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2019-03-17T06:01:48.000Z</published>
    <updated>2019-04-07T11:48:00.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原创文章，转载、引用请注明出处！<br>代码、文章及图片挂载地址：<a href="https://github.com/MoyangSensei/OS">https://github.com/MoyangSensei/OS</a></p></blockquote><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li><p>1 进程的创建：Linux中，载入内存并执行程序映像的操作与创建一个新进程的操作是分离的。将程序映像载入内存，并开始运行它，这个过程称为运行一个新的程序，相应的系统调用称为exec系统调用。而创建一个新的进程的系统调用是fork系统调用。</p></li><li><p>2 exec系统调用：execl()将path所指路径的映像载入内存，arg是它的第一个参数。参数可变长。参数列表必须以NULL结尾。通常execl()不会返回。成功的调用会以跳到新的程序入口点作为结束。发生错误时，execl()返回-1，并设置errno值。</p></li><li><p>3 fork系统调用：成功调用fork()会创建一个新的进程，它与调用fork()的进程大致相同。发生错误时，fork()返回-1，并设置errno值。</p></li><li><p>4 终止进程：exit()、段地址错误、kill -9</p></li><li><p>5 进程挂起：pause()。函数pause会把进程挂起，直到接收到信号。在信号接收后，进程会从pause函数中退出，继续运行。</p></li><li><p>5 等待子进程中断或结束：wait()</p></li><li><p>6 vim常用命令</p></li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/0.png" alt="vim常用命令" title="Optional title"></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li>1 打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有进程的ID和父进程ID。将得到的进程树和由pstree命令的得到的进程树进行比较。</li></ul><ul><li>2 编写程序，首先使用fork系统调用，创建子进程。在父进程中继续执行空循环操作；在子进程中调用exec打开vi编辑器。然后在另外一个终端中，通过ps –Al命令、ps aux或者top等命令，查看vi进程及其父进程的运行状态，理解每个参数所表达的意义。选择合适的命令参数，对所有进程按照cpu占用率排序。</li></ul><ul><li>3 使用fork系统调用，创建如下进程树，并使每个进程输出自己的ID和父进程的ID。观察进程的执行顺序和运行状态的变化。</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/00.png" title="Optional title"></p><ul><li>4 修改上述进程树中的进程，使得所有进程都循环输出自己的ID和父进程的ID。然后终止p2进程(分别采用kill -9 、自己正常退出exit()、段错误退出)，观察p1、p3、p4、p5进程的运行状态和其他相关参数有何改变。</li></ul><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><ul><li><p>（1）创建vi进程：启动Linux终端，直接输入“vi”并回车就可进入vi界面。</p></li><li><p>（2）由于我们需要寻找到刚才所打开的进程的PID。值得注意的是，在本题目中我们所要寻找的进程非常的容易寻见，因为在我们运行Linux的时候，并没有进行其他的操作，即此时并没有特别多的进程在运行。此时直接使用如下命令：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ps -A</span><br></pre></td></tr></table></figure><p>然后直接在所有进程中人工匹配进程名即可。</p><p>但我们都知道，实际情况并不是理想的。我们需要一条命令，通过进程的名称帮助我们匹配和查找进程的具体信息。首先我们用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pgrep [str] </span><br></pre></td></tr></table></figure><p>进行模糊匹配，找到匹配该特征串的进程ID，再根据进程ID显示指定的进程信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ps --pid [pid]；</span><br></pre></td></tr></table></figure><p>因为查找出来的进程ID需要被作为参数传递给ps命令，故使用xargs命令，通过管道符号连接。最后我们需要进程的详细信息，故需要加上-u参数。</p><p>综上，如果我们需要通过名称“vi”来匹配查找某些进程的具体信息，则可以使用以下的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pgrep vi | xargs ps -u --pid</span><br></pre></td></tr></table></figure><p>于是，我们启动另一个终端，输入上述命令，就可以在已经进行过名称匹配的进程中查找我们需要的内容。</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/1.1.png" alt="图1.1" title="Optional title"></p><p>如上图标注，我们要寻找的vi的进程号为42907。</p><ul><li>（3）寻找vi进程的父进程，我们需要使用它的进程号并使用如下命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ps -ef |grep pid</span><br></pre></td></tr></table></figure><p>其中，ps命令将某个进程显示出来，它是LINUX下最常用的也是非常强大的进程查看命令；grep命令是的功能查找，它是一种强大的文本搜索工具，能使用正则表达式搜索文本，并把匹配的行打印出来，其全称是Global Regular Expression；而中间的“|”是管道命令，是指ps命令与grep同时执行。</p><p>通过多步查找，直到查找到<strong>init进程</strong>，其进程号为<strong>1</strong>。</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/1.2.png" alt="图1.2" title="Optional title"></p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/1.3.png" alt="图1.3" title="Optional title"></p><ul><li>（4）我们可以使用如下命令来查看进程树，并打印每个进程的PID：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pstree -p</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/1.4.png" alt="图1.4" title="Optional title"></p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/1.5.png" alt="图1.5" title="Optional title"></p><p>根据图中标注，我们可以看到vi进程的进程树为：<strong>1 -&gt; 953 -&gt; 1209 -&gt; 1360 -&gt; 42888 -&gt; 42894 -&gt; 42907</strong>，与上面的结果完全一致。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><ul><li>（1）根据题意编写代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> p1,p2;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p1=fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!p1)&#123;</span><br><span class="line">        <span class="keyword">while</span>((p2=fork()) == <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//使用进程2打开vi</span></span><br><span class="line">        <span class="keyword">if</span>(!p2)&#123;</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            ret = execlp(<span class="string">&quot;vi&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERROR!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//进程1设置为无限循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>（2）使用<strong>ps -Al</strong>命令查看信息，结果如下：</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/2.1.png" alt="图2.1" title="Optional title"></p><p>参数如下图所示：</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/2.11.png" alt="图2.2" title="Optional title"></p><p>这些参数所表示的意义为：</p><table><thead><tr><th align="center">参数名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">F</td><td align="center">flag，4表示用户为超级用户</td></tr><tr><td align="center">S</td><td align="center">stat，状态</td></tr><tr><td align="center">PID</td><td align="center">进程ID</td></tr><tr><td align="center">PPID</td><td align="center">父进程ID</td></tr><tr><td align="center">C</td><td align="center">CPU使用资源的百分比</td></tr><tr><td align="center">PRI</td><td align="center">priority，优先级</td></tr><tr><td align="center">NI</td><td align="center">Nice值</td></tr><tr><td align="center">ADDR</td><td align="center">核心功能，指出该进程在内存的哪一部分</td></tr><tr><td align="center">SZ</td><td align="center">用掉的内存的大小</td></tr><tr><td align="center">WCHAN</td><td align="center">当前进程是否正在运行，若为“-”表示正在进行</td></tr><tr><td align="center">TTY</td><td align="center">登陆者的终端位置</td></tr><tr><td align="center">TIME</td><td align="center">用掉的CPU的时间</td></tr><tr><td align="center">CMD</td><td align="center">所执行的指令</td></tr></tbody></table><ul><li>（3）使用<strong>ps -aux</strong>命令查看信息，结果如下：</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/2.2.png" alt="图2.3" title="Optional title"></p><p>参数如下图所示：</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/2.22.png" alt="图2.4" title="Optional title"></p><p>这些参数所表示的意义为：</p><table><thead><tr><th align="center">参数名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">USER</td><td align="center">进程的属主</td></tr><tr><td align="center">PID</td><td align="center">进程ID</td></tr><tr><td align="center">PPID</td><td align="center">父进程ID</td></tr><tr><td align="center">%CPU</td><td align="center">进程占用的CPU百分比</td></tr><tr><td align="center">%MEM</td><td align="center">占用内存的百分比</td></tr><tr><td align="center">NI</td><td align="center">NICE值，数值大，表示较少占用CPU时间</td></tr><tr><td align="center">VSZ</td><td align="center">发进程使用的虚拟内存量（KB）</td></tr><tr><td align="center">RSS</td><td align="center">该进程占用的固定内存量（KB）（驻留中页的数量）</td></tr><tr><td align="center">TTY</td><td align="center">该进程在哪个终端上运行，若与终端无关，则显示“？”；若为pts/0等，则表示由网络连接主机进程</td></tr><tr><td align="center">WCHAN</td><td align="center">当前进程是否正在进行，若为“-”表示正在进行</td></tr><tr><td align="center">START</td><td align="center">该进程的启动时间</td></tr><tr><td align="center">TIME</td><td align="center">占用CPU的时间</td></tr><tr><td align="center">COMMAND</td><td align="center">命令的名称和参数</td></tr></tbody></table><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><ul><li>（1）由题图可编写如下程序：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> p1,p2,p3,p4,p5;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p1=fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!p1)&#123;</span><br><span class="line">        <span class="keyword">while</span>((p2=fork()) == <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> ((p4=fork())==<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!p4)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Node p4 is p2&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> ((p5=fork())==<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!p5)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Node p5 is p2&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Node p2 is p1&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((p3=fork()) == <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!p3)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Node p3 is p1&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node p1 is parent with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>（2）分别运行两次该程序，可发现它们的输出顺序是不同的。或者说是随机的，但这个随机是在满足如上所示的进程树的情况下的“随机”，且仅是一个节点的左右节点会出现顺序的随机，不会出现“越级”的随机。</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/3.png" alt="图3.1" title="Optional title"></p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><ul><li>（1）根据第三题的代码修改，为每个进程的输出加上无限循环**while(1)**即可：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> p1,p2,p3,p4,p5;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p1=fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!p1)&#123;</span><br><span class="line">        <span class="keyword">while</span>((p2=fork()) == <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> ((p4=fork())==<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!p4)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Node p4 is p2&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span> ((p5=fork())==<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!p5)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Node p5 is p2&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">                sleep(<span class="number">2</span>);&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Node p2 is p1&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exit退出进程</span></span><br><span class="line">        <span class="comment">//exit(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用段地址错误退出进程</span></span><br><span class="line">        <span class="comment">//int *ptr = (int *)0;</span></span><br><span class="line">        <span class="comment">//*ptr = 100;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((p3=fork()) == <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!p3)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Node p3 is p1&#x27;s child with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">2</span>);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Node p1 is parent with pid %d, it&#x27;s parent pid %d.\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    sleep(<span class="number">2</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同第三题一样，它们内部的输出顺序是由略微不同的，但整体的输出是5个节点全部输出完成之后再进行下一回合的输出。sleep函数用于减慢输出速度便于观察。</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/4.1.png" alt="图4.1" title="Optional title"></p><ul><li>（2）使用kill -9终止进程2。首先，kill是Linux里非常常用的一个命令，其作用如同字面意思一样，用来“杀死”进程。而kill -n中的数字n表示信号编号(signnum)。默认参数下，kill发送SIGTERM（15）信号给进程，告诉进程需要被关闭，请自行停止运行并退出。而kill -9 发送SIGKILL信号给进程，告诉进程，你被终结了，请立刻退出。TERM(或数字9）表示“无条件终止”；因此 kill - 9 表示强制杀死该进程；与SIGTERM相比，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理。</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/4.2.png" alt="图4.2" title="Optional title"></p><ul><li>（3）使用exit()终止进程2。exit()函数为退出函数，将其放入p2的循环中即可。</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/4.3.png" alt="图4.3" title="Optional title"></p><ul><li>（4）使用段地址错误终止进程2。段错误就是指访问的内存超出了系统所给这个程序的内存空间，如（1）中代码所示，我们为进程2的无限循环加上一个“野指针”即可达到目的。</li></ul><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/lab2/4.4.png" alt="图4.4" title="Optional title"></p><ul><li>（5）可以发现，通过各种方式“杀死”进程2之后，进程2不再存在，其子程序进程4和5却仍然存在，并能完成输出信息的任务，但其PPID变为1号进程的PPID。这是因为，调用fork产生一个子进程，同时父进程退出。我们所有后续工作都在子进程中完成。这样做我们可以交出控制台的控制权,并为子进程作为进程组长作准备;由于父进程已经先于子进程退出，会造成子进程没有父进程，变成一个孤儿进程（orphan）。<strong>每当系统发现一个孤儿进程，就会自动由1号进程收养它，这样，原先的子进程就会变成1号进程的子进程，即1360号进程。</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原创文章，转载、引用请注明出处！&lt;br&gt;代码、文章及图片挂载地址：&lt;a href=&quot;https://github.com/MoyangSensei/OS&quot;&gt;https://github.com/MoyangSensei/OS&lt;/a&gt;&lt;/p&gt;
&lt;/b</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
